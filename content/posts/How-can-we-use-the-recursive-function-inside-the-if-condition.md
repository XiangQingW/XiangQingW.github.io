---

title: 我们如何在IF条件内使用递归函数？
date: 2022-01-23T22:08:06+08:00

---




## 我们如何在IF条件内使用递归函数？  
### 回答 1
一个例子可能是：开始  
你几乎不得不。在任何类型的递归中，你必须有一种方法来逃避。如果你不这样递归永远不会结束，这很容易告诉，因为你的电脑会用完内存。  
您对IF语句的操作是检查条件是否为真或假的检查。如果True会递归，如果没有您完成此迭代，请返回上一个迭代。最终你会回到第一次迭代，你已经完成了。还有其他方法可以检查失败吗？当然，但如果声明可能会是最常用的。  
一个示例可能是：从C驱动器开始，检查子目录。如果有任何（true）采取您获得的第一个，并提出完全相同的检查（重复）。如果您没有找到任何（false），请返回上一个实例并检查下一个实例。  
### 回答 2
你的意思是这样的东西吗？  
<ol> def f（n，k = 2）：如果k> = n：返回false：if（k <n和n％k == 0）或f（n，k + 1）：返回true：返回false </ OL>  
<li> def f（n，k = 2）：</ li>  
<li>如果k> = n：返回false </ li>  
<li> if（k <n和n％k == 0）或f（n，k + 1）：</ li>  
<li>返回true </ li>  
<li> else：</ li>  
<li>返回false </ li>  
如果n个是素数，则函数f返回false。你称之为f（100）。  
请注意，它在第二次语句中如何使用递归来实现它。  
在侧面，这不是一种检查素数的有效方法。  
### 回答 3
只需称之为 - 它在任何逻辑条件内使用的表达式都没有条件。  
### 回答 4
它基本上是使用递归的唯一方法，因为您需要递归的停止条件。  
以下是Python的示例，用于阶段函数：  
<ol> def因子（n）：如果n == 0：返回另外一个：return n * arberial（n-1）</ ol>  
<li> def因子（n）：</ li>  
<li>如果n == 0：</ li>  
<li>返回1 </ li>  
<li> else：</ li>  
<li>返回n *因子（n-1）</ li>  
或者更紧凑如下：  
<ol> def因子（n）：返回1如果n == 0 else n * armantial（n-1）</ ol>  
<li> def因子（n）：</ li>  
<li>返回1如果n == 0 else n * arberial（n-1）</ li>  
### 回答 5
似乎这是一个C ++特定问题，所以应该适当地标记它。实际上，std :: fornt和std :: list有迭代器，而std :: stack和std :: queue不。  
STD :: Stack和STD ::队列容器适配器被认为是尽可能普遍的。这些模板不了解如何存储和检索其元素。您必须提供一个具体的容器类型，例如std :: deque或std ::列表，其物理存储内存中的元素。堆栈或队列将简单地将存储和检索委托给底层容器。  
堆栈需要返回（），push_back（）和pop_back（）操作。队列需要Front（），back（），push_back（）和pop_front（）。因此，当您将元素推入队列时，它会在底层容器上调用push_back（）等。  
为了使堆栈和队列支持迭代，他们必须要求底层容器也表现。因此，如果您发明了支持Front（），back（），push_front（），push_back（），pop_front（）和pop_back（）的新容器，但不迭代，则无法使用该容器来构建堆栈或队列。因此，堆栈和队列适配器不会尽可能普遍。  
如果您需要迭代，请考虑使用STD :: DEQUE直接。  
编辑：您也可以从STD :: Stack和STD ::队列容器继承，从而继承Push和Pop成员函数。下面的容器作为受保护成员C暴露。因此，您可以创建一个具有增强功能的容器，包括迭代器，如果您如此希望，通过要求派生类模板与具有更严格的要求的容器实例化。但是，请注意，STD :: Stack和STD ::队列缺少虚拟析构函数，因此您不能通过指向基类的指针删除派生类的对象。  
### 回答 6
不，我甚至不确定人们对它的困惑。我有一个理论：  
查看以下递归函数。  
<ol> int因子（int n）{if（n == 0）返回1; int m =因子（n-1）;返回n * m; } </ OL>  
<li> int因子（int n）{</ li>  
<li>如果（n == 0）返回1; </ Li>  
<li> int m =因子（n-1）; </ Li>  
<li>返回n * m; </ Li>  
<li>} </ li>  
用我读这个。  
第1行。定义一个函数因子，它具有整数作为输入，最终也将最终输出整数。好的。  
第2.如果我们计算零的因子，那么答案是1.因为0！= 1。好的。  
第3行。首先计算N-1的因子。只需一秒钟！那是什么意思！？我想我必须回到顶部或什么？所以现在  
不，我甚至不确定人们对它的困惑。我有一个理论：  
查看以下递归函数。  
<ol> int因子（int n）{if（n == 0）返回1; int m =因子（n-1）;返回n * m; } </ OL>  
<li> int因子（int n）{</ li>  
<li>如果（n == 0）返回1; </ Li>  
<li> int m =因子（n-1）; </ Li>  
<li>返回n * m; </ Li>  
<li>} </ li>  
用我读这个。  
第1行。定义一个函数因子，它具有整数作为输入，最终也将最终输出整数。好的。  
第2.如果我们计算零的因子，那么答案是1.因为0！= 1。好的。  
第3行。首先计算N-1的因子。只需一秒钟！那是什么意思！？我想我必须回到顶部或什么？所以现在我们在第2行，一个少，而且......使困惑。  
如果这就是你的困惑，那么使用这个伎俩，由妈妈发现：暂停怀疑。只需从功能阶乘正确计算阶乘所示的一开始就是假设。让我们再试一次：  
第3行。首先计算N-1的因子。呃......我想...是的！就是那种精神！暂停怀疑！不要担心！如果你这么说。我这么说。让我们继续。  
第4行将N-1的因子乘以n以获取n的因子，并返回结果。这再次有意义。它确实如此，不是吗？  
所以现在你确实验证了这个功能是有道理的，你只是没有回到顶部，然后再次回到顶部，再次丢失又丢失。这就是你应该避免的。它将允许您了解该功能如何工作，而不将您的大脑绑在结。  
好的，完整性，暂停怀疑真的好吗？我的意思是，我们可以去：  
<ol> int因子（int n）{返回因子（n）; } </ OL>  
<li> int因子（int n）{</ li>  
<li>返回因子（n）; </ Li>  
<li>} </ li>  
不：有两个要求：  
如果这两件事有序，则有必要暂停怀疑伎俩。  
最后一句话，我后来发现了托马斯科伦的答案，提供了非常相似的视角。  
### 回答 7
对于困难（不可能的？）来计算而没有递归的函数的示例，请参阅Ackermann函数。  
但是，*是*人工功能。要指出，以递归方式最容易描述的问题更为真实，通常以递归方式最典雅地解决。优雅很重要，因为它很容易相信优雅的解决方案是正确的。  
例如，尝试编写代码来解析文件目录结构。递归和作为循环进行递归。根据您作为程序员的体验和技能，我怀疑循环版本将需要更长的时间到调试*，*完成后可能会有未检测到的错误。递归版本更有可能是正确的。解析无背景语言是另一个递归的情况简化了编码。  
事实是递归算法的循环版本必须（通过问题的性质）实现堆栈和所有用于递归的机制的所有机制。这大大复杂化了代码并使其更加努力，更容易。  
起初可能很难理解递归，但如果你在两种方式递归结构的问题中，你都会很快就会欣赏它。  
最后，递归的定义（不是我自己的原始的定义，但我喜欢它）：  
递归：如果您了解递归，则停止否则请参阅递归。  
