---

title: 为什么浮点另外比整数加入更复杂吗？
date: 2022-01-23T22:08:18+08:00

---




## 为什么浮点另外比整数加入更复杂吗？  
### 回答 1
你有没有在科学符号中与数字合作，如3.14159×1063.14159×106和8.67530×109？8.67530×109？  
你如何添加那些，并产生结果到相同数量的有效数字？  
你不添加这些，就像你一样是整数：  
+ 3.141598.6753011.81689×106×109×10 ??错误！3.14159×106 + 8.67530×10911.81689×10？错了！  
显然没有意义。首先，您必须对准数字，以便数字共享10的公共功率。  
\ begin {eqnarray}＆0.00314159＆\ times 10 ^ 9 \\ + \ enspace和8.67530000＆\ times \ begin {eqnarray}＆\ times 10 ^ 9 \\ + \ enspace＆8.67530000＆\ times  
你有没有在科学符号中与数字合作，如3.14159×1063.14159×106和8.67530×109？8.67530×109？  
你如何添加那些，并产生结果到相同数量的有效数字？  
你不添加这些，就像你一样是整数：  
+ 3.141598.6753011.81689×106×109×10 ??错误！3.14159×106 + 8.67530×10911.81689×10？错了！  
显然没有意义。首先，您必须对准数字，以便数字共享10的公共功率。  
+ 0.00300008.67844159×109×109×1090.00314159×109 + 8.67530000×1098.67844159×109  
然后我们需要将值达到6个有效数字，产生8.67844×109.8.67844×109。  
现在，假设我们执行此减法：  
-8.678448.675300.00314×109×109×1098.67844×109-8.67530×1090.00314×109  
我们的结果，0.00314×109,0.00314×109，需要重整为3.14000×106.3.14000×106。  
我们刚计算表单（A + B）-B的表达。（A + B）-B。而且我们将自己限制在科学符号中的6位数，因此您可以看到我们没有收到A，A的原始值。  
希望对你相当熟悉。  
事实证明，浮点几乎完全适合于具有固定精度的科学符号。二进制浮点只是恰好使用底座2而不是底座10.有小数浮点存在这样的东西;然而，它在银行和交易处理中发现的大铁外罕见。  
在硬件中，浮点加法器包括额外的逻辑，以将Addends对齐，以及额外的逻辑循环，并将结果正常化。  
以下链接答案在浮点添加时提供了有关角落案例的更多细节。它链接到额外的答案，覆盖浮点的变幻物变形虫。也许你会发现秘密机器人互联网！  
<span> joe zbiciak·7mo </ span>  
<span> 7mo </ span>  
¹例如，有一些关于无穷大的额外规则，签名零，逐渐下溢，纳米适用于IEEE 754浮点，但不一定适用于您在课堂上学的科学符号。  
### 回答 2
在整数添加中，添加1S地点，添加2S地点，添加4S地点等。您已经进行处理，这就是它的程度。  
在浮点......它不起作用。你的一个数字是1.00001110111011 x 2 ^ 7，另一个数字是1.110111010111100001 x 2 ^（ -  3）。  
不是疯狂的，但并不像整数版本一样简单。  
### 回答 3
因为它的混合想象你有这个数字  
3.42 x 10 ^ 3 + 5.81 x 10 ^ 5 + 9.12 x 10 ^ -2  
这种加容易比自然数更容易加成吗？  
嗯，以上是浮点（在基座10中）。  
现在有浮点是最糟糕的，因为。  
它不仅仅是这样，但你必须考虑你只能有一定的小数点，所有其他人都消失了  
为此，让我们想象一下我们只能获得6个（并且更多丢弃）  
为了能够正确地执行此操作，我们将把所有它们设​​置为共同指数。而且我们只能在点左侧有一个数字，然后是exponen  
因为它的混合想象你有这个数字  
3.42 x 10 ^ 3 + 5.81 x 10 ^ 5 + 9.12 x 10 ^ -2  
这种加容易比自然数更容易加成吗？  
嗯，以上是浮点（在基座10中）。  
现在有浮点是最糟糕的，因为。  
它不仅仅是这样，但你必须考虑你只能有一定的小数点，所有其他人都消失了  
为此，让我们想象一下我们只能获得6个（并且更多丢弃）  
为了能够正确地执行此操作，我们将把所有它们设​​置为共同指数。当我们左侧只能有一个数字时，在这种情况下，指数将必须是5  
3.42 x 10 ^ 3 = 0.342 x 10 ^ 4 = 0.0342 x 10 ^ 5（改变但在这里没有松散）  
5.81 x 10 ^ 5 = 5.81 x 10 ^ 5（没有变化）  
9.12 x 10 ^ -2 = 0.912 x 10 ^ -1 = 0.0912 x 10 ^ 0 = 0.00912 x 10 ^ 1 = 0.000912 x 10 ^ 2（这里是松散开始的地方，因为我们仍远远超过10 ^ 5和我们我们只能举行6个小数位的地方会发生什么  
0.000912 x 10 ^ 2 = 0.0000912 x 10 ^ 3，但我们的系统只能获得6位数，所以反而将存储0.000091 x 10 ^ 3然后  
0.000091 x 10 ^ 3 = 0.0000091 x 10 ^ 4，但再次转换为0.000009 x 10 ^ 4  
最后0.000009 x 10 ^ 4 = 0.000000009 x 10 ^ 5  - > 0.000000 x 10 ^ 5  
所以换句话说，最后的附加术语不会被添加  
0.0342 x 10 ^ 5 + 5.81 x 10 ^ 5，现在w刚刚加入它们  
5.8442 x 10 ^ 5  
（要添加它，我们只是制作普通因子10 ^ 5然后我们可以正常添加）  
这是我们试图计算的真正价值，不是因为它只是一个近似值  
这是浮点的主要问题并不是在任何总和或繁殖或任何东西上的唯一问题。  
很多人甚至不考虑这个问题的最糟糕的部分，愿意浮点是最好的数字（其实是最糟糕的）  
### 回答 4
CPU旨在使用二进制数字。添加/减去这些数字所需的逻辑相当直接。它还容易将许多这些二进制数字一起串联形成整数。  
浮点数不是CPU的自然部分。它由不同的部分（符号，尾数，指数）组成，需要由不同的二进制数字表示。需要不断换档并调整这些数字，以便可以完成添加。这需要更多的工作。  
### 回答 5
Joe Zbiciak给出了一个很好的答案，但我会给一个更简单的答案。  
什么是1除以3，次3？如果你在头脑中这样做，那就太微不足道了。这是1。  
在廉价的计算器上尝试一下。在我尝试过的大多数时候，你最终得到了.99999999。  
如果你最终结束了1，请尝试减去1.你可能会惊讶地看到你得到了-00000001  
这是事情。我们知道，如果我们将1划分为3，我们有三个1/3。如果我们将它们备份或乘以3，我们应该回到。  
但是，在计算机中这样做有点棘手。真的1除以3是.3333 ......它无限。我们很明显  
Joe Zbiciak给出了一个很好的答案，但我会给一个更简单的答案。  
什么是1除以3，次3？如果你在头脑中这样做，那就太微不足道了。这是1。  
在廉价的计算器上尝试一下。在我尝试过的大多数时候，你最终得到了.99999999。  
如果你最终结束了1，请尝试减去1.你可能会惊讶地看到你得到了-00000001  
这是事情。我们知道，如果我们将1划分为3，我们有三个1/3。如果我们将它们备份或乘以3，我们应该回到。  
但是，在计算机中这样做有点棘手。真的1除以3是.3333 ......它无限。我们显然无法在计算机中存储无限的长表示。所以，有些东西必须跟踪这一点。当我们乘以3时，我们必须跟踪我们真正恢复到1。  
那只是数学！  
### 回答 6
浮点算术必须处理舍入和精确的考虑因素。整数算术不是。  
### 回答 7
不。  
正如我在下面讨论的那样，它并非关联。然而，它是换向的。  
<span> joe zbiciak </ span>  
<SPAN>开发实际用于生产中的实用算法。</ span>  
IEEE 754浮点不是rr。它更像是QQ的古怪子集，其中分母被限制为2的力量。  
您链接的页面具有浮点的高电平描述，而不是专门的IEEE 754.并且它牺牲了保持概述简单的准确性。浮点数不得实际数字，但我们用浮点数近似真实。  
正常的IEEE 754浮点数是形式......  
±1.FFFFFF×2E±1.FFFFFF×2E  
...... ffffffffffff是一个固定数量的分数位，并且ee是签名的指数。  
人们说IEEE 754浮点添加（一般浮点）是非关联的，因为它是一个真正的陈述。它的真实即使你将自己限制为正常数字 - 没有亚极性，没有无限，没有NAN，没有签名的零。  
无论您选择哪种格式，它都有有限的精度。假设我们选择Binary32，单精度IEEE 754格式。在C和C ++中，这通常与浮动相关联。  
Binary32的分数部分仅为23位。因此，利用隐藏的1，有用的总共24位。  
继承你尝试，使用铅笔和纸张的东西。在IEEE 754 Binary32中工作这些添加问题。我建议手动工作，以便你看到第一手会发生什么。  
（-16777216⊕16777216）⊕1（-16777216⊕16777216）⊕1  
-16777216‖（16777216⊕1）-16777216‖（16777216⊕1）  
符号注意事项：我使用了Taocp的Knuths²大约：⊕⊕和⊖⊖表示浮点加法和减法，所有这些都意味着。  
此外，如果有帮助，16777216 = 22416777216 = 224。这些数字是有目的地简单的，并且不应该用手努力工作。您可以使用此转换器来检查您的工作。  
在默认的舍入模式中，第一个表达式应该评估为1，而第二个表达式应该在Binary32浮点算术中评估为0。  
我所做的就是移动括号来改变评估的顺序，它改变了结果。正如您所看到的，浮点另外并非关联！  
短语舍入模式应该是一个提示：如果您不保留确切的结果，您只需要舍入。 Binary32中16777216×116777216311的结果是不精确的，因为它不适于有效。  
Kahan Sumpation依赖于这种非关联性质来收集来自多元素总和的每个步骤的错误项，以提供更准确的结果。它在中间有一步，看起来代数冗余。 SS是总和，CICI是补偿（C0 = 0）（C0 = 0），并且AIAI是输入序列。在所有元素上迭代此序列。  
YTCI + 1。←←←←←←←AI-CIS + Y（T-S） - ←AI-CIT←S + YCI + 1←（T-S） - ←T  
第三步减去了SS和YY退出了TT。但TT只是S + Ys + Y！代数，每个CICI项应该是0。  
除了......我在上面做了一个错误！让我们解决这个问题。  
YTCI + 14s←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←AI⊖CIS⊕Y（T⊖s）⊖yty←AI⊖CIT←S⊕YCI+ 1←（T⊖s）⊖←  
我们去了。每个步骤都有浮点加法和减法，并且具有舍入错误。 CICI术语捕获。  
卡汉求和很好，但并不完美。 Shewchucks算法确保每次都有正确的圆形结果。  
如果您想挖掘浮点算术的更多细节，请阅读此答案，以及其中的其他几个链接到。  
<SPAN> JOE ZBICIAK·6MO </ SPAN>  
<span> 6mo </ span>  
¹Remember学习广场根源，并被告知你不能采取负数的平方根？然后一段时间后，他们介绍了I = -1 ---√i= -1和复数？类似的想法。  
²Knuth还将IEEE 754 Binary64实现为MMIX-ARITH的一部分。在MMIX文档页面上阅读。  
### 回答 8
IEEE 754浮点不是rr。它更像是QQ的古怪子集，其中分母被限制为2的力量。  
您链接的页面具有浮点的高电平描述，而不是专门的IEEE 754.并且它牺牲了保持概述简单的准确性。浮点数不得实际数字，但我们用浮点数近似真实。  
正常的IEEE 754浮点数是形式......  
±1.FFFFFF×2E±1.FFFFFF×2E  
...... ffffffffffff是一个固定数量的分数位，并且ee是签名的指数。  
人们说IEEE 754浮点添加（和  
IEEE 754浮点不是rr。它更像是QQ的古怪子集，其中分母被限制为2的力量。  
您链接的页面具有浮点的高电平描述，而不是专门的IEEE 754.并且它牺牲了保持概述简单的准确性。浮点数不得实际数字，但我们用浮点数近似真实。  
正常的IEEE 754浮点数是形式......  
±1.FFFFFF×2E±1.FFFFFF×2E  
...... ffffffffffff是一个固定数量的分数位，并且ee是签名的指数。  
人们说IEEE 754浮点添加（一般浮点）是非关联的，因为它是一个真正的陈述。它的真实即使你将自己限制为正常数字 - 没有亚极性，没有无限，没有NAN，没有签名的零。  
无论您选择哪种格式，它都有有限的精度。假设我们选择Binary32，单精度IEEE 754格式。在C和C ++中，这通常与浮动相关联。  
Binary32的分数部分仅为23位。因此，利用隐藏的1，有用的总共24位。  
继承你尝试，使用铅笔和纸张的东西。在IEEE 754 Binary32中工作这些添加问题。我建议手动工作，以便你看到第一手会发生什么。  
（-16777216⊕16777216）⊕1（-16777216⊕16777216）⊕1  
-16777216‖（16777216⊕1）-16777216‖（16777216⊕1）  
符号注意事项：我使用了Taocp的Knuths²大约：⊕⊕和⊖⊖表示浮点加法和减法，所有这些都意味着。  
此外，如果有帮助，16777216 = 22416777216 = 224。这些数字是有目的地简单的，并且不应该用手努力工作。您可以使用此转换器来检查您的工作。  
在默认的舍入模式中，第一个表达式应该评估为1，而第二个表达式应该在Binary32浮点算术中评估为0。  
我所做的就是移动括号来改变评估的顺序，它改变了结果。正如您所看到的，浮点另外并非关联！  
短语舍入模式应该是一个提示：如果您不保留确切的结果，您只需要舍入。 Binary32中16777216×116777216311的结果是不精确的，因为它不适于有效。  
Kahan Sumpation依赖于这种非关联性质来收集来自多元素总和的每个步骤的错误项，以提供更准确的结果。它在中间有一步，看起来代数冗余。 SS是总和，CICI是补偿（C0 = 0）（C0 = 0），并且AIAI是输入序列。在所有元素上迭代此序列。  
YTCI + 1。←←←←←←←AI-CIS + Y（T-S） - ←AI-CIT←S + YCI + 1←（T-S） - ←T  
第三步减去了SS和YY退出了TT。但TT只是S + Ys + Y！代数，每个CICI项应该是0。  
除了......我在上面做了一个错误！让我们解决这个问题。  
YTCI + 14s←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←AI⊖CIS⊕Y（T⊖s）⊖yty←AI⊖CIT←S⊕YCI+ 1←（T⊖s）⊖←  
我们去了。每个步骤都有浮点加法和减法，并且具有舍入错误。 CICI术语捕获。  
卡汉求和很好，但并不完美。 Shewchucks算法确保每次都有正确的圆形结果。  
如果您想挖掘浮点算术的更多细节，请阅读此答案，以及其中的其他几个链接到。  
<SPAN> JOE ZBICIAK·6MO </ SPAN>  
<span> 6mo </ span>  
¹Remember学习广场根源，并被告知你不能采取负数的平方根？然后一段时间后，他们介绍了I = -1 ---√i= -1和复数？类似的想法。  
²Knuth还将IEEE 754 Binary64实现为MMIX-ARITH的一部分。在MMIX文档页面上阅读。  
### 回答 9
这是一个问题的一个好例子，即一套神奇看起来真的很简单，但是得到了真正复杂的你进入细节的更深。我有点惊讶的是这个问题声称的一些其他答案，现代没有特殊的硬件CPU来处理部门甚至是它在软件中完成。这是事实上的错，也缺少了实际发生的事情。如果我们留在正常的英特尔兼容的PC架构，自奔腾以来的所有CPU  - 这就是着名的对于Miss，计算浮点分区 - 具有集成的浮点单元。Floation Point Co处理器已经存在较长，并且还有386和486个CPU（称为DX）的更昂贵的版本，其具有集成的8087数学共处理器.Later模型使用MMX，SSE和AVX的集成浮点功能演变，也引入了SIMD（单指令，多个数据）的概念，可以执行浮点操作在多个数字同时.Modern编译器完全能够利用这些指令，并不能在软件中模拟浮点操作，除非它们真的必须（例如，围绕已知的CPU错误或生成没有的平台代码浮点功能）。如果在划分浮点或双值时，请查看由GCC生成的汇编器代码，它将利用Divs或DivPD，它是AVX或SSE指令划分单个或双精度浮点号。要理解为什么划分更多的时间而不是乘法，我们必须实际定义更多的时间，并且如果前提甚至是真实的。从算法的角度来看，乘法和划分的最快已知算法是类似的复杂性等级。 O（n）和o（n log n）之间的区域。所以他们应该同样长久地 - 理论上，这是相当不同的，因为我们不处理任意的leng数量但受到CPU寄存器的长度的限制 - 这是在64位 -  512位之间的某个位置，具体取决于CPU的MMX，SSE或AVX的生成，在CPU语言中定义了时钟数量执行操作所需的周期。这也称为指令的延迟.https：//www.agner.org/optimize/instruction_tables.pdf对不同CPU平台上的浮点指令的延迟有一些非常有趣的数字.Let的作为一个榜样。我们看到的是，divss的延迟是muls的延迟率约为muls的延迟，并且你可以发出每个3个时钟周期的divss指令（互惠吞吐量）。请注意那些是SIMD的说明，这意味着您可以通过每3个时钟周期的相同划分方式将多达32个除法。上述所有情况下，问题基本上归结为：为什么一个部门的时钟周期大约需要3倍，作为乘法？ Jonathan Busby已经给出了决定性提示：划分不能用硬件并行化到与乘法相同的金额可以完成。澄清这一点：  
乘法是关联，交换和分配的同时 - 虽然句话既不是关联也不是换向。乘以两个数字的乘法，例如，你可以毫无升它：  
50,000 * 768 + 1,000 * 768 + 200 * 768 + 30 * 768 + 8 * 768.如果您的CPU有足够的ALU单位，它可以在一个时钟周期中完成所有乘法以及第二个时钟周期中的所有添加。如果添加和乘法是在两个不同的管道阶段完成的，并且给出足够数量的乘法，这意味着您可以平均完成一个乘法每个时钟周期（或使用AVX时的32）。因为缺失的划分截阵缺失， SRT算法需要每个步骤中的携带位的串行评估（再次检查jonathan busby的答案）。这意味着除了划分算法中的所有步骤都可以并行化（您可能希望读取Amdahls Lave以获取更多详细信息此），带有大约3倍的时钟周期，最有效的算法。  
### 回答 10
至少没有，至少在现在。这些天大多数计算机使用IEEE 754浮点算术，并以一致的方式实现。  
也就是说，有一些显着的变化：  
而且所有这些都没有包括具有不同天然硬件浮点类型的旧前IEEE-754大铁。  
如果您跳过随机计算机这些天，无论是由英特尔，AMD，ARM，飞思卡尔，微芯片，德州仪器还是其他人建造的，以及写一个涉及双和/或浮动的C程序，你不太可能看到任何计算差异。  
现代64位x86 abis在那里清理了浮点。 ARM，PowerPC，MIP和TI DSP也几乎融合在IEEE 754浮点上。  
关于您可能看到的唯一剩余差异是硬件是否实现了子万体，或者将子通量结果刷新为零。  
编辑：Robert Munafo在此处编目了许多预IEEE-754格式。我最喜欢的模糊格式之一是TI-99 / 4A上的基数-100浮点格式。是的，它在那里列出了，是的，我为该页面贡献了它的信息。  
### 回答 11
使用ALU进行任意长度添加或减法非常简单。这些天大多数CPU有32位或64位ALU（可以做出添加，减法，有时乘法或分区）  
常规算法如下：  
最终，您将最终结束完整添加的总和  
乘法和诽谤对于任意长度数字来说是更棘手的。  
