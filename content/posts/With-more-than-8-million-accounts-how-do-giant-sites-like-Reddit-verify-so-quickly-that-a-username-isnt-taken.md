---

title: 凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？
date: 2022-01-23T22:08:13+08:00

---




## 凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？  
### 回答 1
输入新用户名时，它会在列表中间检查它。这个名字是  
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。  
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，... Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。  
输入新用户名时，它会在列表中间检查它。那个名字就像是manwithamodem。它将用户名与此进行比较，并询问是相同的名称吗？如果是这样，拒绝。它可能是没有，所以那么它问这个新用户名在此用户名之前或之后按字母顺序排列吗？  
如果之前，它就会知道所有400万+在列表中的名称可能是一个匹配，所以它现在已经在单个比较中消除了400万+可能性。如果它追求，那么它就知道所有400万+在列表中的名字不能匹配。在任何一种情况下，我们只在一个比较之后排除了一半列表 - 以及我们排序清单！  
接下来，我们采取我们没有消除的列表的剩余一半，查看该列表中间的用户名，并将其与我们的新用户名进行比较。再一次，如果它不是一个完美的匹配（即发现它已经在使用），我们可以判断匹配（如果存在）是否坐在排序列表中的那一点之前或之后。正如我们之前所做的那样，我们再次消除了整个剩余可能性的一半。  
通过每次进行比较，通过将清单切成一半，我们可以快速浏览800万+用户名的列表。太快了？  
答案是您需要划分800万的次数，直到结果小于1？我们正试图将排序列表的段切成两半，直到事情足够小，以至于我们已经达到了两个彼此旁边的用户名，然后我们可以将新用户名与每个人进行比较，如果它匹配其中一个，那么用户名已经在使用中;如果没有，那么它是一个有效的新用户名。  
好吧，这个问题的答案是23次。  
就这样。由于我们将用户保存在一个排序的列表中，我们只需要做的23个比较，以验证新的提出的用户名是否存在。这很多，比800万比较快。  
如果您想了解更多，您可以在此处阅读其他答案，该答案解释了该排序列表如何称为索引，并且这种类型的搜索和比较过程（或类似于它的类似物质）通常会在其中的数据库中提供用户名存储，加上其他细节。  
### 回答 2
快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。  
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。  
重复这一点，直到它找到用户名或两个用户名...  
### 回答 3
任何现代平台都应该能够索引和缓存一个小varchar字段，以返回子秒内的简单存在评估。即使数亿用户也不会努力让这是努力的人只有800万。  
### 回答 4
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。  
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，... Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。  
......  
### 回答 5
为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。  
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。  
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。  
<ol>导入mm =打开（username_list.txt）s = mmap.mmap（f.fileno（），0，access = mmap.access_read）如果s.find（bwvdvajlo \ n）！= -1：print（true ）</ OL>  
<li>导入mmap </ li>  
<li> </ li>  
<li> f =打开（UserName_List.txt）</ li>  
<li> s = mmap.mmap（f.fileno（），0，access = mmap.access_read）</ li>  
<li>如果s.find（bwvdvajlo \ n）！= -1：</ li>  
<li>打印（true）</ li>  
运行这个程序  
为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。  
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。  
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。  
<ol>导入mm =打开（username_list.txt）s = mmap.mmap（f.fileno（），0，access = mmap.access_read）如果s.find（bwvdvajlo \ n）！= -1：print（true ）</ OL>  
<li>导入mmap </ li>  
<li> </ li>  
<li> f =打开（UserName_List.txt）</ li>  
<li> s = mmap.mmap（f.fileno（），0，access = mmap.access_read）</ li>  
<li>如果s.find（bwvdvajlo \ n）！= -1：</ li>  
<li>打印（true）</ li>  
运行此程序需要：  
<ol> bash-5.0 $ time python3 test.py true real 0m1.097s用户0m0.369s sys 0m0.109s </ ol>  
<li> bash-5.0 $ time python3 test.py </ li>  
<li>真实</ li>  
<li> </ li>  
<li> Real 0m1.097s </ li>  
<li>用户0m0.369s </ li>  
<li> sys 0m0.109s </ li>  
这是写完后第一次打开文件，所以内核没有正确缓存这个文件。  
随后的运行，或运行搜索较近开头的用户名，花费更少的时间，约0.4秒。  
所以这是底线。 800万用户名并不是那么多，可以使用现代硬件来搜索。  
适当的搜索或数据库引擎将降低该搜索时间，如果不是百倍，则最有可能使用这些搜索时间。  
更大的网站，如Facebook的含有它的1,5亿用户，是需要开始工程特殊解决方案的人，每个人都在评论，解决用户名存储和查找问题。  
但凭借800万用户，它真的不是问题。  
### 回答 6
用字典树  
字典树由节点组成。每个节点都是一封信。节点可以指示其他节点。从上面读取树下，给出了所用缺口的所有变体：  
所以这里我们有一个填充数据的树的示例。有一个词和单词新闻。还有其他人。  
因此，软件将树存储在内存中。当用户想要注册昵称时，服务器通过字母检查它字母。例如 ：  
您要注册新闻昵称。  
程序检查顶行是否包含n个字母。是的。  
n个字母的节点是否向E节点指示？是的。  
和节点E到节点w？  
是的。  
w表明s吗？  
y  
用字典树  
字典树由节点组成。每个节点都是一封信。节点可以指示其他节点。从上面读取树下，给出了所用缺口的所有变体：  
所以这里我们有一个填充数据的树的示例。有一个词和单词新闻。还有其他人。  
因此，软件将树存储在内存中。当用户想要注册昵称时，服务器通过字母检查它字母。例如 ：  
您要注册新闻昵称。  
程序检查顶行是否包含n个字母。是的。  
n个字母的节点是否向E节点指示？是的。  
和节点E到节点w？  
w表明s吗？  
在此图中，它不可见。但最后也是Word节点的结尾。  
下一个节点是一个结束节点吗？  
是的。  
行。所以这个昵称是保留的。  
使用8mLn用户检查昵称是否删除以检查N + 1次，如果存在指示灯。其中n是昵称长度。  
它需要一分的米氏乳头。并且不依赖于注册多少用户。  
覆盖并遵循原因它很有趣！  
### 回答 7
令人惊讶的是，到目前为止只有一个绽放过滤器。  
绽放过滤器实际上是完美的这个应用程序，让我们看看为什么。  
说k散列函数，使用绽放过滤器您有一个大的位数和许多散列函数。当您添加新用户名时，您可以哈希k次并打开这些k位。  
当您想要检查用户名是否占用了您的哈希次数，并且如果其中一个位为0，则用户名可用，因为否则该位将已打开。  
使用22MB过滤器，仅使用7个散列功能，您可以使用0.01个概率存储2000万物品  
令人惊讶的是，到目前为止只有一个绽放过滤器。  
绽放过滤器实际上是完美的这个应用程序，让我们看看为什么。  
说k散列函数，使用绽放过滤器您有一个大的位数和许多散列函数。当您添加新用户名时，您可以哈希k次并打开这些k位。  
当您想要检查用户名是否占用了您的哈希次数，并且如果其中一个位为0，则用户名可用，因为否则该位将已打开。  
使用22MB过滤器，仅使用7个散列功能，您可以存储2000万个项目，为误报的0.01个概率。当您说使用用户名时，会发生错误的阳性，但实际上并非如此，它只是通过一些其他字符串打开所有位。  
您可以使用在线绽放过滤器计算器来计算此功能：BloomFilter计算器  
关于这一点的最美好的是，如果你说一个用户名，那么它真的不是它没有那么多伤害，那么用户就可以选择另一个用户名。这使得一个绽放过滤器适用于这个应用程序，它们也非常好，过滤未安全的密码，只需将所有已知的坏密码添加到过滤器，概率低概率，您可以禁止安全密码，但用户可以挑选其他东西。  
绽放过滤器经常用作DB查询的缓存，如果过滤器说该项目不在DB中，则不需要查询，因为错误的否定是不可能的，如果该项目说该项目可能位于DB中，那么您询问。该想法是保存磁盘访问/查询，用于不在DB中的内容。  
请注意，检查是O（1）并在内存中完成，无需磁盘访问或数据库查询。  
这是从线性搜索中更好的更好，无需解决违规何时何时使用常规散列，您会自动说出用户名是否拍摄了ORNOT。没有存储单个字符串！  
### 回答 8
HERES是一个简单的，虽然天真的答案。我没有完全了解Reddit（或谷歌或Facebook）的第一手知识确保唯一性，但下面描述的一般校长可能非常接近真相。线性搜索是痛苦的  
让我们从最简单的方法开始：所有名称都存储在列表中，软件只需检查列表中的每个名称以确定用户名是否已经拍摄。这真的是可怕的：我们需要每一个名称单时间.TheThats对3600万用户Reddit实际上已经拥有，并且对于Facebook曲目的15亿用户完全站立。使用！计算机科学就在这里提供帮助！二进制搜索真的很聪明  
更好的方法是使用二进制搜索.Generally说明，您可以按字母顺序排列的用户名列表，然后划分和征服！例如，让我们说出您正在寻找泥炭...而不是从列表中的名字开始，你跳到列表中间（Reddits Case中的1800万纪录）.lets说那个地方的名字是迈克尔，所以我们问一个简单的问题：迈克尔之前或之后按字母顺序排列？因为米歇尔之后，泥炭出现，我们知道列表是字母顺序的，我们可以完全忽略前1800万唱片.Woo！如何加速？接下来，我们重复。剩下1800万条记录，所以我们将它们分成两半并跳跃900万坐在蒂娜上的位置......好吧，蒂娜来了泥炭之后，所以现在我们可以忽略最后900万唱片。他们已经丢弃了三个季度的整个列表.cool！重复：我们再次划分，跳跃回来，我们打彼得 - 现在我们有一个匹配的前两个角色（运气y美国！），但彼得在泥泞之后才能拆分列表并再次倒退！要倒退，如果我们再次重复这种方法，我们将结束是否存在是泥炭的记录。使用二进制搜索意味着我们必须在N个用户名的列表中进行的最大比较数是n的二进制对数。对于3600万用户，这是最糟糕的情况下的25个比较！不糟糕。现在，让我们看看一些更加努力的东西。15亿用户在二进制搜索中只看30个比较。没有那更难，嗯？......但是哈希呢？哈希是一个很酷的技巧，一群人在评论和其他响应中提到了它。基本说话，哈希表采用密钥（如用户名）和通过功能运行它来生成可以找到相应值的地址（或索引的索引）。在识别用户名是否是唯一的，我们将将用户名粘贴到散列函数中然后，请参阅是否存在于计算的地址处的用户记录。这具有令人敬畏的属性，因为它在恒定的时间内工作：计算地址需要相同的时间，无论数据集多大！在一个具有无限制的理想计算机中内存，这种简单的散列技术将是完美的。 S泥炭，外出来了，存储器地址A，并且计算机检查是否有任何东西。这种简单的方法在现实生活中没有解决。38 ^ 20可能的reddit用户名，所以即使我们正在解决个人BITS作为真/假标志，地球上没有足够的内存（也没有一些时间）来存储整个哈希表。所以，我们无法使用包含reddit用户名的整个地址空间的理想哈希表 - 但有很多聪明的方法可以制作一个哈希表紧凑，因此它只必须覆盖现有的用户名。折衷是，当数据集成长时，表必须重新磨损。在其他单词中，计算数据集时要找到值的位置的计算，这意味着数据必须移动（类似于上面的二进制搜索示例中的按字母顺序地保持列表）。这突出显示了工程师的最大问题之一必须在规模处理：不变的数据很容易处理随着和优化，但对于像Reddit和Facebook这样的网站，游戏的名称正在保持高性能，而在系统中被引入大量数据。为了有趣，我们可以使用两者吗？现在还有什么东西！  
### 回答 9
好消息！ Reddit通过Github公开在线提供其网站的整个源代码：RedDit / RedDit。  
另一个答案来自计算机科学的角度有趣，可以肯定地掌握自己的优点，但实际答案比较简单：它是一个数据库查询。  
流程是，当您注册时，它会在表单上执行验证。表单上的一个验证器称为vuname，它使数据库调用呼叫以查看用户名的小写版本是否存在记录。  
它真的很简单。数据库调用是符合SQL的数据库，我认为至少在基于代码注释的一个点处的Postgresql 9+。 PostgreSQL非常快，可靠，所以如果这是他们的选择，我不会感到惊讶。呼叫周围有一层缓存，以避免猛击DB，并且用户列肯定会索引足够好，它将使用B树，这是一个广义二进制搜索树（参见yishan Wongs回答超过8百万个帐户，如何快速验证像Reddit这样的巨型网站是否验证了一个易于拍摄的用户名？对于那种易于理解的解释它是如何工作的）。对于大多数SQL数据库查找，这些都是超级脱节，无论数据大小。  
800万个帐户记录对于数据库系统无法在分组中搜索。我在数据库表上建立并工作了数十亿记录，这些记录仍然可以从分秒的索引中收集数据。  
### 回答 10
想象一本带有一百亿的一本书，按顺序组织。这是你的索引。  
我请你找到Page 4,776,250,189。有几种方法可以做到。  
如果您尝试将本书随机打开到页面，则您可以获得1 / 10,000,000,000千分之一的机会。如果您需要一秒钟即可向每个页面打开并检查数字，可能会在第一个转移或第二个或十亿日。随着范围在一秒钟和十亿秒之间，随着均值的等等，那么平均查找时间将是50亿秒，或158.5岁。不是很有帮助。 （也是，这并不阻止重复查看页面，因为甚至要知道你已经看到的页面可能不会阻止你自己再次找到它。）  
你可以强迫它。一次一个，确保你不要错过它。在这种情况下，它需要你大约155年。这个字符串的改进，但如果有人告诉你发现九十亿九十亿并改变，你很容易超过300年。显然更准确和控制，但有时它将通过保证比随机民意调查慢。  
让我们做得更好。你随机打开一个页面，看看它的60亿并改变。您可以放入书签并忽略以外的每一页，因为您知道数字大于目标。然后，您随机选择书籍开始和书签之间的页面。如果它尚不少但是，您将书签返回，如果它更大，则在前盖后添加另一个。您持续缩小范围，它在30到40秒之间分解。  
我们可以通过这种方法做得更好。自制造以来，您可以使用标尺并测量页面堆栈的精确半部。它是2个功能的适当力量，因此您可以在保证最多34个步骤中找到任何数字。但我认为这可以做得更好。  
当您第一次浏览本书时，您将放入一些颜色编码的标记。蓝色表示十亿，标记标记在0到10之间，页面1,10亿，20亿，依此类推，高达100亿。在他们之间，每亿页，是一个黄色标记，标有0到9.与十百万，粉红色，橙色数百万人相同，达到十百万。解决方案十秒钟。  
现在重要的是要注意，这些都是所有算法函数，虽然没有精确的本质上（分离在一半中）到计算机处理查找的方式，但是通过索引快速孔隙快速孔隙的长期换档的示例。但是，虽然您可以每秒查找一个数字，但慢消费者处理器可以通过大约一个小时半的速度来通过10亿个字符串来走出蛮力计数方法。在一个核心上最长，最长，最长，大约两百万分之大约一千万;如果它没有开销，8核英特尔CPU可以可靠地解决每秒5000万次验证。  
将索引分为由不同机器或核心搜索的卷，就像书上的彩色标记一样，可以早期使用比50％的百分比更大，但对于非二元字符串的一些增加的处理能力，它在一秒钟内提到更多。  
它在现实生活中慢一点，因为我们在Base-10中思考时，计算机在基础-2（作为10状态计算机的高效）中运行，而我提到的字符串是简单的数字，只使用十个可能的字符，用户名通常具有10位数的选项，26个大写字母，26个小写字母和20个或如此特殊字符，为给定字符串长度提供7.2倍。  
也就是说，这一切都变成了在索引中排序的数字字符串，以升序顺序排序，算法可以重复分成一半，从而导致千分之一的秒。就像在书中查找页面一样。  
### 回答 11
尽管如此，正如我想要抵制非技术人的问题，或者对所有计算机科学的响应感到惊讶，因为所有的计算机科学仍然不熟悉关系数据库，其存在40多年以上的关系......什么样的大学教育科学家（或只是毕业）不知道SQL的性能限制？你住在岩石下吗？  
八百万人没有。如果字段索引，八个数册就没有了。八万亿......可能（并不总是）需要分布式（AKA分片）列存储NoSQL数据库，如Cassandra专门针对查询/读取进行了优化。  
我可以沉迷于旧学校的计算机科学，并解释数据库索引是如何通过B-，红色/黑色和其他树木实现的，但我忘记了大学课，我不在乎。没有人直接处理数据结构和算法，除非有一些采访的程序员。现代数据库保证了某些级别的性能。搜索就是即时的。  
### 回答 12
实际上reddit和其他人具有更复杂的挑战，如搜索整个数据库以获取匹配搜索输入的帖子。  
回复您的问题，用户名以减少查找匹配的复杂性的方式索引。典型的索引算法是二叉树或哈希表，并由无论数据库站点实现。可能是一个nosql。  
### 回答 13
依赖  
如果我正在设计类似的东西，则可能是具有用户名的主要索引的名称列表表，或者如果可能使用的次要唯一索引，如果DB引擎允许，则可以用作覆盖索引。 （覆盖索引是DB引擎可以使用的次要索引，以便在不需要从主表库获取数据的情况下完全应答给定查询，这使得索引访问更快。）  
或者如果此表特别热，则可能在某种类型的Redis样式内存缓存中，但下面的逻辑不会在任何一种情况下都不同。  
根据Biz逻辑，您可以尝试插入行并获得唯一或主键约束违规。许多应用程序开发人员不喜欢它作为SQL错误，并且可能很难用作代码中的合法应用程序错误，因为它可能会搞定异常处理。  
替代方法 - 大多数人可能会使用 - 是使用一个创建一个多语音事务  
开始交易;从user_tab中选择count（*），其中user_name = newname;  
关于这种方法的好处是计数（*）可以通过覆盖指数完全回答，而无需访问底层表。  
如果计数出现非零，则回滚XACT并要求用户选择另一个名称。如果它没有，您可以插入新用户数据和提交。  
### 回答 14
这是一个困难的听起来难以实现计算机的困难的东西之一。  
首先，计算机简直非常快。事实上，计算机可以简单地逐个通过800万用户名列表，并检查列表中所有名称的新名称。那将需要十分之一的一秒钟！谁在乎！  
但如果你更聪明地整理事情，它没有必要让电脑做得很多。可以使用的一个非常强大的技巧称为哈希。这个想法是定义一个函数，将任何字符串映射到一个和一百万之间的某个数字。数字应该看起来几乎是随机的，除了您计算相同字符串的数量时，可以获得相同的号码。然后下一步是制作列表列表。该清单长达1000万条参赛作品。第n个条目包含函数映射到n的所有用户名的列表。只有几个这样的琴弦！这是一个插图。  
因此，当用户输入新用户名时，将快速计算其哈希编号，并将对恰好具有相同号码的其他字符串进行检查。  
这样的解决方案实际上很快就是实际上瞬间。  
### 回答 15
快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。  
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。  
重复这一点，直到它找到了大于和少于提交的用户名的用户名或两个用户名。 8 MIL，4密耳，2密耳，1密耳，500K，250K，125K，CONT ...这可以在几秒钟或更短的时间内完成。  
请记住，有更多的技术来加速它，如：如果用户名以字母M开始，则该过程可以在索引的中间开始MS。这将小于8密耳的1/26次搜索。  
### 回答 16
Reddit的方式可能通过一种索引形式。  
大多数数据库存储在行中的数据 - 就像表的行（实际上，他们只是因为这个原因而被称为表格）。  
如果您所希望，则可以为每列分配索引。只要更改表中的行，数据库将保持索引保持最新状态。该指数是一个快速查找机制;给定值，它会告诉您哪个行包含该值。  
通常索引是基于名为B + -Tree的数据结构上构建的。细节不得不非常重要，但他们是一个优化的二叉树形式。并通过设计，由于数据结构本身，它们以排序方式存储数据。  
在二叉树内（从根到叶子到叶子），每个分支拆分为两个，左侧指的是索引中的数据的一半，右侧包含另一半的右侧。当您插入或删除它们时，这些树木尝试保持平衡，以便他们始终在每个分支中进一步朝向叶子中的大约一半的物品。  
因此，如果您有1,000,000项，则第一个分支将它们分成500,000个项目。接下来将其分成250,000件物品。接下来将其分成125,000个项目。然后是62,500件物品。然后31,250。然后15,625。然后7,812。然后〜3,906。然后1,953。然后是488.然后244.然后122.然后61.然后30.然后15 ...  
所以第16次检查，而不是1,000,000，以便到达15件事要查看。你可以进一步走;大多数b + -trees dont  - 叶子将包含一个项目列表。  
对于大多数这些，您甚至不需要检查整个字符串;只有许多字符，可以看到它是否小于，大于或等于它。  
甚至更好......仍然更快 - 您可以使用绽放过滤器。这是一个概率散列结构，它永远不会返回错误的否定。因此，如果拍摄的用户名是没有，您可以在大多数情况下执行单个检查并立即了解。它偶尔会有误报，这意味着在某些情况下，您仍然需要做一些工作要知道。  
### 回答 17
当它给出特定用户名不存在的答案时，置信水平  
实现此类特征的方法之一（成员身份检查）可以使用绽放过滤器，即，检查是否拍摄了特定的用户名。  
以下是对巨型网站可扩展和高效的设计。它使用概率数据结构有点类似于Hashtables，但它需要比HASHTables更少的存储。绽放过滤器的概率性质涉及以下两种情况的置信水平：  
当它给出了特定用户名不存在的答案时，置信水平为100％。但！！  
当它给出存在特定用户名存在的答案时，置信水平小于100％，这意味着用户名可能存在或可能不是（有可能不存在的可能性），因此概率性质。假阳性案例。  
实现 - 它使用比特数组作为一定长度的基本数据结构，例如如下所示  
我们占用了几次单词/用户名的哈希（例如，k次），并将那些哈希的位向量（所有k位）索引设置为1。  
现在要查找特定的用户名是否存在，它再次使用相同的哈希函数k次哈希，并检查是否设置了所有这些k索引，如果未设置所有这些k索引，则保证不存在用户名（ 100％），但如果设置了所有散列位向量，那么由于哈希碰撞（其他用户名或用户名的某些组合可能将这些位设置为1），那么它可能存在或不存在，因此有可能有机会假阳性。  
这里的挑战是选择可以降低误报概率的最佳散列函数。  
资料来源：绽放过滤器 - 维基百科  
### 回答 18
嗯，它是表面上的数据库查询。所以数据库会照顾它。  
如果您没有其他信息，则搜索有序列表是O（lg n）。在这种情况下，我们可以改进事物，因为我们不必跳跃中点。我们可以使用字母表字母切掉更大的块（例如，P是在中间，而且A靠近头部，X将更接近尾部）。数据库索引算法可以快速跳转到使用查找表接近答案（它可以跟踪多少A的，多少B's等）  
如果名单从800万到80亿到80亿，那么它不会更长1000次，但只有约1.5倍（可能少，但不再是更多）。  
### 回答 19
大多数数据库都有盛开过滤器的内部实现，以检查给定的用户名是否存在于用户名列表中。HBase，Cassandra和Postgres在其实现AFAIK中使用绽放过滤器。  
它是一个概率数据结构，它具有100％的概率识别如果用户名不存在，并且在识别username时，识别username约90％（不确定此数字）。  
而且该90％是因为哈希碰撞，适当使用散列函数或更多我们使用的散列函数的数量将这种概率增加到100％。  
希望这可以帮助。  
### 回答 20
明显的答案不是线性搜索。  
软件开发人员使用数据库存储数据的最常见原因之一是数据可以超出正常文件存储的限制。我是在有限范围内使用文件系统作为数据库的大粉丝。在我几年前写的开源汇编程序中，我将符号表函数映射到文件系统语义。这效果很好，因为我组装的程序没有比子目录更多的变量应该具有文件。数据库程序优化密钥搜索，其中包含更多键的键，应该以线性方式扫描。  
### 回答 21
eli5版本  
并非一切都保持在同一个地方。你知道在哪里看。如果您的用户名已经存在，那么它就会拍摄。  
当然，它并不简单，这两者都是看起来的组合以及如何在本地安排以节省空间。  
### 回答 22
我没有读过所有的答案。我这么懒惰。但是我正在上下跳起来，他们错过了这个重要的重要关键决议包括信封，只有在企业层面上做的事情在她的手指提示。我的忏悔......我不知道reddit是什么。我甚至没有Facebook account.nor twitter.i在谷歌博客虽然在谷歌博客上有一些博客。所以有一个很高的可能性 - 无论如何不会使用我的策略.OK，好的，所有这些人都在排序和搜索中有更好的专业知识.Me?i只是使用我认为的别人的图书馆是好的enuf.a二叉树，散箭树，哈希树，无论如何。他们错过了因为你忽略了问题 - 分布式的一个重要障碍 - 分布式。分布式。它e User Database.There是一个池，使用预克隆的数据库副本进行游泳。{database}不是一个好术语，但它是一个术语，但它是一个术语muggles会理解。它实际上是用户数据库的提取物。我将确保有一个提取物可用的一组克隆是您正在使用的网络方面的拓扑上最接近您使用的服务器区域。我创建的解决方案现在产卵另一个问题。我是否同步所有这些用户名提取克隆？同步也不好术语。由于实际同步意味着{以时间}同步，实际上是一个基本同时/并行处理意识形态。我们与同步的错误意义为{使所有克隆都具有相同的数据集实时}。但是软件工程已经学会了误用和滥用英语语言甚至被接受的术语。模式}和{data} .btw ... {实时}是一项符合一些愚蠢的SLA的战略规范，我将避免在这里解释。请说我是用户名extract的克隆。我分配给你和其他一些思考潜在的新用户申请人。您提交建议的新用户名，我会在自己内部搜索，并在我提供的名字，在我这里找到您提供的名称，您将立即拒绝。oth，如果您提出的用户名在我内部找不到，我会把它拍摄到一个中央提取物，以确保刚刚创建了新的用户名。但是，我刚才描述的策略是可怕的。即将到来，我作为一个用户名 - 提取克隆/无人机，我分配了一组散列子键。哈希键。我不知道要打电话它.I由于所有近的子散列，我只会有一个受限制的现有用户名和潜在用户名。 -Infinitely可能的用户名唯一地进入segments.as您的键，我们的浏览器JavaScript代码已经预测建议的用户名的子哈希键。它已经与哈希董事服务实例进行了通信。您将坐在您的终端疑惑，嗯，我最喜欢的最疯狂的用户名 - 你已经给我们准备拍摄到右侧用户名段克隆/无人机的时间很多。您在建议的用户名中键入，哈希导演服务实例与浏览器上的javacript代码合作，已经预测了新用户名的任何同时冲突。在你键入的时候已经做出了决定，谁将被驳回jacqui ???? 79323，谁将被反击的jacqui ???? 50033.然后，随着你的关键，所以一致的是，三个雅克的建议是同步的，如果您的提案存在，并且如果您的提议与他人同时存在，则幕后已经决定了。除了我的哈希算法外，我不应该解释一下哈希值。可以确保任何特定的字符序列，  
由于您的思考和键入提供了慷慨的延迟提供给我们，我可能不会关心哪些搜索/排序算法是最好的表现。我将简单地使用经过验证的非常快速的现成内存基于内存的数据库品牌。  
### 回答 23
典型的字典有超过100,000个字，但您可能只需几秒钟就可以查找任何字 - 因为单词按字母顺序排序。Reddit使用数据库索引，这基本上是相同的。  
### 回答 24
像Reddit这样的巨型网站如何验证用户名是否如此速度拍摄？  
具有适当的自由文本搜索引擎的数据库，例如，SQLite，没有问题这样做。您可以在PC上轻松执行此操作，更不用说巨型服务器。  
### 回答 25
许多好的答案已经在这里。  
我只想补充一下，为一个良好的关系数据库，半个世纪的技术，一张桌子，桌子被认为是小（ISH）。这足以介绍介绍索引（在一些其他答案中描述的方式中的一种方式加速搜索的结构，以便发动机未按顺序搜索），但远远足够大以担心实际指标类型或尝试要分区或应用大数据集使用的任何其他策略。数据库引擎最多可以在几毫秒内找到答案（最有可能更快，因为索引数据可能会在内存中缓存）;最大的延迟来源将是沟通的。  
即使没有专门的数据库引擎，每个计算机科学生都应该能够在几个小时内处理为目的服务的程序。  
对于真正大的数据集，或地理上分布的数据，或者当需要真正快速的响应时（例如，亚微秒），或者在数据不规则或异常的情况下，存在许多巧妙的方法。毕竟，它的整体目的是有效地处理数据。  
但是，验证了一个词或短语在那里的800万人中不是 - 绝对是一个孩子的戏剧。  
### 回答 26
好吧，事实上，问题非常简单。（通过在数据库中使用B-Tree索引可以通过B-Tree索引来易于解决）。  
有趣的方法是使用绽放过滤器。（例如，如果您想要在客户端检查用户名，那么大小的尺寸  
例如：包含8密耳的概率数据结构。可以在O（1）时间内检测到独特的物品，0.01误率大约需要10米。使用绽放过滤器的空间。[BloomFilter Calculator]。  
因此，您可以将整个Bloom过滤器存储在内存中的次数哈希，因此，允许您在非常便宜的空间上疯狂地检查。  
### 回答 27
免责声明：我不是专业开发人员，我的技术工作涉及大多数无聊的东西，如写文档，管理供应商和过剩的会议。  
尽管如此，当我在高中（90年代中期）时，我们被任务建立了各种项目，我选择了类似的问题来解决这个问题。我选择的解决方案涉及两个步骤：  
我们在古代（但在时间不半糟糕）IBM OS / 2 386DX机器上跑了它，这可能比这些天用的东西慢慢。即使在非常大的数据集上，它也很快。 800万个帐户对该算法本身不是一个问题，虽然如此大的数据集（适用于那个时间）将增加一些内存管理挑战。即便如此，通过将每棵树分成N / 128文件块（或仅选择更大的Mod编号），可以通过时间技术轻松解决。  
我想象现在，除了货币的硬件资源之外，还更聪明地解决这些问题。这不是任何令人惊讶或敬畏的令人惊叹，这是计算机设计的。  
### 回答 28
他们将使用索引。当数据被索引时，在1,000,000中查找1只需要两倍，只要查找1000即可超过1次，而不是在10中找到的3倍。  
要了解为什么，想象在10个名称的按字母顺序列表中寻找名称。这需要几秒钟左右。但是，这篇论文有100个列中有100个名称。首先，找到右图，这需要几秒钟，然后您找到了正确的名称，它需要几秒钟，与之前相同。如果移动到1000个名称，则在10页中组织为100个名称，它需要几秒钟才能找到合适的页面，然后需要另一个夫妇找到正确的名称。每次乘以10时，它只会添加几秒钟。它不会将搜索时间乘以10。  
### 回答 29
你知道吗？你可能自己制作其中一个。或者跳过代码部分。  
这是基本的Python代码：  
<ol> username = [aa，bb，wksb，aiens，qjdvsi，ahdksve，jetsbsoeb，jwgsksvsu，鲍勃，ben，byer，sean] #so heres一个用户名列表，如果你想从划痕开始，你可以拍空方括号INP = str（输入（输入用户名：））x = 0在用户名中：如果i == n：x + = 1 else：pass如果x == 0：username.append（n）else：print（用户名已存在）</ ol>  
<li>用户名= [AA，BB，WKSB，AIENS，QJDVSI，AHDKSVE，JETSBSOB，JWGSKSVSU，BOB，BEN，BENER，SEAN] </ LI>  
<li> #so heres一个用户名列表，如果你想从划痕开始，你只能把空的方括号</ li>  
<li> inp = str（输入（输入您的用户名:)）</ li>  
<li> x = 0 </ li>  
<li>在用户名中：</ li>  
<li>如果i == n：</ li>  
<li> x + = 1 </ li>  
<li>通过</ li>  
<li>如果x == 0：</ li>  
<li> username.append（n）</ li>  
<li> else：</ li>  
<li>打印（用户名已存在）</ li>  
这是线性搜索的基本代码！但是，当在大站点时，列表超过数百万时，他们使用的是  
你知道吗？你可能自己制作其中一个。或者跳过代码部分。  
这是基本的Python代码：  
<ol> username = [aa，bb，wksb，aiens，qjdvsi，ahdksve，jetsbsoeb，jwgsksvsu，鲍勃，ben，byer，sean] #so heres一个用户名列表，如果你想从划痕开始，你可以拍空方括号INP = str（输入（输入用户名：））x = 0在用户名中：如果i == n：x + = 1 else：pass如果x == 0：username.append（n）else：print（用户名已存在）</ ol>  
<li>用户名= [AA，BB，WKSB，AIENS，QJDVSI，AHDKSVE，JETSBSOB，JWGSKSVSU，BOB，BEN，BENER，SEAN] </ LI>  
<li> #so heres一个用户名列表，如果你想从划痕开始，你只能把空的方括号</ li>  
<li> inp = str（输入（输入您的用户名:)）</ li>  
<li> x = 0 </ li>  
<li>在用户名中：</ li>  
<li>如果i == n：</ li>  
<li> x + = 1 </ li>  
<li>通过</ li>  
<li>如果x == 0：</ li>  
<li> username.append（n）</ li>  
<li> else：</ li>  
<li>打印（用户名已存在）</ li>  
这是线性搜索的基本代码！但是，在大站点的情况下列表超过数百万时，他们使用的是被称为二进制搜索。  
在这种情况下，他们的列表已按字母顺序排序。接下来，他们找到了TGE列表的中期期限。它检查它是否等于Enetered的用户名，如果不是，那么是否在术语之前或之后是按字母顺序出现的？  
因此，它们将其列表除以一半，并按字母地映射元素。如果不存在用户名，则它们将其添加到列表中。  
我希望你明白。  
### 回答 30
用户名将在数据库中索引，该数据库将在索引（例如B树）上使用某种类似的树状数据结构。  
平衡树将有O（LOGN）查找时间，因此100万条记录的略低于20次，或者800万用户的24次命中，然后每次倍增一次。  
看看这样的东西可以为什么是这种情况来获得直觉：  
https://www.cs.helsinki.fi/u/mluukkai/tirak2010/b-tree.pdf.  
请注意树的高度，它应该帮助您入口。  
如果你正在努力获得直觉的话，你可以通过检查垃圾箱来开始  
用户名将在数据库中索引，该数据库将在索引（例如B树）上使用某种类似的树状数据结构。  
平衡树将有O（LOGN）查找时间，因此100万条记录的略低于20次，或者800万用户的24次命中，然后每次倍增一次。  
看看这样的东西可以为什么是这种情况来获得直觉：  
https://www.cs.helsinki.fi/u/mluukkai/tirak2010/b-tree.pdf.  
请注意树的高度，它应该帮助您入口。  
如果您正在努力获取直觉，可以通过检查二进制搜索如何使用例如8米数字来开始，并查看具有更高/较低的响应的猜测，您需要能够在正确的答案上收敛（提示 - 它在最糟糕的情况下24次猜测，或者O（logn））  
二进制搜索 -  Geeksforgeeks  
### 回答 31
绽放过滤器将使用相对适度的存储量来完成此操作，并且可以容易地并行化。  
### 回答 32
我不知道他们究竟是多么做。但是绽放过滤器可以检查字符串是否是字符串数组的一部分。当阵列大小在数百万内时，这可能是最快的技术。  
阅读：按示例的绽放过滤器  
### 回答 33
你能解释为什么你认为Reddit必须通过800万其他用户查询吗？当您在字典中查找单词时，您是否在查找确切的单词之前查看字典中的所有40万字？  
### 回答 34
我会添加到其他答案的东西是计算机真的很快。如果您在现代计算机的内存中存储800万个名称，则可能有可能在大约2秒内通过它们进行搜索。这被称为蛮力解决方案，实际上没有使用（见其他答案），因为其他方法要快得多，但它很令人着迷。  
### 回答 35
您建议的搜索是对数自然的。我猜搜索使用字符串的哈希版本。如果它是64位哈希，它可以在三个动作的64个操作中找到散列和用户名的三个操作。  
假设缓存数据库中没有数据库的64个操作是13微秒。计算哈希本身就花了很多时间。  
基本上，您可以假设搜索一个用户名的数据库和用户名的三级数据库将同时进行。  
### 回答 36
我不记得是他们特别谈论这个特别但史蒂夫·霍夫曼（我认为他的名字），Reddit的创始人有一个关于Udacity的Web开发课程。他谈到了很多关于Reddit如何构建的。如果你真的很感兴趣，请检查出来。我相信它的CS253。  
基于我记得的东西。我猜他们也使用索引。  
### 回答 37
这不是那么难。这取决于您有多少用户。如果您了解NoSQL，则可以在内存或键值DB中执行此操作。维护内存中的索引不是那么昂贵的。假设用户名的最大长度限制为20字节（20字节* 10百万），即使您有数百万用户也没有真正那么疯狂的事情。  
你也可以做块。按字母块维护用户名只是一种简单的方式。  
### 回答 38
引用散列和数据库实现的答案是正确的。我只是想加入一个进一步的洞察力。在这样的尺度上，一个经常需要简单的点解决方案。因此，概念上您可以考虑将用户信息存储在数据库中。现在您需要检查唯一性，因为新用户出现，所以您对用户数据库进行查询呢？或许。我肯定不知道，但如果Reddit（和其他大型站点）对唯一性检查有特殊的实现设置，我不会感到惊讶。您可以使用更适合此类查询的用户数据库中使用不同的数据库。它可能只是存储用户名，以便在查询时，唯一回来的是用户名，而不是用户数据。您可以做的另一件事是基于所请求用户名的第一个字符将用户名搜索空间拆分为许多单独的索引（较小的搜索空间）。这只是一个例子。  
所以这一点就是这样。在比例下，您经常必须设计点解决问题。  
### 回答 39
一台计算机可以检查非常快。  
只是为了说明：  
我决定看到赚取1000万个数字比较需要多长时间。我用过Python，这不是一个已知的用于执行速度的语言。检查每个数字0到10,000,000，看看它们是否匹配1,000,000，花了0.39秒。  
<ol >>>> def test_speed（）：start = time.time（）在范围内（0,10000000）：如果i == 1000000：通过打印（time.time（） - 开始）>>> test_speed（）0.3913123607635498 </ OL>  
<li >>>> def test_speed（）：</ li>  
<li> start = time.time（）</ li>  
<li> i在范围内（0,10000000）：</ li>  
<li>如果i == 1000000：</ li>  
<li>通过</ li>  
<li>打印（time.time（） - 开始）</ li>  
<li> </ li>  
<li >>>> test_speed（）</ li>  
<li> 0.3913123607635498 </ li>  
### 回答 40
通过表的索引  
我假设Reddit仍然使用传统的关系数据库（我称之为表格数据库）。  
一个正确索引的数据库表（基本上创建每个索引列的关联阵列）非常迅速搜索。800万行并不是那么多的角度。  
处理系统中的消息和评论应该是一个相当大的问题，这比用户更丰富。当显示消息时，还需要删除与该消息相关的注释，并且都需要与右用户联系。  
通过索引表内容和表行引用的数值索引（不要将这两者混淆）它很快也很快到了交叉参考表。例如。根据存储在消息表中的用户帐户ID，查找用户已写入的消息。  
### 回答 41
为什么用户名必须是独一无二的？因为那时他们可以被认为是'钥匙'？这意味着您可以在恒定时间内查找与“键”相关联的“值”（即用户记录）。有很多方法可以实现这一点，但只需将那些Nitty GriTy细节留给您的数据库。  
### 回答 42
要加入yishan Wong的答案，这是一个视频解释了完全相同的过程（如果他非常深入地解释你们中的任何一个）：  
### 回答 43
我不知道用户名，但是当用户放置一个链接时，它们有一个IP的限制必须等待10分钟。  
### 回答 44
如果，数据存储在平衡二叉树中，假设800万条条目，则需要23-24比较，以确定是否存在条目。  
您必须对自己构成“平衡二进制”树来做自己的研究。  
现在，如果每秒有数百或数千个搜索请求，如果是我，我不会使用这样的方法，而是我会看一个散列方案。  
### 回答 45
在寻找一个特定值的一个特定字段上查询数据库是一件非常简单的事情。  
如果我想使用BOB的用户名。我们只是询问数据库，嘿，用户的表是否在用户名列中有条目“bob”？  
想象一下，让他们全部在电话里书写的目录中。你只是寻找鲍勃，如果它已经在书中，你拒绝它。这对我来说很容易。  
### 回答 46
只需在其数据库中使用usename字段即可。单击“连接”时，填写表单并按“输入网站操作脚本的”背景语言“操作脚本然后查询用户数据库，请检查数据库中的所有名称的名称，并有条件地返回此名称已在使用中或此名称是已经拿了。没有什么比这更快。  
### 回答 47
用户帐户存储在数据库表中。您将索引放在表中的相应列中，执行搜索，并搜索800万行不需要很长时间。没什么大不了的。  
### 回答 48
是的，我迟到了，但让我简短：  
请阅读和理解：Knuth，计算机编程艺术  
### 回答 49
即使对于愚蠢的算法搜索，800万个账户甚至也是游戏。但这是不同数据的许多算法。  
最重要的因素之一是数据（用户名）如何保存在内存中。最简单的方法是按字母顺序排序所有用户名。使用新用户名进行中间用户名并比较。如果此用户名相等。如果没有，是新的用户名，如果按字母顺序排序将是中间用户名或之后？因此，只需一个尝试，您将丢弃4百万用户名，并留下4百万用户名。您再次占据400万的中间用户名并再次检查。如果新的用户名与中间用户名不同，则再次丢弃一半的用户名，并留下2百万用户名。并且在找到现有用户名之前重复它（所以您不允许使用此用户名），或者您丢弃数据库中的所有用户名，并找不到现有用户名（因此您接受它）。  
以下是改进该算法的许多方法。因此，实际应用程序将使用更好的东西，但即使是现在您不需要比较800万用户名。  
### 回答 50
实际上，无论如何，经历几百万名字不应该花费。你不知道电脑是多么快。  
虽然他们可能确实有一些像散发一样聪明的东西来减少计算负荷。  
### 回答 51
对数据库的简单查询选择用户名。如果返回的记录（并且它发生得非常快 - 通常较少索引字段上），则使用该名称，当前用户不能使用。  
### 回答 52
800万相当容易。要问的真正问题是它如何从眨眼间从储存的储存中获取数据。  
### 回答 53
谁说你需要一个接一个地查找800万账户？任何能够关联键（用户名）值（数据和加密密码）的NoSQL Server并返回O（1）的结果。在简单的术语中，它只是关键值映射。  
### 回答 54
只要我想到使用Reddit以外的任何目的，我就会感到焦虑，除了寻找色情或模因以外的任何目的。经过多年的经验，我基本上假设，无论我写什么，除非它是最普遍和无聊的废话，否则表达了大多数人的意见，我可能会遇到不合理的敌意，无论我说什么都将被贬低遗忘。  
对于所有这些原因，每当我尝试使用除色情和模因以外的任何东西时，我都会感到不舒服。它设计不佳，它的UserBase似乎有问题。如果不是这样的事实，它是如此大，并且几乎任何方便的潜水员都可能不会用它。  
### 回答 55
没有尊敬塞巴斯蒂安D.安德森，但这个答案似乎有点关键。 Reddit（产品）在十年+生活中经历了大规模的动荡，并且我们从未意味着更改的答案不会从Tech角度响起。  
当用户删除其帐户或已删除时，所做的帖子或注释是由*括号*删除*括号*符号的标准。  
因此，如果底层系统可以在那种情况下为另一个文本分配，为什么不构建？保留更改文本的代码，并丢失86个帐户的部分。  
我的私人怀疑是，红线文化的影响力梯度想要这种方式。他们希望能够跟踪来自青少年的用户，他们是他们将会的律师或惠劳特。他们想要一个永久性的系统，身份意味着什么。当然，你可以获得一个新帐户 - 但你丢失了所有的朋友和贡献，以及像你这样的Redditor的原因。  
最糟糕的是，这是一个蚂蚁农场。最多，这是一个在互联网上的社会实验，而不是社区中的每个人都匿名。  
到目前为止，它似乎很好地闷闷不乐。戏剧一边。戏剧是机器如何发布压力。这就是它的发展。每只珍珠都需要刺激物。  
### 回答 56
业力是reddit使用的点系统。它根据Upvotes（上箭头）的数量和下移（向下箭头）您的帖子接收。  
有2种Karmas。链接Karma和Content Karma。 Link Karma获得链接提交的链接提交，而内容Karma则获得在帖子中发布的评论。  
1.加入受欢迎的资金  
您需要更多与您发布以快速改善您的业力点的互动。找到很多人闲逛的大菲德德。请记住将贴片的理想时间发布。  
2.回复热选项卡上的线程  
在您的帐户中，您将看到一个热选项卡。这  
业力是reddit使用的点系统。它根据Upvotes（上箭头）的数量和下移（向下箭头）您的帖子接收。  
有2种Karmas。链接Karma和Content Karma。 Link Karma获得链接提交的链接提交，而内容Karma则获得在帖子中发布的评论。  
1.加入受欢迎的资金  
您需要更多与您发布以快速改善您的业力点的互动。找到很多人闲逛的大菲德德。请记住将贴片的理想时间发布。  
2.回复热选项卡上的线程  
在您的帐户中，您将看到一个热选项卡。此选项卡显示您订阅的子文件中最流行的线程。因为许多人正在参与这些线程，所以您的评论很可能会获得更多的可见性和更多的投票。  
下面，一个社会管理工具，为您创建多个发布任务以获得您的业力。您也可以用它升空和拆卸。  
### 回答 57
我认为它完全取决于账户的目的。  
我见过的redditor实际上没有坐在那里，有一个用户名的几个小时。非常肯定，他们模糊地引用了他们的一个兴趣。  
我知道许多Redditors根据他们想要分享的内容创造了一次性账户。例如，当人们继续r / aita（我是混蛋？）并披露个人细节。  
但是，如果你想提出一个很好的用户名，你可以随时尝试以前推荐的用户名生成器:)  
### 回答 58
一些关于一些政治资深人士的一个速度，我永远不会忘记的一些政治资金：  
U / cucksylvania  
巨魔的完美用户名。加上双关语很有趣。  
### 回答 59
二进制搜索基本上消除了只需一个支票中的一半可能性。您需要做的就是将所有用户名存储在有序列表中。  
如果有100万个名称，我们只需检查大约20次。  
如果有200万个名称，我们只需检查约21次。  
如果有10亿个名称，我们只需要检查大约30次。  
### 回答 60
人们记得他们。 :)大多数Reddit用户名往往很难记住，也许是因为Reddit不允许签名或头像。所以一个易嘲讽的亵渎的用户名是人们会记住的唯一一个。它甚至可能变成了自己的模因。  
此外，它有时难以抵制点击这些用户名的历史，并看到人们如何对这些帖子作出反应。  
I_RAPE_CATS只是因为这个原因而闻名。我和雷德德的一些人谈过，其中一些人说他们不能记得除了i_rape_cats以外的单个用户名。顺便说一下，他利用他的名望将一个YouTube视频推进成名（他在Reddits文章下列出了百科全书DRAMATICA）。  
此外，它只是有趣的是想象出在他们的一些帖子中附加这些用户名的心理形象。  
### 回答 61
简单。像用户一样快速验证的用户名存储在多累的NoSQL数据库中。用户名驻留最有可能的内容，在非常快的辅助存储器中的其他信息，例如闪存驱动器在与巨大的高速缓存的SAN中。  
根据您提到的，Facebook主要使用Hive和Cassandra，其中绩效计数和休息的MySQL。  
谷歌使用Bigtable。  
这与前端侧使用JavaScript无关，就像其他未经教育的答案一样。  
### 回答 62
Reddit已经为您提供了大量的匿名，所以我不明白为什么要隐藏您的用户名。至于IM意识到，它不可能。如果您觉得您发表评论或发布，您不应该，只需删除它。  
P.S.咨询词 - 不要选择可以链接回到您的用户名。选择一些真正愚蠢/通用的东西。  
