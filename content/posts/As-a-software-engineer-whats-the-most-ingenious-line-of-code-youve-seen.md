---

title: 作为一个软件工程师，你看到的最巧妙的代码线是什么？
date: 2022-01-23T22:08:07+08:00

---




## 作为一个软件工程师，你看到的最巧妙的代码线是什么？  
### 回答 1
A2A by Josh Knight [https://www.quora.com/profile/josh-knight-19]。我正在回答这个问题作为软件工程师，开发人员和/或程序员;您在Codebase中见过的最野蛮评论是什么？  
您的问题导致我记得收购由公司源代码中的单一评论保存的软件公司。不是你想到的，而是一个有趣的战争故事。  
1986年末，我对r ...的电子表格计划的源代码进行了困扰  
### 回答 2
到目前为止，这是第10行：  
<ol> float q_rsqrt（浮点数）{long i; float x2，y; const float threehalfs = 1.5f; x2 =数字* 0.5f; y =数字; i = *（long *）＆y; //邪恶的浮点位级别黑客i = 0x5f3759df  - （i >> 1）; //他妈的是什么？ y = *（float *）＆i; Y = Y *（三个 - （x2 * y * y））; //第1次迭代// y = y *（threehalfs  - （x2 * y * y））; //第二迭代，可以删除返回y; } </ OL>  
<li> float q_rsqrt（float numby）</ li>  
<li> {</ li>  
<li> long i; </ Li>  
<li> float x2，y; </ Li>  
<li> const float threehalfs = 1.5f; </ Li>  
<li> </ li>  
<li> x2 =数字* 0.5f; </ Li>  
<li> y =数字; </ Li>  
<li> i = *（long *）＆y; //邪恶的浮点位水平黑客攻击</ li>  
<li> i = 0x5f3759df  - （i >> 1）; //他妈的是什么？ </ Li>  
<li> y = *（float *）＆i; </ Li>  
<li> y = y *（threehalfs  - （x2 * y * y））; //第1次迭代</ li>  
<li> // y = y *（threehalfs  - （x2 * y * y））; // 2nd迭代，可以删除</ li>  
<li> </ li>  
<li>返回y; </ Li>  
<li>} </ li>  
它来自Quake 3源代码，原始评论。目标是计算逆平面根1/√x。重点是，这  
到目前为止，这是第10行：  
<ol> float q_rsqrt（浮点数）{long i; float x2，y; const float threehalfs = 1.5f; x2 =数字* 0.5f; y =数字; i = *（long *）＆y; //邪恶的浮点位级别黑客i = 0x5f3759df  - （i >> 1）; //他妈的是什么？ y = *（float *）＆i; Y = Y *（三个 - （x2 * y * y））; //第1次迭代// y = y *（threehalfs  - （x2 * y * y））; //第二迭代，可以删除返回y; } </ OL>  
<li> float q_rsqrt（float numby）</ li>  
<li> {</ li>  
<li> long i; </ Li>  
<li> float x2，y; </ Li>  
<li> const float threehalfs = 1.5f; </ Li>  
<li> </ li>  
<li> x2 =数字* 0.5f; </ Li>  
<li> y =数字; </ Li>  
<li> i = *（long *）＆y; //邪恶的浮点位水平黑客攻击</ li>  
<li> i = 0x5f3759df  - （i >> 1）; //他妈的是什么？ </ Li>  
<li> y = *（float *）＆i; </ Li>  
<li> y = y *（threehalfs  - （x2 * y * y））; //第1次迭代</ li>  
<li> // y = y *（threehalfs  - （x2 * y * y））; // 2nd迭代，可以删除</ li>  
<li> </ li>  
<li>返回y; </ Li>  
<li>} </ li>  
它来自Quake 3源代码，原始评论。目标是计算逆平面根1/√x。重点是，这种黑掩囊比当时的任何其他替代方案相比至少表现为4倍。  
此处更多信息：快速逆平面根 - 维基百科。  
### 回答 3
一条线太短暂，不能以同样的方式让我惊讶地说，看谷歌翻译了一个惊人的我。  
但我最喜欢的线路是一个简单的低通数字滤镜：  
<OL>实际=（15 *实际+目标）/ 16; </ OL>  
<li>实际=（15 *实际+目标）/ 16; </ Li>  
它充当一个简单的集成商，将实际朝向目标移动。  
我已经用它在工业系统中的PID控制器，以及计算机游戏中的“Steadicam” - 在轨道上进行相机运动的平滑。  
谢谢那些博士的传说来自西门子的鲍勃拿出来。我很高兴在我的职业生涯中偷了它。  
您可以使用此操作：  
<OL>浮法实际= 0.0f;浮动目标= 100.0f; for（int s </ OL>  
<li>浮法实际= 0.0f; </ Li>  
<Li>浮动目标= 100.0f; </ Li>  
<li> </ li>  
<li> for（int s </ li>  
一条线太短暂，不能以同样的方式让我惊讶地说，看谷歌翻译了一个惊人的我。  
但我最喜欢的线路是一个简单的低通数字滤镜：  
<OL>实际=（15 *实际+目标）/ 16; </ OL>  
<li>实际=（15 *实际+目标）/ 16; </ Li>  
它充当一个简单的集成商，将实际朝向目标移动。  
我已经用它在工业系统中的PID控制器，以及计算机游戏中的“Steadicam” - 在轨道上进行相机运动的平滑。  
谢谢那些博士的传说来自西门子的鲍勃拿出来。我很高兴在我的职业生涯中偷了它。  
您可以使用此操作：  
<OL>浮法实际= 0.0f;浮动目标= 100.0f; for（int步骤= 0;步骤<500;步骤++）{实际=（15 *实际+目标）/ 16; system.out.println（实际）; } </ OL>  
<li>浮法实际= 0.0f; </ Li>  
<Li>浮动目标= 100.0f; </ Li>  
<li> </ li>  
<li> for（int step = 0;步骤<500; step ++）{</ li>  
<li>实际=（15 *实际+目标）/ 16; </ Li>  
<li> system.out.println（实际）; </ Li>  
<li>} </ li>  
### 回答 4
几十年前，我试图在网络公司获得工作。这是堆栈溢出或书籍等网站之前的潮流，如破解编码面试，但仍有科技面试，所以我是我自己的。对于预备，我审查了一些大学教科书，包括Tannenbaum的操作系统，其封面插图包括一行代码：  
而（* m ++ = * p ++）;  
当运气有它时，我的技术面试问题之一是在C的情况下在不使用任何库中实现一个字符串复制函数。我确认我可以指望源字符串终止终止，因此我继续写入该行代码。我清楚地回忆起面试官不相信答案，并检查它是否真正有效。当然，我不得不承认这个问题太容易了，因为我已经知道了答案，但我认为这是一个非常好的第一印象。那是好的，因为我没有对其他问题做得很好。无论如何，我得到了这份工作，我将永远深情地记住那条代码，因为它打开了门，让我在这样一个令人敬畏的公司工作。  
### 回答 5
我会回应最巧妙的代码线。  
想象一下，您给出了表示二进制值（0或1）的整数，并且您希望在给出的整数与整数相反的位置处访问阵列。  
在Java中，这就是这样的样子：  
<ol>公共字符串getValue（int pos）{if（pos == 0）返回arr [1];否则返回arr [0]; } </ OL>  
<li>公共字符串getValue（int pos）{</ li>  
<li> if（pos == 0）返回arr [1]; </ Li>  
<li> else return arr [0]; </ Li>  
<li>} </ li>  
回想起来，以下代码不是那种介意，我现在已经多次看了。但我第一次看到这个时，我想，哦，你聪明的小恶魔你！  
<ol>公共字符串getValue（int pos）{return arr [1-pos]; } </ OL>  
<li>公共字符串getValue（int pos）{</ li>  
<li>返回arr [1-pos]; </ Li>  
<li>} </ li>  
当然这是一个简单的例子  
我会回应最巧妙的代码线。  
想象一下，您给出了表示二进制值（0或1）的整数，并且您希望在给出的整数与整数相反的位置处访问阵列。  
在Java中，这就是这样的样子：  
<ol>公共字符串getValue（int pos）{if（pos == 0）返回arr [1];否则返回arr [0]; } </ OL>  
<li>公共字符串getValue（int pos）{</ li>  
<li> if（pos == 0）返回arr [1]; </ Li>  
<li> else return arr [0]; </ Li>  
<li>} </ li>  
回想起来，以下代码不是那种介意，我现在已经多次看了。但我第一次看到这个时，我想，哦，你聪明的小恶魔你！  
<ol>公共字符串getValue（int pos）{return arr [1-pos]; } </ OL>  
<li>公共字符串getValue（int pos）{</ li>  
<li>返回arr [1-pos]; </ Li>  
<li>} </ li>  
当然这是一个简单的例子，如果POS不是0或1，则会有问题，但通过从1中减去整数表示由整数表示的二进制值的想法是一个可爱的小技巧。  
### 回答 6
一段代码我曾写过以在固定宽度字段中打印可变长度值  
<ol> int len = print_val（expr）;printf（+ len）;</ OL>  
<li> int len = print_val（expr）;</ Li>  
<li> printf（+ len）;</ Li>  
函数print_val（）返回打印其参数时发出的字符数。此值用于索引到空格数组中，并且在值之后打印正确的空格数，使结果是固定宽度字段中的左对齐值。要正常工作，必须保证Print_Val（）返回的最大数量不大于数组中的空格数。  
### 回答 7
Duff的设备非常漂亮：  
它使用一个循环交错与交换机语句有效，因为C如何编译（并来自装配风格跳转），并且Duff使用它在Lucasfilm上加速动画[更多此处达夫（Wikipedia） -  Wikipedia]  
<OL>发送（从，计数）注册短*，* from;注册数; {寄存器n =（count + 7）/ 8;切换（计数％8）{case 0：do {* to = * from ++;案例7：*来自++的= *;案例6：*来自++的= *;案例5：*到= *来自++;案例4：*到= *来自++;案例3：*至= *来自++;案例2：*来自++的= *;案例</ ol>  
<li>发送（来自，计数）</ li>  
<li>注册短*，* from; </ Li>  
<li>寄存器计数; </ Li>  
<li> {</ li>  
<li>寄存器n =（count + 7）/ 8; </ Li>  
<li>开关（计数％8）{</ li>  
<li>案例0：do {* to = * from ++; </ Li>  
<li>案例7：*到= + ++; </ Li>  
<li>案例6：*到= *来自++; </ Li>  
<li>案例5：*到= *来自++; </ Li>  
<li>案例4：*到= *来自++; </ Li>  
<li>案例3：*到= *来自++; </ Li>  
<li>案例2：*到= *来自++; </ Li>  
<li>案例</ li>  
Duff的设备非常漂亮：  
它使用一个循环交错与交换机语句有效，因为C如何编译（并来自装配风格跳转），并且Duff使用它在Lucasfilm上加速动画[更多此处达夫（Wikipedia） -  Wikipedia]  
<OL>发送（从，计数）注册短*，* from;注册数; {寄存器n =（count + 7）/ 8;切换（计数％8）{case 0：do {* to = * from ++;案例7：*来自++的= *;案例6：*来自++的= *;案例5：*到= *来自++;案例4：*到= *来自++;案例3：*至= *来自++;案例2：*来自++的= *;案例1：*到= *来自++; } while（ -   -   -  0）; }} </ OL>  
<li>发送（来自，计数）</ li>  
<li>注册短*，* from; </ Li>  
<li>寄存器计数; </ Li>  
<li> {</ li>  
<li>寄存器n =（count + 7）/ 8; </ Li>  
<li>开关（计数％8）{</ li>  
<li>案例0：do {* to = * from ++; </ Li>  
<li>案例7：*到= + ++; </ Li>  
<li>案例6：*到= *来自++; </ Li>  
<li>案例5：*到= *来自++; </ Li>  
<li>案例4：*到= *来自++; </ Li>  
<li>案例3：*到= *来自++; </ Li>  
<li>案例2：*到= *来自++; </ Li>  
<li>案例1：*到= *来自++; </ Li>  
<li>} while（ -   -   -  0）; </ Li>  
<li>} </ li>  
### 回答 8
快速的逆平面根 - 用于早期3D游戏，如厄运和地震，用于计算表面法线。  
<ol> float q_rsqrt（浮点数）{long i; float x2，y; const float threehalfs = 1.5f; x2 =数字* 0.5f; y =数字; i = *（long *）＆y; //邪恶的浮点位级别黑客i = 0x5f3759df  - （i >> 1）; //他妈的是什么？ y = *（float *）＆i; Y = Y *（三个 - （x2 * y * y））; //第1次迭代// y = y *（threehalfs  - （x2 * y * y））; //第二迭代，可以删除返回y; } </ OL>  
<li> float q_rsqrt（float numby）</ li>  
<li> {</ li>  
<li> long i; </ Li>  
<li> float x2，y; </ Li>  
<li> const float threehalfs = 1.5f; </ Li>  
<li> </ li>  
<li> x2 =数字* 0.5f; </ Li>  
<li> y =数字; </ Li>  
<li> i = *（long *）＆y; //邪恶的浮点位水平黑客攻击</ li>  
<li> i = 0x5f3759df  - （i >> 1）; //他妈的是什么？ </ Li>  
<li> y = *（float *）＆i; </ Li>  
<li> y = y *（threehalfs  - （x2 * y * y））; //第1次迭代</ li>  
<li> // y = y *（threehalfs  - （x2 * y * y））; // 2nd迭代，可以删除</ li>  
<li> </ li>  
<li>返回y; </ Li>  
<li>} </ li>  
### 回答 9
有一些。在我的头顶 - 它是Ehud Shabtai的一条线，在深度黑暗的20世纪90年代，一个4dos别名，用于显示提示标题（在Bash中所谓的$ PS1，DOS世界中的％提示％）  
当时 - ％提示％评估中允许的情况没有允许的条件，并且ehud希望以一小时+拨号格式显示一天的时间  
IE：  
15 ^ 15:00 .. 15:14  
15> 15:15 .. 15:29  
15V 15:30 .. 15:44  
15 <15:45 .. 15:59  
用一张纸坐下来，我想到了一些多项式表达 - 当除以某些东西时会提供所需的ASCII代码。  
这可能是第一次  
有一些。在我的头顶 - 它是Ehud Shabtai的一条线，在深度黑暗的20世纪90年代，一个4dos别名，用于显示提示标题（在Bash中所谓的$ PS1，DOS世界中的％提示％）  
当时 - ％提示％评估中允许的情况没有允许的条件，并且ehud希望以一小时+拨号格式显示一天的时间  
IE：  
15 ^ 15:00 .. 15:14  
15> 15:15 .. 15:29  
15V 15:30 .. 15:44  
15 <15:45 .. 15:59  
用一张纸坐下来，我想到了一些多项式表达 - 当除以某些东西时会提供所需的ASCII代码。  
这可能是第一次看到我后来实现的是分支免费编程。 [线路是类似的 - 不是最可读的东西，我认为ehud说很难写，应该很难读;他将在某个时候评论评论时]  
<ol>％@小时％@ char（％@ mod [mode * 1647,342] +％@ mod [mime * 547,321] * 44）</ ol>  
<li>％@小时％@ char（％@ mod [mode * 1647,342] +％@ mod [mime * 547,321] * 44）</ li>  
他的％提示％最终看起来像  
15 ^ c：\ blahblah \ moshe>  
我不记得这个代码，我记得第一次看到这个，然后编辑他的4dos .profile等价物（shell.btm？），并告诉他他必须有点疯狂，或者至少是一个真正的黑客，在最古典感觉。 [我的意思是，他的个人命令线设置水平的bling，相当于当今'oh-my-zsh'哦，我的zsh不会让你成为一个10x的开发人员......但你可能觉得自己像一个。，ehud肯定是一个我遇到过的10倍开发人员]  
另一个'喜欢'优雅的代码线，是Peter Norvig在Python中的抽象类在0行代码中。 Norvig写了很多优雅的代码（来自他的书籍和在线示例）。但这简明扼要了。  
 -   
有一些艺术编码领域具有优雅的短线。  
我正在做一些与少数朋友的类似事情，例如 - 正弦波发生器或各种声音振荡器可以优雅地写入“一衬垫”，以及差分方程的数学优雅。  
SC140 Supercollider.  
小小的音乐  
机场2/1 by @ p01  
R / JS1K.  
 -   
我想我可以继续。但我现在会停下来。  
### 回答 10
与Robotron 2084开发人员（VID Kidz）设法在汇编程序中实现面向对象的编程。只要各种对象（例如播放器和所有BADDY类型）以某种方式组织它们的数据（例如，x坐标，y坐标，结构顶部的像素数据源地址），您可以通过对象的地址来传递对象的地址一般例程和他们工作 - 类似于利斯沃替代原则。这是在1982年完成的！  
VID Kidz还创建了一种我认为很酷的多任务和调度系统。很多很多东西填充了48k rom。  
在Galaxian（1979）中，他们设法通过转动显示器在其侧面横向滚动整个外星人，并使用硬件的列滚动功能来制作外星人的行。想想是多么巧妙！  
如果你在高级语言中询问我关于很酷的代码，我必须思考长而且很难:)  
### 回答 11
当我看到在Pythonzip（* the_list）中的这种方式时，我想知道为什么我的同事代码只创建文件以删除另一个文件并将新文件重命名为删除的文件。直到他解释说，删除和重命名比写入文件要快得多，因此如果程序崩溃，您可能不会用删除的文件留下，并且没有什么可以替换它  
### 回答 12
最巧妙的我不确定，但我最初的是第一次兴奋地嘲笑任何/所有的龙眼：  
<ol> const ayinvalid = meducemap（任何，propor（true，'无效'））</ ol>  
<li> const valyvalid = meducemap（任何，propor（true，'无效'））</ li>  
MeduceMap，任何和普促员来自崇高的缸库库。传递可能或可能不具有无效属性的元素或对象数组，而MeduceMap将在任何monoid下均匀地核开，首先通过第二个参数，这是一个获取`无效的属性的函数，如果存在，则或者如果没有，则默认值为true。  
换句话说，而不是编写一个循环，它必须检查每个项目，breakin  
最巧妙的我不确定，但我最初的是第一次兴奋地嘲笑任何/所有的龙眼：  
<ol> const ayinvalid = meducemap（任何，propor（true，'无效'））</ ol>  
<li> const valyvalid = meducemap（任何，propor（true，'无效'））</ li>  
MeduceMap，任何和普促员来自崇高的缸库库。传递可能或可能不具有无效属性的元素或对象数组，而MeduceMap将在任何monoid下均匀地核开，首先通过第二个参数，这是一个获取`无效的属性的函数，如果存在，则或者如果没有，则默认值为true。  
换句话说，而不是编写一个循环，它必须检查每个项目，如果发现有效，则可以将作者描述了操作的真实状态 - 列表中的任何对象都无效。  
编辑格式化，摘要。  
### 回答 13
作为JavaScript开发人员，我们使用TypeOf运算符检查变量或值的数据类型。但是在NULL，REGEXP，阵列，文字对象和创建类的对象的情况下，Typeof会给对象。这会创造一个问题是那个对象。  
现在要解决此问题对象.Prototype是一种获取JavaScript值的确切数据类型的方法。  
这是完整的代码行  
<ol> object.prototype.tostring.call（[1,2]）; //在array //输出[对象阵列] object.prototype.tostring.call（null）; //在null //输出[对象null] object.p </ ol>  
<li> //输出[对象阵列] </ li>  
<li> object.prototype.tostring.call（null）; //在null </ li>  
<li> //输出[对象null] </ li>  
<li> object.p </ li>  
作为JavaScript开发人员，我们使用TypeOf运算符检查变量或值的数据类型。但是在NULL，REGEXP，阵列，文字对象和创建类的对象的情况下，Typeof会给对象。这会创造一个问题是那个对象。  
现在要解决此问题对象.Prototype是一种获取JavaScript值的确切数据类型的方法。  
这是完整的代码行  
<ol> object.prototype.tostring.call（[1,2]）; //在array //输出[对象阵列] object.prototype.tostring.call（null）; //在null //输出[对象null] object.prototype.tostring.call（{ishuman：true}）; //对象文字案例//输出[对象对象] object.prototype.tostring.call（/ [a-za-z] /）; //正则表达式//输出[对象regexp] var objdate = new date（）; object.prototype.tostring.call（objdate）; //类实例案例//输出[对象日期] </ ol>  
<li> //输出[对象阵列] </ li>  
<li> //输出[对象null] </ li>  
<li> //输出[对象对象] </ li>  
<li> //输出[对象Regexp] </ li>  
<li> var objdate =新日期（）; </ Li>  
<li> //输出[对象日期] </ li>  
现在才能在对象之后修复字符串  
<ol> object.prototype.tostring.call（[1,2,3]）。匹配（/ \ s（[a-za-z] +）/）[1]; //输出阵列</ ol>  
<li> object.prototype.tostring.call（[1,2,3]）。匹配（/ \ s（[a-za-z] +）/）[1]; </ Li>  
<li> //输出阵列</ li>  
快乐编码!!!  
### 回答 14
在HPC16微控制器上，程序状态字AKA标志是内存映射。  
这允许您执行以下操作  
ld psw，#imm  
跳过PSW;将状态字的内容作为指令执行  
这是一个有趣的是，PSW中的一个位连接到输入端口，因此根据输入的值，PSW中的一位为0或1。  
然后，您需要找到两个指令的组合，只有此位不同，然后您有一个快速的位测试，比读取I / O端口快得多，然后测试该位。  
该程序是具有32任务的多任务处理。  
在HPC16微控制器上，程序状态字AKA标志是内存映射。  
这允许您执行以下操作  
ld psw，#imm  
跳过PSW;将状态字的内容作为指令执行  
这是一个有趣的是，PSW中的一个位连接到输入端口，因此根据输入的值，PSW中的一位为0或1。  
然后，您需要找到两个指令的组合，只有此位不同，然后您有一个快速的位测试，比读取I / O端口快得多，然后测试该位。  
该程序是具有32任务的多任务处理。任务只能为2US运行（包括任务交换机）。今天，这可能较少问题，但HPC16是一个3 MIPS处理器，因此您最多有12个指令来开始任务，完成其处理，并停止任务并选择下一个任务，然后选择下一步  
### 回答 15
匿名  
最好的一个衬里：实际上不是代码，但配置：1997/98我将我的公司从坎伯利搬到了吉尔福德的研究园。当然，租用线路的子网变化，所以我必须重新配置DNS。  
虽然这样做，但我读到DNS有默认记录。所以我向Config文件和Hey Presto添加了默认记录，不再www！  
[所以让我们说每天键入10亿个URL。每次输入'www'需要大约0.1s。因此，每天达1000万人秒〜每天300,000人小时x每小时10美元;所以我每天拯救大约300万美元的地球。 ]  
另一个方便的技巧，无论您有两个整数，如果它们是x /（2 ^ n），请使用换档右操作员x >> n;因为它更快。  
### 回答 16
在Pythons的Sklearn机器学习包中，这是计算每个单词的文档频率的函数。 X是表示文本的功能矩阵。每行都是一个热的矢量代表单词的袋子。文档频率是计数每列中的非零元素的数量。  
如果x是密集的矩阵，则计算可能是：  
<ol>（x！= 0）.sum（轴= 0）</ ol>  
<li>（x！= 0）.sum（轴= 0）</ li>  
但是NLP，x通常是稀疏矩阵。该函数接受SCIPY压缩稀疏列（CSC）或压缩稀疏行（CSC）格式的输入。稀疏矩阵压缩格式仍可计算文档频率  
在Pythons的Sklearn机器学习包中，这是计算每个单词的文档频率的函数。 X是表示文本的功能矩阵。每行都是一个热的矢量代表单词的袋子。文档频率是计数每列中的非零元素的数量。  
如果x是密集的矩阵，则计算可能是：  
<ol>（x！= 0）.sum（轴= 0）</ ol>  
<li>（x！= 0）.sum（轴= 0）</ li>  
但是NLP，x通常是稀疏矩阵。该函数接受SCIPY压缩稀疏列（CSC）或压缩稀疏行（CSC）格式的输入。稀疏矩阵压缩格式仍可以单行代码计算文档频率。  
<ol> def _document_frequency（x）：计算稀疏x中每个功能的非零值的数量。如果sp.isspmatrix_csr（x）：return np.bincount（x.indices，minlength = x.shape [1]）否则：返回np.diff（sp.csc_matrix（x，copy = false）.indptr）</ ol>  
<li> def _document_frequency（x）：</ li>  
<li>计算稀疏X的每个功能的非零值的数量。</ li>  
<li>如果sp.isspmatrix_csr（x）：</ li>  
<li>返回np.bincount（x.indices，minlength = x.shape [1]）</ li>  
<li> else：</ li>  
<li>返回np.diff（sp.csc_matrix（x，copy = false）.indptr）</ li>  
### 回答 17
Brian Kernighan的比特数：  
<ol> int count_set_bits（int n）{int count = 0;虽然（n！= 0）{n＆=（n-1）;count ++;返回续;} </ OL>  
<li> int count_set_bits（int n）{</ li>  
<li> int count = 0;</ Li>  
<li> while（n！= 0）{</ li>  
<li> n＆=（n-1）;</ Li>  
<li> count ++;</ Li>  
<li>返回续;</ Li>  
<li>} </ li>  
### 回答 18
编码因子函数的递归方式非常漂亮。  
在Swift中，它是：  
func fac（_ n：int） - > int {  
如果n == 1 {  
返回n  
让f = n * fac（n-1）  
返回f.  
}  
### 回答 19
我认为我已经看到的最巧妙的单线代码在单行中交换两个变量的值：  
复杂（y，x）=复杂（x，y）;  
据我所知，这仅适用于PL / I。  
问题：作为一个软件工程师，你看过的最巧妙的代码是什么？  
### 回答 20
好的，我会折腾一个老人而不是好吃的。当我学习PDP-11实际工作的时候 - 我曾经详细研究过的第一个CPU  - 我的目标是实际上理解这一点。当我这样做时，一个全新的世界恍然大悟。  
线2238 UNIX v6评论：您预计不会理解这一点。  
### 回答 21
这是一系列基本：  
<OL> 10打印CHR $（205.5 + RND（1））;：转到10 </ OL>  
<li> 10 print chr $（205.5 + RND（1））;：转到10 </ li>  
解开此一点：  
RND（1）随机产生0到1之间的数字，当添加到205.5时，转换为整数，表示随机打印字符'205'或'206'，无限期地重复。  
'205'和'206'是PETSCII中的2个可能的“对角线”，该程序在屏幕上产生了真正满足的随机“迷宫”模式。  
我可以说更多关于这个，但诚实地说，我不能比这本书更好地说（打印或作为CC By-NC-SA 3.0 PDF）  
### 回答 22
在Ruby中，您可以使用这样的语法迭代阵列（每个/地图）：  
<ol>用户。家{|用户| user.destroy}＃或users.map {|用户| user.name} </ ol>  
<li>用户。家{|用户| user.destroy} </ li>  
<li>＃或</ li>  
<li> </ li>  
<li> users.map {|用户| user.name} </ li>  
漂亮的标准，对吗？但是，您也可以编写相同的代码：  
<OL> Users.each（＆：destroy）＃或用户。  
<Li> Users.each（＆：Destroy）</ li>  
<li>＃或</ li>  
<li> </ li>  
<li>用户.map（＆：name）</ li>  
很酷，语法较短，可以实现同样的事情，而不是那么特别。但这是如何实现的，我总是找到天才，因为这不是Ruby的解析器的一些特殊语法。  
它滥用“别的东西”是什么，“基本上只需要一个名为”to_proc`的方法就是在此之后传递的。  
`：名称`是一个  
在Ruby中，您可以使用这样的语法迭代阵列（每个/地图）：  
<ol>用户。家{|用户| user.destroy}＃或users.map {|用户| user.name} </ ol>  
<li>用户。家{|用户| user.destroy} </ li>  
<li>＃或</ li>  
<li> </ li>  
<li> users.map {|用户| user.name} </ li>  
漂亮的标准，对吗？但是，您也可以编写相同的代码：  
<OL> Users.each（＆：destroy）＃或用户。  
<Li> Users.each（＆：Destroy）</ li>  
<li>＃或</ li>  
<li> </ li>  
<li>用户.map（＆：name）</ li>  
很酷，语法较短，可以实现同样的事情，而不是那么特别。但这是如何实现的，我总是找到天才，因为这不是Ruby的解析器的一些特殊语法。  
它滥用“别的东西”是什么，“基本上只需要一个名为”to_proc`的方法就是在此之后传递的。  
`：名称`是一个符号。这是一个像一个字符串，但不是完全。您可以将其视为包含字符名称的字符串以简化。  
`＆：姓名`只是一个语法糖，相当于`：name.to_proc`。  
这里是魔法线，实现了`symbol.to_proc`  
<ol>类符号def to_proc proc.new {|对象| Object.send（self）}结束</ ol>  
<li>类符号</ li>  
<li> def to_proc </ li>  
<li> proc.new {|对象| object.send（self）} </ li>  
<li>结束</ li>  
它基本上创建并返回一个Lambda，调用命名的方法与传递的任何对象上的符号相同。  
美丽的短黑客！  
### 回答 23
好！有时我发现了一个只有开发人员名称的评论线。我认为开发人员名称不太重要，我们应该解释代码的任务。然后我们可以将开发人员名称放在。例如：：  
<ol>代码....... // roky代码....... </ ol>  
<li> // roky </ li>  
<li>代码....... </ li>  
### 回答 24
由于您可能从您收到的答案中看到，因此代码行不是巧妙。  
如果单一的代码是巧妙的，我会争论它可能也可能是不可读的。我宁愿在更多的代码中勾出我的天才，并使其更可读。  
我可能更倾向于说明一行本身就是毫无意义的。它可能正在调用其他代码，它具有实际功率。  
但是这里有一些很棒的例子，其中有趣的东西人们哈哈......  
### 回答 25
David Korn's（Korn Shell  -  Ksh-Mame）一班轮赢得了1987年IOCC肯定有资格：  
main（）{printf（＆unix [\ 021％six \ 012 \ 0]，（unix）[st] + fun-0x60）;}  
这将使用宏UNIX的（已过时）默认定义为1上的UNIX / Linux上的1，假设ASCII字符集和K＆R和ANSI C QUIRK，您可以在其中调用未命令功能。  
### 回答 26
想听听真正的独包吗？  
自2000年代初以来，过去两年一直在这个大规模的项目。我没有计算这些线，但一百万行不会让我感到惊讶。其中一半是使用com的c ++，另一半在c＃中。大多数它受到旧学校C专家综合症的患者。  
该项目的关键部分最初是在2000年初的基于模型的软件工程工具中创建的。没有代码开发的早期尝试之一。即便如此，它也可以与项目一起使用，因此必须出口。  
和她们应该冒犯你的工程敏感性。如果你很容易冒犯，现在就停止阅读。  
请参阅，唯一基于模型的代码可以导出到其他内容的唯一方法是作为SQL文件，该文件甚至没有定义表关系。它超过100,000行的SQL行，没有迹象表明，与其他事情有关。  
然后通过Perl脚本转换为C ++代码。  
是的。  
不是一个笑话。  
基于模型的东西→SQL文件→Perl脚本翻译→C ++。  
脚本需要20分钟运行。  
有效。没有人理解如何。有时事情没有工作得很好，但由于没有人真正触摸任何东西，任何没有工作权利的东西都在更高的水平。胶带解决方案。  
我的预算大约是一个数月的时间，只是为了让我现代化，所以它不会再碰到这一点。我同时在个人生活中经历了很多东西。我设法首先解开SQL并提取其中的一些含义，然后将一个实用程序（不是脚本！）放在一起，可以消耗SQL文件并将其转换为C＃。我在那里得到了大约90％的百分比，一些语法并不完全匹配足以编译。但是，嘿，它有一个完全集成的构建过程，转换只需要10秒钟，所以它也会随着能够停止使用Python脚本来构建项目的辅助益处，因为它可以使用MSBuild完成。 yup，python脚本调用Perl脚本在调用项目中的所有单独版本之前转换。  
所以它坐着。没有人敢触摸这个丑陋的怪物，但整个项目都取决于。  
真实的故事，不是一个笑话。  
而每个人都讨论Python脚本以构建项目，但至少是那个维护。  
### 回答 27
它通过取数字来工作，转移位  
快速逆平面根。它使用一个非常奇怪的技术来计算1 / sqrt（x）。  
Square Root是一个非常昂贵的操作，用于执行计算机，并且在处理向量时，您可以使用它来获得载体的长度，例如，又将用于归一化向量。在3D图形中，许多向量需要长度为1.0，因此您可以使用Dot产品来获得像素上的照明量。  
这张照片是从Wikipedia条目中解释的。它是从地震3竞技场游戏引擎中取出，所有的评论都完整：  
它通过取消，从“魔术号”中取出比特并减去结果，从“魔术号”中，“他妈的”行。出于某种原因，该方法的结果1 / SQRT（x）。这不是完全1 / sqrt（x）的结果，但在第1次迭代的评论中计算的计算结果更准确。它最多占误差的4％，在许多情况下足够接近。如果不是，您可以重复上次计算以确切地靠近1 / sqrt（x），并且您可以继续重复它越来越近。但是，当然，如果你继续重复它，整件事就会需要更多的时间，并且在某些时候，您可以使用实际的SQRT功能。对于灯光计算，眼睛几乎看不到4％的错误。  
这让我困惑了这项工作。对我来说，这是黑魔法。甚至甚至可以提出这个问题真是太棒了。但不幸的是，我的数学知识并不是那么大。对维基百科页面的解释是对我的完整的Hocus-Pocus。 ^ _ ^  
### 回答 28
在许多设计缺陷中，两个最令人震惊的  
当我在现有的现有（虽然过时的）电子商务网站上作为领导开发人员开始新的工作时，我任务了解具有愿望清单，信用卡付款，采购订单等功能的新的购物车系统。  
我分析的第一部件之一是购物图表/信用卡系统，该系统已经作为一十年的经济实惠的第三方插件购买。我被这个模块的设计如此惊慌，它立即成为我最优先的更换，不能等待任何其他模块推出。  
在许多设计缺陷中，两个最令人惊叹的：  
### 回答 29
最强大的意义上，我一直抓住我的头部误差！  
我想创建一个延迟，我只是在我的代码中使用空循环以创建几微秒延迟。  
该程序在复杂过程中与零错误完美构建，并创建了十六进制文件，但在执行期间延迟似乎持续延迟。  
我在Vain中搜索了错误，称为几个朋友。  
然后我意识到这个循环是无限循环。  
不同的处理器支持不同的积分数据类型。IN的范围。我在8051微控制器上燃烧了一个8-b的代码  
最强大的意义上，我一直抓住我的头部误差！  
我想创建一个延迟，我只是在我的代码中使用空循环以创建几微秒延迟。  
该程序在复杂过程中与零错误完美构建，并创建了十六进制文件，但在执行期间延迟似乎持续延迟。  
我在Vain中搜索了错误，称为几个朋友。  
然后我意识到这个循环是无限循环。  
不同的处理器支持不同的积分数据类型。IN的范围。我在8051微控制器上刻录了一个8位（一个字节）架构的代码。INT（我使用的十字交叉口允许的大小为16位），所支持的范围是我猜到-215-215到215-1215-1 （即--32768至32767）。  
在此循环中，在后续更新后，我的值从0到最大值，然后在更新变为最小后，再次转到最大值（由于整数溢出）;但由于32767 <100000 <100000，条件总是如此，因为我从未达到100000100000的价值。它会转到最大值，然后再次从最小值到最大值等，因此广告无限制，从来没有出来的循环，从而使循环永远继续。  
将值更改为1000010000（其实际打算，额外的零几乎是看不见的XD。这是一个错误！）代码效果很好。你真的从错误中吸取教训。  
因此，保持数据类型的范围是重要的。我对此无知，这种无知是足够强大的，让我抓住我的脑袋又几个小时：p。简而言之，我们完全学习的每件事都很重要！  
只要您需要一个无限的循环，也可以使用此代码，这确实是强大的：D  
谢谢阅读 ：）  
### 回答 30
到目前为止，在我的经历中，C继续在蓝色的月亮中成为一个神秘的人！就在你认为你知道它的时候，有些荒谬的异常弹出。在我的情况下，我不能帮助，但抓住我的脑袋来弄明白。有时甚至整天都很长！  
因此，这里值得一提的荣誉代码是基于浮点异常。  
<ol> int main（）{float x = 0.7; if（x <0.7）printf（该死的，c是一个神秘的！）;否则打印（明显）;返回0; } </ OL>  
<li> int main（）{</ li>  
<li> float x = 0.7; </ Li>  
<li> if（x <0.7）</ li>  
<li> printf（该死的，c是一个神秘的！）; </ Li>  
<li> else </ li>  
<li> printf（显而易见）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
现在，您认为上述程序的输出将是什么？你可能会说，显然是显而易见的。好吧，如果你还没有，就准备感到惊讶！  
产出：该死的，c是  
到目前为止，在我的经历中，C继续在蓝色的月亮中成为一个神秘的人！就在你认为你知道它的时候，有些荒谬的异常弹出。在我的情况下，我不能帮助，但抓住我的脑袋来弄明白。有时甚至整天都很长！  
因此，这里值得一提的荣誉代码是基于浮点异常。  
<ol> int main（）{float x = 0.7; if（x <0.7）printf（该死的，c是一个神秘的！）;否则打印（明显）;返回0; } </ OL>  
<li> int main（）{</ li>  
<li> float x = 0.7; </ Li>  
<li> if（x <0.7）</ li>  
<li> printf（该死的，c是一个神秘的！）; </ Li>  
<li> else </ li>  
<li> printf（显而易见）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
现在，您认为上述程序的输出将是什么？你可能会说，显然是显而易见的。好吧，如果你还没有，就准备感到惊讶！  
产出：该死的，C是一个谜！  
（请注意，我使用了gcc编译器）  
荒诞？对我来说，是的。一个异常的一个哎呀！毕竟，代码本身很简单，简单。简单地没有这种奇怪的输出的范围。至少不是程序员的结局。  
更奇怪的是它在0.7（即0.6,0.5,0.8,0.9等上，它只突破了它。  
我还在C ++，JavaScript，Python和PHP中代码。因此，出于好奇心，我用其他语言（Python）写了类似的代码。只是为了了解其他语言如何处理同样的情况。  
而且，正如您所看到的，它正如预期的那样工作！  
如何和/或为什么 - 如果这些是现在突出的单词，请阅读！  
首先，让我们看看它的修复程序......  
<ol> int main（）{float x = 0.7; if（x <（float）0.7）printf（该死的，c是一个神秘的！）;否则打印（明显）;返回0; } </ OL>  
<li> int main（）{</ li>  
<li> float x = 0.7; </ Li>  
<li> if（x <（float）0.7）</ li>  
<li> printf（该死的，c是一个神秘的！）; </ Li>  
<li> else </ li>  
<li> printf（显而易见）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
就是这样，明确的类型转换使它正如预期的那样工作。  
观察：为C的编译标准规则写下C的标准规则希望所有原始的浮动数字都被视为加倍，除非另有说明。  
但我很确定你不满意！相信我，即使我不是（不是）。  
结论：阅读后虽然大约有十几堆栈溢出页面[1]我发现它与机器本身存储和处理的代码中的这些数字是如何处理的。事实上，整个过程可能会稍微精心地压倒程序员的眼睛。  
<a> [1] </a>  
可以从IEEE 754 [2]的理解中汲取宏观解释。即，在最小的单词中，用于在计算机系统的物理内存中表示具有一些特定精度的浮动数字。  
<a> [2] </a>  
脚注  
### 回答 31
它实际上不是一行代码，所以说话，但代码线。  
我在Salesforce工作，对于那些不熟悉其云架构的人，如果生产的总体测试覆盖率为75％或更多，则可以将来自QA的组件移动到生产。意思是，如果所有组件的代码行总数，包括新介绍的，必须使用适当的测试场景写入足够的测试类，以便覆盖至少7500行的块。 Salesforce本身强制执行此规则，因此无法解决它。另一方面，断言可以没有。  
如果组件的移动导致生产的平衡转移并将其整体覆盖范围提高到75％以下，您应该在新组件上工作并在部署之前提高其覆盖范围。一个噩梦的噩梦，因为你的代码有很好的机会，只有在多年来已经进入的肮脏代码的历史记录拖动整体覆盖范围的历史记录，才会发生这个问题。  
我以前的公司中有人发现了一种偷偷摸摸的方式来在他（或她）的一些代码中偷渡，而无需担心这个问题。  
所以这是简单的数学，对吗？如果您有5000行代码，则必须涵盖3750行。但是如果我设法只占用2500（50％），我的截止日期是危险的？  
简单的。我添加了5000行不必要的代码，即我可以通过一个函数调用肯定地覆盖，使整个线路编号现在是10000，覆盖线是7500，使我的覆盖率百分比甜点75。  
为此目的，他们在每个中引入了几个完整的课程。该方法始于，  
Integer i = 0;  
并继续重复上行数千次。  
I ++;  
他们有大胆的方法在整个笨重的方法中复制和粘贴这个重复的代码，并且以这种鲁莽的方式，您可以在每一100行左右完全在第一行中看到错误的选项卡。  
现在，您留下的所有这些都在测试类中呼叫此方法，您可以在不破坏汗水的情况下覆盖线路的得分。实际上重要的所有代码可能在自动覆盖检查中未经测试，如果一个人应该注意看看，但是你有效地有效地蒙上蒙蔽了销售部署机制。  
和后果甚至是疯狂的。看到囤积组件的方式可以在不必踏上写作测试类的繁琐过程中，这项技术获得了我们在我们实践中的Salesforce最佳实践等同于Salesforce最佳实践的状态。在几乎所有主要的组织中，如果您搜索它，您可以找到具有I ++流的类;沿着屏幕流动，据您所能滚动下来。  
好吧，在一些未经测试的情景开始再欣培之前，这些披肩陷入困境仍未被未被发现。更明智的开发商捕捞了I ++;课程，抬起闹钟并下来清理混乱。只需删除这些课程将整体生产覆盖率推向深处低，防止任何形式与生产相互作用。我能说什么，这让我们许多人至少忙于一个月。  
我不打电话给愚蠢地把这个代码的开发人员打电话。我宁愿去邪恶。较高的头部和测试人员在鼻子下面传递的时候没有注意看看，确实有资格愚蠢。  
和这个代码......男人，那是我见过的最愚蠢的事情。  
### 回答 32
我主要是因为我看到很多答案都没有真正地解决过于解决的答案。我不是说所有人，但公平的数字不是真正的过度工程的纯粹例子。它们更好地描述为A）的例子是年轻和缺乏经验的或b）不了解问题或c）只是引入效率低下并且不起作用的坏代码。  
过度工程是过度思考问题的过程，产生过度卷积，然而，可能非常聪明，通常是非常通用的代码，其实在现实中最终难以使用，理解或维护。  
一个例子是工程师创造一个如此令人惊讶的系统的人，使得它可以用来在特定主题域中解决几乎任何问题，但是当实施时，当实施时是一个噩梦，因为它是如此疯狂地从问题中抽象出来。  
过度工程的最大迹象是当代码到目前为止抽象出来的问题，你几乎无法找到一块实际代码，一种方法，可变分配，一些具体实施的东西，等等。  
编辑：几个用户想要一个例子或回答，更好地说明概念并回答问题。同样，将代码放在这个论坛中对于大多数现实世界问题来说是禁止的，所以我将提供一些额外的插图和信息。  
过度工程卡通（伟大的比喻）：  
卡通的点，为什么它说明过于工程，是最终用户（桌子末尾的家伙）只是想要一些盐。这告诉我们什么？避免过度工程的最佳事物之一是不要设计到未来的太远，猜测您的客户可能会要求的内容。这可以是计算的风险，或者是一个良好的业务举措，如果您知道您拥有客户或业务需求将在那里，但您需要仔细考虑它。  
超过工程通常会在您提供超过要求的情况下发生的。我问你锤子，水平和螺丝刀。你去商店并用整个300pc力学工具集回来。这很好，但不必要（B / C在这种情况下我只是挂了一张图片）。有时你可能想要这样做，但你需要仔细考虑他们。  
它通常发生的另一种方式是通过过度抽象。上面的卡通是这个问题的一个完美的例子。它不仅在表格需要结束时提供的远远超过用户，另一个人正在创建一些通用，抽象的系统，以便无论谁要求某种东西，无论什么样的调味品，都可以处理。系统不再适用于盐，创建了一层抽象，然后他建立了系统，为该用户的盐来实现它。一个漫长的过程。在这种情况下不必要。您可以再次进一步逐步摘要，并说这不仅仅是一种传递调味品的系统，现在它将成为通过任何物品的系统。您可以进一步逐步说明它不仅仅是传递项目，它可以组合它们，添加它们，减去它们。另一个步骤更进一步，它不再只是物品，但现在它几乎是什么。  
抽象不差，这是一个精彩的概念，你只需要小心你在寻求方面有多远来实现完美的松散耦合和高凝聚力。  
### 回答 33
A2A由Josh Knight。我正在回答这个问题作为软件工程师，开发人员和/或程序员;您在Codebase中见过的最野蛮评论是什么？  
您的问题导致我记得收购由公司源代码中的单一评论保存的软件公司。不是你想到的，而是一个有趣的战争故事。  
1986年末，我在IBM大型机上运行的电子表格程序的源代码源代码。同时，我团队的两个成员正在从软件中收集绩效统计数据，因为它们运行了各种压力测试。我们签订了莲花开发公司的合同设计和监督其展示数据中心的建设。我们还共同开发了微致大型机应用。因此，我们的关系是一种自然的延伸，以审查是计划收购目标的电子表格软件。  
我们处于紧张的截止日期，因为该交易在不到两天内将在不到两天内关闭，我们刚刚收到了包含该软件的9轨磁带。吉姆的员工敦促最后一分钟独立检查，但吉姆最初被贬低，因为IBM已经向他带来了交易。不是技术（根本）吉姆倾向于依靠IBM的专业知识。不幸的是，IBM的观点是我们喜欢公司及其软件，做某事。 IBM已经在没有独立的尽职愿望，但莲花没有人问过这个问题。  
IBM希望在IBM MainFlams上运行的Lotus 1-2-3克隆在IBM MainFrams上运行的Lotus中没有秘密。有几种如此可用的应用程序，但没有莲花的Imprimatur。如果莲花收购了公司，那么越来越多的传闻1-2-3 / m将越早提供。因此，这笔交易直接向曼齐根提出，绕过了他的技术人员。此后，交易几乎越好地升级了自己的生活。  
电子表格软件已在市场上三年，工作人员担心什么样的行李莲花可能正在接受。莲花员工希望我们进行技术尽职调查，但吉姆犹豫不决 - 他不想冒犯IBM。随着截止日期接近的，吉姆授权在剩下的短窗口中对百窗进行了一些非常基本的技术尽职调查。  
被隔离工作，我正在审查来源。在Codebase中表示三种语言：主要是Fortran，一些PL / 1和370个装配机的Modicum。我正在映射他们的监督例程通过数据和其他工件从模块到模块的方式映射，并寻找可能有用的东西。我记得恼火：那天我不得不报告，没有攻击计划 - 做到这一点！做吧！  
源库中的每个模块都是一个大型分区数据集，在初始代码中具有版权声明。当我打开其中一个图形例程时，我介绍了以下文本：版权所有（c）1984年Issco，Inc。这是节省交易的评论。  
我立即叫莲花，并询问他们是否确定了公司与ISSCO之间的合同关系？虽然在SAS，我试图与ISSCO合作，但我无法与他们合作，因为他们要求使用过度的特许权使用费和其他费用来使用或链接到他们的产品的任何组成部分。在任何情景下，电子表格源中的ISSCO代码都存在问题。  
如果公司从ISSCO获得许可，ISSCO将允许许可证传递给莲花？ ......以什么价格？ ......特许权使用费多是多少？无论如何，不​​了解Issco意味着对交易的财务分析有缺陷。吉姆是完善的金融MBA本人，由一位手工采摘MBA的部落支持：这并不漂亮。  
如果ISSCO软件尚未获得许可，那么这笔交易展开的另一类问题：事情会变得更加丑陋。  
我只是一个雇佣的枪，所以吉姆和他的部落都没有解释哪种情况杀死了这笔交易。无论如何，这是一个评论都是它的。  
### 回答 34
而不是谈论初级开发人员写的单一代码，我将谈论一个初级开发人员（当时）和他写的代码数量。  
在我和他合作的特定公司，他通过他的本科学位开始作为一个有偿实习生。在上述实习结束时，他留下了深刻的印象，以至于他被要求留下初级开发。现在，因为这是一个启动，他被提供了股票期权，他决定继续他的学位，但只有一个课程一个学期，所以他也可以全职工作。他在那里工作了很长时间，当公司拿了一个相当大的系列一系列私人资金时，他将他的股票期权销售给公司，让他直接买房子（没有抵押贷款）。他还在20世纪20年代晋升为高级开发，并且可能没有超过一半的代码基础，他没有以某种方式触及或影响。  
如果完成了他，我不知道，但他真的不需要它。  
如果你是一个初级开发，请不要试图用你的天才留下深刻的印象。  
尽量担心您的学习愿意留下深刻的印象，以及您的愿意贡献。如果您正在为代码库的大块贡献，您将为自己做得好。  
### 回答 35
A2A by Josh Knight [https://www.quora.com/profile/josh-knight-19]。我回答你有史以来被视为一名软件工程师的代码是什么？[https://www.quora.com/what-is-the-bost-mind-blowing-纲 -  ef-code-youve-ever-seen-as-a-software-engineer]  
我加入SAS Institute的1977年以来，我真的不是一名软件工程师。我被托尼巴尔聘用了预期我会贡献代码来实施我的一些想法来改善SAS，但销售，营销，......  
