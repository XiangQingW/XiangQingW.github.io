---

title: 你如何下行线路代码？
date: 2022-01-23T22:08:06+08:00

---




## 你如何下行线路代码？  
### 回答 1
如果你的意思是在编辑器中？大多数编辑器都支持键盘上的箭头键，或者如果编辑器处理鼠标输入，那么点击下一行也会有效。  
你的意思是在调试器中吗？它在不同的调试器之间不同，但可能有一个“下一个”或“步骤”命令来执行下一行。  
根据您是否要执行任何函数调用，可能还有一个“跨越”和“踏入”变体，而无需逐步通过该功能。  
如果您不在调试器中，则程序将始终自动执行下一行（或它的等效）。  
### 回答 2
我曾经在一家公司的非技术经理提出过这个天才的想法：发展缓慢，所以他试图激励开发人员通过承诺编写大量代码的奖金来促使开发人员更快地工作日。  
我们当然同意了。这是最好的赚钱的方法，对吗？  
我们立即开始向代码添加ASCII-ART注释。像这样：ascii艺术生成器（Taag）的文字  
此外，而不是这样的代码：  
<OL> for（var i = 0; i <10; i ++）{//代码} </ ol>  
<li> for（var i = 0; i <10; i ++）{</ li>  
<li> //代码</ li>  
<li>} </ li>  
...我们写了这样的代码：  
<OL> for（var i = 0; i <10; i ++）{//代码} </ ol>  
<li>对于</ li>  
<li>（</ li>  
<li> var i = 0; </ Li>  
<li> i <10; </ Li>  
<li> i ++ </ li>  
<li>）</ li>  
<li> {</ li>  
<li> //代码</ li>  
<li>} </ li>  
实际上，你  
我曾经在一家公司的非技术经理提出过这个天才的想法：发展缓慢，所以他试图激励开发人员通过承诺编写大量代码的奖金来促使开发人员更快地工作日。  
我们当然同意了。这是最好的赚钱的方法，对吗？  
我们立即开始向代码添加ASCII-ART注释。像这样：ascii艺术生成器（Taag）的文字  
此外，而不是这样的代码：  
<OL> for（var i = 0; i <10; i ++）{//代码} </ ol>  
<li> for（var i = 0; i <10; i ++）{</ li>  
<li> //代码</ li>  
<li>} </ li>  
...我们写了这样的代码：  
<OL> for（var i = 0; i <10; i ++）{//代码} </ ol>  
<li>对于</ li>  
<li>（</ li>  
<li> var i = 0; </ Li>  
<li> i <10; </ Li>  
<li> i ++ </ li>  
<li>）</ li>  
<li> {</ li>  
<li> //代码</ li>  
<li>} </ li>  
实际上，您可以通过设置IDE来使用像上面的代码样式来生成大量的代码，然后只会自动重新格式化现有代码。  
经过一整天的做法，并提出越来越多的荒谬思想如何膨胀代码，穷人经理终于得到了它。他取消了激励计划。我们恢复了代码库。我们再也没有谈过它。  
### 回答 3
最着名的例子是Bill Atkinson的一个纸条，他在他的代码报告中写了-2千行，我得到了减少的报酬吗？  
他删除了2千条线，使得在MAC上更快地绘制，并且能够在盒子上进行圆角而不进行浮点数。  
Bill Atkinson是规则的例外。  
正常程序员不像那样删除2千行的汇编代码，在这样做时使它更快且更好。  
现在，实际答案。不。你真的不是自己优化代码。你今天看到源代码是这样你和其他人可以阅读你正在做的事情。回来的时候  
最着名的例子是Bill Atkinson的一个纸条，他在他的代码报告中写了-2千行，我得到了减少的报酬吗？  
他删除了2千条线，使得在MAC上更快地绘制，并且能够在盒子上进行圆角而不进行浮点数。  
Bill Atkinson是规则的例外。  
正常程序员不像那样删除2千行的汇编代码，在这样做时使它更快且更好。  
现在，实际答案。不。你真的不是自己优化代码。你今天看到源代码是这样你和其他人可以阅读你正在做的事情。回到人们写议会或混合装配和C / Pascal时，你真的无法读取那个代码，就像永远一样，你只是经过一些测试并祈祷它做了它应该做的事情。  
今天我们需要源代码能够阅读它。编译器带走这段代码并做魔法，他们会剥离从未使用的代码，他们清理你的代码，并优化它超出任何不是Bill Atkinson可以写的人。  
试图过早地优化你的代码，自己注定要失败。很可能你的代码会是一团糟，在一两天之后不可读，它可能会慢。  
通过添加更多行更快地制作代码的示例，请参阅此虚拟示例：  
<ol> var p = 0; for（var i = 0，c = 10; i <c; i ++）{p + = 1} </ ol>  
<li> for（var i = 0，c = 10; i <c; i ++）{p + = 1} </ li>  
所以P每次迭代都会增加。如果你知道将有10个迭代，你可以像这样写作：  
<ol> var p = 0; P ++; P ++; P ++; ... P ++; </ OL>  
<li> var p = 0; </ Li>  
<li> ... </ li>  
<li> p ++; </ Li>  
当然，你可以做p + = 10，但这是一个创意的例子。通过像这样的循环分手，只需自己写下每次计算，如果你在一个程序上做到这一点，它将更快地运行速度，但请记住，您可能需要扩展到最后一个示例中的10千条线。  
今天，这就是一个编译器会做的，它会扩大你的循环并为你做这件事，所以如果你这样做，你就不会看到任何差异。  
您在源代码中优化代码的日子很长。  
虽然是，只是因为我觉得它需要，永远不要把逻辑放在循环里面，就像询问数量一样，它很慢。当您为循环执行循环时，限定符如上图所示的例子，所以我小于C，如果您使用PHP，Ruby，Perl或其他类似语言，许多人会像这样写：  
<ol> for（int i = 0; i <persel.count（）; i ++）...... </ OL>  
即使你做了一个Len（人），它只是对每一个循环的手段，它需要迭代完整的人员列表，这可能是磁盘，这将使它变慢得多。改为执行此操作并添加一行代码，这使得代码更长，将使它变得更快  
<ol> var c = people.count（）; for（int i = 0; i <c; i ++）...... </ ol>  
<li> var c = people.count（）; </ Li>  
<li> for（int i = 0; i <c; i ++）...... </ li>  
上面的是一行长，但你只计算一次，你可以轻松衡量这个，这太快了。  
所以，短答案是不，你不能。  
我曾经有一位同事，他倒退了所有的循环，这太烦人了。他发誓它使一切顺利，我相信1984年它可能已经改变了他曾经与之合作的一些编译器，但今天，他只是让所有的同事对他生气了。  
更新：是的，有许多程序员像晨报一样读取装配。我不是这样的人，当我参与内联有议会的项目时，每个人都有一个规则来触摸那部分。所以这更像是我的经历，而不是每个人  
### 回答 4
我觉得一直说的人  
<OL> A = B </ OL>  
<li> a = b </ li>  
不明白鸭键入。如果您将编程牙齿上的编程齿切换为C或Java等静态语言，我可以看到你为什么这么想，但你是错误的.Dynamic键入实际上是Python最强大和误解的功能之一。鸭键入的优势在于您可以构建与例如多种类型或数据来源一起使用的类。Python中的常见习语是使用类似文件的对象。那是你的美丽可以使任何类看起来像一个文件，因为如果看起来像一个文件并像文件一样谈话，它就是一个文件。这意味着您可以采用任何类或数据结构并将其周围的文件相同界面包裹.OR传递给套接字而不是file.it也适用于另一种方式。您可以包围文件周围的字典，以获取那些采用字典的Object.something也很好，只有动态键入购买您是评估任意字符串的代码：  
<OL>在[16]中：B = foo在[17]中：a = b在[18]：eval（a == b）out [18]：真实[19]：eval（a是b）out [ 19]：真实</ ol>  
<li>在[16]中：b = foo </ li>  
<li>在[17]中：a = b </ li>  
<li>在[18]中：eval（a == b）</ li>  
<li> out [18]：真正的</ li>  
<li> </ li>  
<li>在[19]：eval（a是b）</ li>  
<li> out [19]：真正的</ li>  
所有这些小助手在编码中节省了很多时间，并且对于原型设计代码非常壮观。对于a = ba = bmakes的副本，或者将一个变量简单地指向另一个变量，或者在大多数情况下，您实际上没有需要知道的，但足以说A = BA = BDOES不立即制作一个B中的B副本，因为Python使用名称绑定。例如：  
<OL>在[1]中：B = 1在[2]中：a = b在[3]：hex（id（a））out [3]：0x34578b8l：0x34578b8l：hex（id（b）） [4]：0x34578B8L </ OL>  
<li>在[1]中：b = 1 </ li>  
<li>在[2]中：a = b </ li>  
<li>在[3]中：十六进制（ID（a））</ li>  
<li> out [3]：0x34578b8l </ li>  
<li> </ li>  
<li>在[4]：hex（id（b））</ li>  
<li> out [4]：0x34578b8l </ li>  
您可以看到何时进行分配，该BB和AA实际绑定到相同的精确对象。但是当我在[5]中更改b？<ol>时会发生什么：b = 2在[6]中：hex（id（a ））OUT [6]：0x34578B8L [7]：HEX（ID（B））OUT [7]：0x34578A0L </ OL>  
<li>在[5]中：b = 2 </ li>  
<li>在[6]：十六进制（ID（a））</ li>  
<li> out [6]：0x34578b8l </ li>  
<li> </ li>  
<li>在[7]中：十六进制（id（b））</ li>  
<li> out [7]：0x34578a0l </ li>  
看看那个！当我设置B = 2时，B有一个新的地址。这是因为B现在已经隐含地制作了一个新的对象。然后，如果然后再做一个= BA = B，请观看会发生什么：  
<OL>在[8]中：A = B：HEX（ID（B））OUT [9]：0x34578A0L [10]：HEX（ID（A））OUT [10]：0x34578A0L [11] ]：</ OL>  
<li>在[8]中：a = b </ li>  
<Li>在[9]：十六进制（ID（B））</ Li>  
<li> out [9]：0x34578a0l </ li>  
<li>在[10]：十六进制（ID（a））</ li>  
<li> out [10]：0x34578a0l </ li>  
<li> </ li>  
<li>在[11]中：</ li>  
A和B都同时分享了一个地址。0x3457b8b的对象发生在一起？它仍然存在.Consider以下内容：  
<OL>在[1]中：b = foo在[2]中：a = b在[3]：hex（id（a））out [3]：0x7fe3a2a125f8在[4]：hex（id（b））中[4]：[5]中0x7FE3a2a125f8：x = [6]中的memoryview（a）：x out [6]：<0x7Fe3a19b6180>在[7]：x.tobytes（）out [7]：foo在[ 8]：B =栏[9]：a = baz [10]：aout [10]：baz在[11]：b out [11]：bar in [12]：x.tobytes（）out [ 12]：foo </ OL>  
<li>在[1]中：b = foo </ li>  
<li>在[2]中：a = b </ li>  
<li>在[3]中：十六进制（ID（a））</ li>  
<li> out [3]：0x7Fe3a2a125f8 </ li>  
<li>在[4]：hex（id（b））</ li>  
<li> out [4]：0x7Fe3a2a125f8 </ li>  
<li>在[5]中：x = MemoryView（a）</ li>  
<li>在[6]中：x </ li>  
<li> out [6]：<0x7Fe3a19b6180> </ li>  
<li>在[7]：x.tobytes（）</ li>  
<li> out [7]：foo </ li>  
<li>在[8]中：b = bar </ li>  
<li>在[9]：a = baz </ li>  
<li>在[10]：a </ li>  
<li> out [10]：Baz </ Li>  
<li>在[11]中：b </ li>  
<li> out [11]：酒吧</ li>  
<li> </ li>  
<li>在[12]：x.tobytes（）</ li>  
<li> out [12]：foo </ li>  
数据仍然存在！至少在垃圾收集器与它结束时，无论如何都要完成.WORD对明智的方式：不要依赖这种行为。你已经警告了。事实上，我会说，我会说什么依赖于MemoryView的事情可能是最危险的。所以，正如您所见，A = BA = B根本没有难以预测。  
### 回答 5
绝对不。  
考虑这个简单的问题。  
找到大小Nn的数组（a）（a）的所有整数的总和。  
看起来很简单，对吗？  
现在最简单的方法是简单地写下这些代码行。  
<ol> int ans = 0; for（int i = 0; i <n; i ++）{ans + = a [i]}返回ans; </ OL>  
<li> int ans = 0; </ Li>  
<li> for（int i = 0; i <n; i ++）{</ li>  
<li> ans + = a [i] </ li>  
<li>} </ li>  
<li> </ li>  
<li>返回ANS; </ Li>  
这是最简单的功能，可以为过程制作。但是现在是抓住，这个过程的复杂性是O（n）o（n）。  
现在假设我们必须为NN时间重复此过程，我们必须做几乎n * nn * n计算。  
并且据说如果n> 106n> 106或其他一些大数字，则无法正确缩放效率  
绝对不。  
考虑这个简单的问题。  
找到大小Nn的数组（a）（a）的所有整数的总和。  
看起来很简单，对吗？  
现在最简单的方法是简单地写下这些代码行。  
<ol> int ans = 0; for（int i = 0; i <n; i ++）{ans + = a [i]}返回ans; </ OL>  
<li> int ans = 0; </ Li>  
<li> for（int i = 0; i <n; i ++）{</ li>  
<li> ans + = a [i] </ li>  
<li>} </ li>  
<li> </ li>  
<li>返回ANS; </ Li>  
这是最简单的功能，可以为过程制作。但是现在是抓住，这个过程的复杂性是O（n）o（n）。  
现在假设我们必须为NN时间重复此过程，我们必须做几乎n * nn * n计算。  
并据说如果n> 106n> 106或其他一些大数字，则无法正确扩展以编写有效和快速的代码。  
那么如何解决这个问题，现在？  
让我们只是制作段树。 :)  
<ol> typedef long long ll; void build_sum（ll树[]，ll a []，ll节点，ll s，ll e）{if（s == e）{树[node] = a [s];返回 ; ll mid =（s + e）/ 2; build_sum（树，a，2 *节点+ 1，s，mid）; build_sum（树，a，2 *节点+ 2，mid，e）;树[节点] =树[2 *节点+ 1] +树[2 *节点+ 2];返回 ; } int查询（ll树[]，ll a []，ll节点，ll s，ll e，ll l，ll r）{if（l> e || r <s）返回0; if（l <= s && r> = r）返回树[节点]; int mid =（s + e）/ 2;返回查询（ll树[]，ll a []，ll 2 * node + 1，ll s，ll mid，ll l，ll r）+查询（ll树[]，ll a []，ll 2 * node + 2，LL MID + 1，LL E，LL L，LL R）} </ OL>  
<li> typedef long long ll; </ Li>  
<li> void build_sum（ll树[]，ll a []，ll节点，ll s，ll e）{</ li>  
<li> if（s == e）{</ li>  
<li>树[节点] = a [s]; </ Li>  
<li>回归; </ Li>  
<li>} </ li>  
<li> ll mid =（s + e）/ 2; </ Li>  
<li> build_sum（树，a，2 *节点+ 2，mid，e）; </ Li>  
<li>树[node] =树[2 *节点+ 1] +树[2 *节点+ 2]; </ Li>  
<li>回归; </ Li>  
<li>} </ li>  
<li> </ li>  
<li> int查询（ll树[]，ll a []，ll节点，ll s，ll e，ll l，ll r）{</ li>  
<li>如果（l> e || r <s）返回0; </ Li>  
<li> if（l <= s && r> = r）返回树[节点]; </ Li>  
<li> int mid =（s + e）/ 2; </ Li>  
<li>返回查询（ll树[]，ll a []，ll 2 * node + 1，ll s，ll mid，ll l，ll r）+查询（ll树[]，ll a []，ll 2 *节点+ 2，LL MID + 1，LL E，LL L，LL r）</ li>  
<li>} </ li>  
预处理所花费的时间将是O（NLogn）O（NLogn），并且现在在O（LOGN）O（LOGN）时间中求解每个查询。所以，即使你一次做NN查询，也将是O（NLogn）O（NLogn）的总时间。  
稀疏表的复杂性甚至更少，对于每个查询，它是（O（1））（O（1）），具有相同的预处理时间。  
所以你现在看到了吗？  
即使代码行的数量正在增加，计算复杂性也会降低，这就是使编程更美丽，优雅和高效的所作。 :)  
希望这可以帮助。 :)  
源 - 段树|设置1（给定范围的总和） -  Geeksforgeeks  
### 回答 6
C ++是上下文强语言。这意味着每一行代码都可以在适当的上下文中拍摄腿部。但没有微笑就无法说。好吧，让我的变体是：  
<ol> struct selfjiller {//可能是危险的一些行〜selfjiller（）{删除这个;} //这个是短而表示的}; </ OL>  
<li> struct selfjiller </ li>  
<li> {</ li>  
<li> //某些可能危险的线路太大</ li>  
<li>〜selfjiller（）{删除这个;} //这个是短而表示的</ li>  
<li>}; </ Li>  
对答案的双层感到抱歉。安迪Heilveil已经写了这篇文章。好。让它是真实生活中的代码。想象一下在一个庞大而旧的项目中的字符串（并持续到现在的时间）由一个着名的公司为另一个着名的公司做了一个甚至是一个更有名的人。  
<ol> class somecentnod </ OL>  
<li> class somecentralnod </ li>  
C ++是上下文强语言。这意味着每一行代码都可以在适当的上下文中拍摄腿部。但没有微笑就无法说。好吧，让我的变体是：  
<ol> struct selfjiller {//可能是危险的一些行〜selfjiller（）{删除这个;} //这个是短而表示的}; </ OL>  
<li> struct selfjiller </ li>  
<li> {</ li>  
<li> //某些可能危险的线路太大</ li>  
<li>〜selfjiller（）{删除这个;} //这个是短而表示的</ li>  
<li>}; </ Li>  
对答案的双层感到抱歉。安迪Heilveil已经写了这篇文章。好。让它是真实生活中的代码。想象一下在一个庞大而旧的项目中的字符串（并持续到现在的时间）由一个着名的公司为另一个着名的公司做了一个甚至是一个更有名的人。  
<ol> class somecentralnodeclass_theveryimportanmanager {//一些代码受到保护：std :: map <std :: string，std :: string>非常重要的ktantmap; //一些代码公共：std :: map <std :: string，std :: string>＆getveryimportantmap（）{return miefimportantmap; }}; </ OL>  
<li> class somecentralnodeclass_theveryimportanmanager </ li>  
<li> {</ li>  
<li>保护：</ li>  
<li> //一些代码</ li>  
<li>公众：</ li>  
<li> std :: map <std :: string，std :: string>＆getveryimportantmap（）</ li>  
<li> {</ li>  
<li>返回MiefimportantMap; </ Li>  
<li>} </ li>  
<li>}; </ Li>  
为隐私道德进行更改名称和代码组合，并简化阅读。  
:)  
P.S.我想知道 - 我的文字有很多观点。非常感谢！它没有那么多的升值，它可能是因为我的错误？对不起我的英语，然后......我需要添加那个  
<ol>删除这个; </ OL>  
<li>删除这个; </ Li>  
根本不是坏事。它的危险也取决于背景。当对象始终只能在堆中创建对象时，它可以（有时）可以完成，并且成员方法删除所有者对象。它被广泛使用。例如，请参阅模式状态。基类儿童（播放基本状态角色）在创建新状态对象（新子项）后删除自己。像这样：  
<OL> VOID ON :: OFF（机器* M）{COUT <<从ON OFF开始; m-> setcurrent（新off（））;删除这个; } </ OL>  
<li> void on :: off（machine * m）</ li>  
<li> {</ li>  
<li> cout <<从off关闭; </ Li>  
<li> m-> setcurrent（新off（））; </ Li>  
<li>删除这个; </ Li>  
<li>} </ li>  
当删除这个时;在上下文中被调用，这对案例不充分，（在析构函数f.e.：d）中是糟糕的。  
:)  
### 回答 7
如前所述，接收此问题的确切答案可能永远不会发生，但我认为这是关于您最喜欢的应用程序有多少行代码的信息图表将有助于您获得一个特征的想法：  
希望这有助于，祝你有美好的一天！  
