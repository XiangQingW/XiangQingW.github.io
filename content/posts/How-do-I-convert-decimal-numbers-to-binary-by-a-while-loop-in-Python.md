---

title: 如何在Python中将十进制数转换为二进制循环？
date: 2022-01-23T22:08:26+08:00

---




## 如何在Python中将十进制数转换为二进制循环？  
### 回答 1
我建议您使用标准算法，反复除以2，并注意到剩下的算法。以下是一个示例：将50转换为二进制。反复除以2，你得到：  
50.  
25 R 0.  
12 R 1.  
6 R 0.  
3 R 0.  
1 R 1  
0 r 1.  
请注意，您需要继续，直到您获得零的商。  
剩下的 - 从底部到顶部读取 - 是二进制数;在这种情况下，110010。  
### 回答 2
听着，你已经在这里有几个体面的正确答案，但我真的不明白为什么任何理智的人都不只是使用Freaking Bin（）内置来做这件事。  
### 回答 3
Hilmar Zonneveld的答案是传统和正确的，但这是一种替代方法，可以在使用按位运算符找到正确的顺序以正确的顺序产生1S和2S：  
<ol> n = 50掩码= 64，掩码> 0：打印（1 if（n＆make）else0，end =）n＆=（mask-1）掩模>> = 1 </ ol>  
<li> n = 50 </ li>  
<li>面膜= 64 </ li>  
<li>虽然掩盖> 0：</ li>  
<li>打印（1 if（n＆make）else0，end =）</ li>  
<li> n＆=（mask-1）</ li>  
<li>掩盖>> = 1 </ li>  
0110010.  
当然这只是一个循环练习。如果您想知道十进制数的十六进制，八进制和二进制等同物，则只需执行此操作：  
<ol> n = 50打印（十六进制（n），10月（n），bin（n））</ ol>  
<li> n = 50 </ li>  
<li>打印（十六进制（n），10月（n），bin（n））</ li>  
0x32 0o62 0b110010或者如果您不喜欢前缀  
<OL>打印（十六进制（n）[2：]，OCT（n）[2：]，箱（n）[2：]）</ ol>  
<li>打印（十六进制（n）[2：]，10月（n）[2：]，bin（n）[2：]）</ li>  
32 62 110010.  
### 回答 4
python具有bin（）函数来执行此操作：  
<OL>二进制=箱（十进制）</ OL>  
<li>二进制= bin（十进制）</ li>  
例如：  
<OL> BIN（123）0B1111011 </ OL>  
<Li> Bin（123）</ Li>  
<li> 0b1111011 </ li>  
如果您不喜欢领先的0B，您可以将其切片：  
<OL> Bin（123）[2：] 1111011 </ OL>  
<Li> Bin（123）[2：] </ Li>  
<li> 1111011 </ li>  
如果您坚持有一段时间循环，您可以拥有这个：  
<ol> binary = bin（十进制）[2：]虽然假：继续</ OL>  
<li>二进制= bin（十进制）[2：] </ li>  
<li>虽然假：</ li>  
<li>继续</ li>  
或这个：  
<ol> twoo = 2，而二进制= bin（十进制）[weo：] break </ ol>  
<li> tweo = 2 </ li>  
<li>虽然是两者：</ li>  
<li>二进制= bin（十进制）[ofo：] </ li>  
<li>打破</ li>  
### 回答 5
因为二进制很容易。比十进制更容易。比如，没有比较二进制比十进制更容易的比较。  
以下可能是非常简单的，但以下是为什么二元比十进制更容易的主要原因：  
简而言之，您可以在两分钟内学习如何表示，添加和乘以二进制数，而您至少需要两周，至少需要使用十进制表示。当然，实现一个固有的计算机的机器更容易，这是一个固有的复杂的机器。因此，二进制是明显的选择。  
### 回答 6
无论是for循环还是循环，主要目标是执行一组所需次数的语句。通常在预先知道循环将要执行的循环时使用时使用A for循环。一段时间循环用于当我们不知道循环将执行有多少次时，但知道循环应该执行，只要某些条件为真，就可以执行。但这不是规则，而A for循环可以替换一段时间，反之亦然。  
for循环具有此表格：  
<OL>（初始化;条件;递增/递减）{组陈述; } </ OL>  
<li>（初始化;条件;递增/递减）</ li>  
<li> {</ li>  
<li>一组陈述; </ Li>  
<li>} </ li>  
这可以很容易地转换  
无论是for循环还是循环，主要目标是执行一组所需次数的语句。通常在预先知道循环将要执行的循环时使用时使用A for循环。一段时间循环用于当我们不知道循环将执行有多少次时，但知道循环应该执行，只要某些条件为真，就可以执行。但这不是规则，而A for循环可以替换一段时间，反之亦然。  
for循环具有此表格：  
<OL>（初始化;条件;递增/递减）{组陈述; } </ OL>  
<li>（初始化;条件;递增/递减）</ li>  
<li> {</ li>  
<li>一组陈述; </ Li>  
<li>} </ li>  
这可以很容易地将其转换为一定的循环：  
<OL>初始化; （条件）{章节陈述;增量/减少; } </ OL>  
<li>初始化; </ Li>  
<li> while（条件）</ li>  
<li> {</ li>  
<li>一组陈述; </ Li>  
<li>增量/减少; </ Li>  
<li>} </ li>  
让我们考虑一个小的循环，它从1到10中打印自然数字：  
<OL> for（int i = 1; i <= 10; i ++）{打印i; } </ OL>  
<li> for（int i = 1; i <= 10; i ++）</ li>  
<li> {</ li>  
<li>打印i; </ Li>  
<li>} </ li>  
这里初始化，条件和增量在一个地方分组在一起。现在让我们看看一段时间的循环，使用相同的标记，但现在它们分散在不同的地方：  
<ol> int i = 1;而（我<= 10）{打印i; I ++; } </ OL>  
<li> int i = 1; </ Li>  
<li> </ li>  
<li> while（i <= 10）</ li>  
<li> {</ li>  
<li>打印i; </ Li>  
<li> i ++; </ Li>  
<li>} </ li>  
在这里，我们可以看到初始化，条件和增量表达不在循环中的一个地方分组，而是写在不同的地方。但是相同的逻辑由两个循环完成。  
### 回答 7
如果我们还没有  
在我们将十进制数转换为二进制文件之前让我们确保我们了解定期的十进制数量。我们可以使用十进制数字1337作为随机数来通过一个例子来工作。当我们编写十进制数字1337时，我们实际上是使用一种形式的速记。当我们说1337是1×1000 + 3×100 + 3×10 + 7×11×1000 + 3×100 + 3×10 + 7×1时，我们真正意味着什么  
用文字，1337是1万，3万，3个和7个。但注意到数千，数百，数十和那些，只是10.所示的力量为10.SO 1337 = 1×103 + 3×102 + 3×101 + 7×1001337 = 1×103 + 3×102 + 3×101 + 7×100  
如果我们没有如此习惯了十进制数，我们希望从头开始“构建”这一十进制数，我们可以问自己，建立这个数字多少103103秒？如下10102秒？如此让我们进入二进制世界。在二进制世界我们将使用2的权力而不是权力，而10作为我们的基本构建块。这是案例让我们熟悉2的权力：  
我们可以这样做很长一段时间让我们停在那里：）这些是足够的构建块来重塑二进制中的十进制数字1337.因此，我们需要建立多少211211s 1337？答案是all。所以0×2110×211  
建立1337次需要多少210210次？我们可以使用其中一个。等等，这是1×2101×210.当我们使用210210构建块时，我们仍然有313左到构建（因为1337  -  1024 = 313）.so让我们继续进行。有多少2929s可以用来构建313？答案是没有。太大了。那是0×290×29  
可以使用多少2828秒来构建313？我们可以使用其中一个。所以答案是1×281×28.当我们使用2828个构建块时，我们仍有57左右（因为313  -  256 = 57）。所以让我们继续前进。何时可以使用2727年来构建57？答案是none。太大了。那是0×270×27  
可以使用多少2626秒来构建57？答案是none。它也太大了。那是0×260×26  
可以使用多少2525秒来构建57？我们可以使用其中一个。所以答案是1×251×25.当我们使用这个2525个构建块时，我们仍然有25个建设（因为57  -  32 = 25）。所以让我们继续前进。有多少2424s可以用来建造25？我们可以使用其中一个。所以答案是1×241×24.当我们使用这块2424个构建块时，我们仍然有9个左翼（因为25  - 16 = 9）.so让我们继续前进。许多2323s可以用来建立9？我们可以使用其中一个。所以答案是1×231×23.当我们使用这块2323建筑块时，我们仍然有1个左转构建（因为9  -  8 = 1）。所以让我们继续前进。很多2222s可以用来建立1？答案是none。太大。那是0×220×22  
可以使用多少2121s来构建1？答案是none。它也太大了。那是0×210×21  
可以使用多少2020年代来构建1？答案是one.so，这是1×201×20  
现在让我们把这个整合在一起并加起来所有的块获得1337.1337 = 0×211 + 1×210 + 0×29 + 1×28 + 0×27 + 0×26 + 1×25 + 1×24 + 1× 23 + 0×22 + 0×21 + 1×201337 = 0×211 + 1×210 + 0×29 + 1×28 + 0×27 + 0×26 + 1×25 + 1×24 + 1×23 + 0×22 + 0×21 + 1×20。好！好的，这是一种表达1337的一种相当笨拙的方式。这就是为什么我们只写下每个块的次数，因为我们从左到右使用，这成为：  
1337（十进制）= 010100111001（二进制）  
在左侧出现的0不是必需的。来自的事实来自于211211已经大于1337开始。同样的两个力量也是如此，也是如此较大的力量。零数量左侧会产生相同的数字，因为它们只表明大型已经太大而无法为我们的号码提供贡献。所以我们可以从左侧删除任何零点，然后到达我们的最终答案：  
1337（十进制）= 10100111001（在二进制中）。所以数量小于1的数字约为0.当我们写入（十进制）0.375时，我们使用上述相同的速记。我们正在写出10个块的每个力量的数量需要建立所需的数字。唯一的区别是，现在十的权力是负面的指数。它是什么0.375真的意味着：0×100 + 3×10-1 + 7×10-2 + 5×10-30× 100 + 3×10-1 + 7×10-2 + 5×10-3.Let使用相同的想法以二进制形式写入0.375。我们需要了解2的负极权力：  
请注意，0.375 = 0×2-1 + 1×2-2 + 1×2-30.375 = 0×2-1 + 1×2-2 + 1×2-3.SO 0.375（十进制）= 0.011（在二进制）。将我们的两个例子放在一起，我们可以说1337.375（十进制）= 10100111001.011（二进制）。矩形！你现在是世界上10种类型的人中最好的。  
### 回答 8
循环格式 -   
<OL>初始化;虽然（条件）{body递减/增量变量} </ ol>  
<li>初始化; </ Li>  
<li> while（条件）</ li>  
<li> {</ li>  
<li>身体</ li>  
<li>递减/增量变量</ li>  
<li>} </ li>  
e。 G。 -   
<ol> int i = 10; （i> 5）{cout << i;一世 - - ; } </ OL>  
<li> int i = 10; </ Li>  
<li> while（i> 5）</ li>  
<li> {</ li>  
<li> cout << i; </ Li>  
<li> i  -   - ; </ Li>  
<li>} </ li>  
输出 -  
<OL> 10 9 8 7 6 </ OL>  
<li> 10 9 8 7 6 </ li>  
2.您要在For循环中使用的变量可以早期初始化，也可以初始化为循环的循环变量初始化部分。  
对于循环格式 -   
<OL>（初始化;条件;递减/增量）{body} </ ol>  
<li>（初始化;条件;递减/增量）</ li>  
<li> {</ li>  
<li>身体</ li>  
<li>} </ li>  
或者  
<OL>初始化; for（;条件;递减/增量）</ ol>  
<li>（;条件;递减/增量）</ li>  
循环格式 -   
<OL>初始化;虽然（条件）{body递减/增量变量} </ ol>  
<li>初始化; </ Li>  
<li> while（条件）</ li>  
<li> {</ li>  
<li>身体</ li>  
<li>递减/增量变量</ li>  
<li>} </ li>  
e。 G。 -   
<ol> int i = 10; （i> 5）{cout << i;一世 - - ; } </ OL>  
<li> int i = 10; </ Li>  
<li> while（i> 5）</ li>  
<li> {</ li>  
<li> cout << i; </ Li>  
<li> i  -   - ; </ Li>  
<li>} </ li>  
输出 -  
<OL> 10 9 8 7 6 </ OL>  
<li> 10 9 8 7 6 </ li>  
2.您要在For循环中使用的变量可以早期初始化，也可以初始化为循环的循环变量初始化部分。  
对于循环格式 -   
<OL>（初始化;条件;递减/增量）{body} </ ol>  
<li>（初始化;条件;递减/增量）</ li>  
<li> {</ li>  
<li>身体</ li>  
<li>} </ li>  
或者  
<OL>初始化; for（;条件;递减/增量）{body} </ ol>  
<li>初始化; </ Li>  
<li>（;条件;递减/增量）</ li>  
<li> {</ li>  
<li>身体</ li>  
<li>} </ li>  
e。 G。 -   
<OL> for（int i = 1; i <= 5; i ++）{cout << i; } </ OL>  
<li> for（int i = 1; i <= 5; i ++）</ li>  
<li> {</ li>  
<li> cout << i; </ Li>  
<li>} </ li>  
或者  
<ol> int i = 1; for（;我<= 5; i ++）{cout << i; } </ OL>  
<li> int i = 1; </ Li>  
<li> for（; i <= 5; i ++）</ li>  
<li> {</ li>  
<li> cout << i; </ Li>  
<li>} </ li>  
输出 -  
<OL> 1 2 3 4 5 </ OL>  
<li> 1 2 3 4 5 </ li>  
现在根据您的问题，您想要在循环中更改为循环。  
可以合并循环的初始化，条件和递增部分以形成循环的参数。  
e。 G。 -   
来自 -   
<ol> int i = 10; （i> 5）{cout << i;一世 - - ; } </ OL>  
<li> int i = 10; </ Li>  
<li> while（i> 5）</ li>  
<li> {</ li>  
<li> cout << i; </ Li>  
<li> i  -   - ; </ Li>  
<li>} </ li>  
对于循环 -   
<OL> for（i = 10; i> 5; i  -   - ）{cout << i; } </ OL>  
<li>（i = 10; i> 5; i  -   - ）</ li>  
<li> {</ li>  
<li> cout << i; </ Li>  
<li>} </ li>  
输出 -  
<OL> 10 9 8 7 6 </ OL>  
<li> 10 9 8 7 6 </ li>  
希望你觉得它有用。  
谢谢你。  
### 回答 9
一般来说，如果您有一个for循环：  
<OL>在易读中的项目：进程（项目）</ ol>  
<li>在Iterable中的项目：</ li>  
<li>过程（项目）</ li>  
然后它是循环等价物的is：  
<ol> iterator = iter（erterable）虽然true  
<li> iterator = Iter（易于）</ li>  
<li>虽然真实：</ li>  
<li>尝试：</ li>  
<li>项目=下一个（迭代器）</ li>  
<li>除了停止例外：</ li>  
<li>＃默默地消耗停止</ li>  
<li>打破</ li>  
<li>除例外除外：</ li>  
<li>升高</ li>  
<li>过程（项目）</ li>  
在几个非常具体的情况下，由于迭代的性质  
范围  
如果它是一个非常简单的循环 - 围绕一个范围对象，那么  
<OL>在范围内的项目（开始，</ OL>  
<li>在范围内的项目（start，</ li>  
一般来说，如果您有一个for循环：  
<OL>在易读中的项目：进程（项目）</ ol>  
<li>在Iterable中的项目：</ li>  
<li>过程（项目）</ li>  
然后它是循环等价物的is：  
<ol> iterator = iter（erterable）虽然true  
<li> iterator = Iter（易于）</ li>  
<li>虽然真实：</ li>  
<li>尝试：</ li>  
<li>项目=下一个（迭代器）</ li>  
<li>除了停止例外：</ li>  
<li>＃默默地消耗停止</ li>  
<li>打破</ li>  
<li>除例外除外：</ li>  
<li>升高</ li>  
<li>过程（项目）</ li>  
在几个非常具体的情况下，由于迭代的性质  
范围  
如果它是一个非常简单的循环 - 围绕一个范围对象，那么  
<OL>在范围内的项目（开始，停止，步骤）：进程（项目）</ OL>  
在范围内的项目（开始，停止，步骤）：</ li>  
<li>过程（项目）</ li>  
转换为：  
<ol>项目=启动（步骤> 0和项目<stop）或（步骤<0和项目> stop）：进程（项）项+ =步骤</ ol>  
<li>项目=开始</ li>  
<li> while（步骤> 0和项目<stop）或</ li>  
<li>（步骤<0和项目>停止）：</ li>  
<li>过程（项目）</ li>  
<li>项目+ =步骤</ li>  
正如您可以看到for循环更简单（即使在循环简单的情况下），因为它在内部处理了负面步骤）。  
容器  
如果它是一个简单的循环围绕整数可索引容器：  
<ol>在my_list中的项目：进程（项目）</ ol>  
<li>在my_list中的项目：</ li>  
<li>过程（项目）</ li>  
可以转换为：  
<ol> index = 0，而索引<len（my_list）：进程（my_list [index]）索引+ = 1 </ ol>  
<li> index = 0 </ li>  
<li> index <len（my_list）：</ li>  
<li>过程（my_list [index]）</ li>  
<li>索引+ = 1 </ li>  
但是循环将更慢（并且诚实不那么可读）。  
在实际代码中，几乎没有或根本没有充分的理由将循环完美可读为一小时的循环。一般一般的循环将有更多的代码（因此，错误的机会更大），并且还将包含一个“递增”的步骤，如果您的进程逻辑复杂，则可以容易地失踪。  
### 回答 10
将二进制数转换为十六进制数并将二进制数转换为二进制编码十进制（BCD）是什么区别的？转换时，二进制数在两个场景中的4位数后分开  
由于OP注意，两组二进制数被分组为4位段。主要区别是每组的范围。  
在十六进制中，组的值范围为0到15，但在BCD中，范围为0到9。  
十六进制是纯二元。必须解释整个数字串，以便找到任何十进制数。在BCD中，每个组表示每个十进制数的值。  
例如，占用十进制数25。  
在十六进制中，这是0001 1001（16 + 8 + 1）  
在BCD中，25代表0010 0101（20＆5）  
大多数计算机将使用纯二进制（对于整数数字 - 浮点数不同），尽管过去的少数人（例如，IBM 650）被设计为在BCD中工作。  
数字计数器或频率计，其输出几乎总是一串十进制数字，将使用BCD进行计数器。  
### 回答 11
如果你想进入细节  
大多数时候，它没有。它存储并在二进制中的所有数字上运行。  
它必须转换为小数的唯一时间是它必须向用户显示数字，或者从用户接受数字输入。在这些情况下，你实际上的实际不是十进制数，而是一串看起来像十进制数的字符串。  
C STDLIB函数（如ATOI（）[ASCII至INTEGER]将十进制字符串转换为整数（二进制）值。有类似的功能，用于转换为浮点表示，并进行其他方式。  
如果您想进入ATOI（）实际工作原理的详细信息，这篇文章是一个很好的起点 - 它需要您通过基本直接方法的实现，然后在几个边缘案例中添加了也需要考虑。写下自己的atoi（） -  geeksforgeeks  
### 回答 12
这里的算法：  
第1步：阅读数字  
第2步：声明堆栈  
步骤3：重复步骤4和5，直到值= 0  
第4步：按下返回值％10  
步骤5：值=值/ 10  
第6步：打印堆栈  
