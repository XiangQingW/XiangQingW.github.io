---

title: 在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？
date: 2022-01-23T22:08:15+08:00

---




## 在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？  
### 回答 1
在标准Perl 5的情况下，它只是解析字符串以将其转换为其内部字节码表示，并且  
我很确定我通过使用eval（）在Perl中的运行时使用的函数使用的示例触发了这个问题。但是，eval对Perl不是唯一的。它于1958年回到了Lisp。  
eval语句实际上处理在字符串或其他数据结构中保持的块的块，并执行它。它是一个用于将数据转换为代码的桥梁。  
语言实现可以解释它，或者它可以在飞行中生成机器代码，或者两者的某种组合。  
在标准Perl 5的情况下，它只解析了字符串以将其转换为内部字节码表示，并允许主解释器循环执行其内容。  
FANCIER语言实现可以携带刚刚立即编译器，以便在运行时实际生成机器代码。  
您还可以找到一个混合的语言实现，执行一些代码作为本机计算机代码，并解释其他代码。我在前一个链接讨论了一些混合动力。  
### 回答 2
本机代码只是另一种类型的中间表示。程序员可以始终在软件中实际上实现一台机器，以将代码编译为自己或确实任何设计的中间表示。这些程序通常称为口译员或虚拟机。  
没有原因无法编译本机代码，然后通过运行程序运行。常见的LISP编译器可以在运行时编译常见的LISP程序，即，从常见的LISP应用程序中运行，并在不停止主机应用程序的情况下运行它们。这个想法和山丘一样古老。  
### 回答 3
这些天，如果语言没有编译为NATIV  
一点都不。  
原始基本实现根本没有编译程序。他们被解释并直接从源代码执行。今天，大量的语言仍然这样做，但它们往往是那些更专业的，在利基应用中使用。  
读取源代码需要很长时间，解释它并执行它所说的。许多以后的基本解释器存储了以令授权的形式存储源代码。因此，而不是必须读取和识别每个打印的每个角色，只有一个字节识别。  
如今，如果语言未编译到本机的机器语言，则它被编译成一个字节代码。您可以将一个字节代码视为作为不存在的计算机的机器代码。它涉及相同的低水平，但它旨在使该特定语言的运行程序。然后解释字节代码。就像在基本的旧时代一样，有一个名为解释器的程序，读取字节代码，识别它的意义并执行它指定的操作。  
字节代码具有另一个大的优势。写一个字节代码解释器比写入全新编译器更容易。因此，如果使用字节代码，则更容易港口语言到新类型的计算机，而不是如果它们编译成本机代码。  
很久以前，我的朋友正在尝试在BBC微型计算机上编写编译器。他发现6502个处理器可怕的编译。为了实现高级语言的常用功能，他必须重复代码，使其太大而无法适合内存，或者他必须继续编译过程调用常见例程，这使得它变得缓慢。因此，他实现了一个字节代码解释器，他尽可能多地优化。例如，他发现加载一个小常数非常常见，所以一半的操作码负载短常数，这是测试者测试的第一个OP-Code。因此，加载短常数实际上只有两种或三个本机指令。这样的东西：  
<ol> next_instr：Inc X LDA [x] BMI Not_Constant推BPL Next_instr not_Constant：... </ OL>  
<li> next_instr：inc x </ li>  
<li> lda [x] </ li>  
<li> bmi not_constant </ li>  
<li>推动</ li>  
<li> bpl next_instr </ li>  
<li> not_constant：... </ li>  
因此，编译成字节代码的程序将从编译到本机代码的速度更快地执行。  
### 回答 4
参考：  
史密斯和Nair的虚拟机。  
Lisp 1.5手动发现  
在虚拟机中，检查JIT（即时）编译器。 JIT编译器将在确定经常执行代码时编译代码。在Intel处理器上运行的某些版本的Java中Java虚拟机指令的JIT编译器。  
但在Lisp系统中也发现了JIT。 IBM 7090的Lisp 1.5包括编程器在运行时涉及的JIT。由于编译代码比解释性代码更多的空间，只有在它是PE时使用  
参考：  
史密斯和Nair的虚拟机。  
Lisp 1.5手动发现  
在虚拟机中，检查JIT（即时）编译器。 JIT编译器将在确定经常执行代码时编译代码。在Intel处理器上运行的某些版本的Java中Java虚拟机指令的JIT编译器。  
但在Lisp系统中也发现了JIT。 IBM 7090的Lisp 1.5包括编程器在运行时涉及的JIT。由于编译代码比解释性代码更多的空间，只有在需要表现时才使用它。  
### 回答 5
是的，如果它编制了。  
有两种语言，编译，作为装配和C（以及其他一些）  
或解释（作为Phython，Java脚本），也有其他人喜欢Java，即使它们也被编译成了机器代码，但也进入其他伪语言，其中Jave运行过。 （与Visual Basic相同，但最后一个被解释）。  
案例1，组装。这在大多数情况下，在大多数情况下都可以轻松到机器代码和1到1。  
案例2，C，也进入机器代码，但函数确实有一束机器代码，大多数指令可能在f之间  
是的，如果它编制了。  
有两种语言，编译，作为装配和C（以及其他一些）  
或解释（作为Phython，Java脚本），也有其他人喜欢Java，即使它们也被编译成了机器代码，但也进入其他伪语言，其中Jave运行过。 （与Visual Basic相同，但最后一个被解释）。  
案例1，组装。这在大多数情况下，在大多数情况下都可以轻松到机器代码和1到1。  
案例2，C也进入机器代码，但函数确实有一束机器代码，大多数指令可能具有少数或相同的100。只有非常特殊的C指令是一个与机器代码的指令，而不是每台计算机。  
解释的谎言Phyhon这始终需要一些程序运行，此外需要安装在几乎与计算机已经拥有的任何操作系统相结合的小型操作系统。  
并且可以想象的是他们有被调用的图书馆和函数（显然这个程序在某些时候运行它完全编译或不起作用  
最后是语言作为Java，被编译，但是被编译成某种有限状态机（我没有真正完全了解所有细节），而是再次类似于使程序都编译为某些点，但是用HI级别函数。不断调用，也需要一些程序来运行。  
### 回答 6
这是编译的编译阶段  
问题：在运行时处理的代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？  
好的第一 - 代码以汇编语言的任何方式都是从汇编语言的所有方式编译和java等更高阶语言都被编译并解析为字节码（由Java虚拟机或JVM中的另一个实体执行的中间语言） ）或机器语言（如C / C ++等语言，经典Visual Basic（6及更早版本）和汇编语言。  
这是编译和执行过程的编译阶段。这是在编译时间处理发生时 - 通常这是类似语法检查和确定是否定义了变量的备忘带。解释的语言如JavaScript，ASP，PHP和旧的QBASIC等语言，并在一步中组合编译和执行相位。  
下一步是执行阶段。这是也称为运行时阶段的内容。这是在运行时处理发生时 - 通常这是诸如垃圾收集和Java的情况下的垃圾收集和垃圾的进程。在类似C ++这样的情况下，运行时未发生太多情况，但有些代码确定Malloc和New / Delete的动态内存分配。可能知道在编译应用程序时，可能会知道内存有哪些内存，并且在每台计算机上不可用，以便在运行时确定它。有一些微流程，在运行时运行的每种语言都会发生，而不是编译时间 - 因为我说 - 它不可能在每台计算机上编译时，它将在它上运行的每台运行，而不是可用的。与检索PC名称的代码一样 - 可能是运行时微进程。确定RAM或硬盘驱动器（HD）空间可能会在运行时进行微流程运行的代码。  
对于像上面提到的那样的解释器类似的东西 - 两个同时发生的编译和运行时进程 - 不一定在同一时间，但它也可能是 - 一个人可能无法辨别在哪里另一个发生了。但是，您将同时进行编译和运行时处理。  
### 回答 7
Q2首先（见下文）Q1  - 基本上有两种类型的代码执行：a）编译（将）源代入机器语言，然后执行该机器代码。执行此操作的步骤是编译时间，链接时间，加载时间和运行时间，即程序执行。在这种情况下，几乎只有在程序运行时发生动态对象加载过程。 b）执行读取源作为数据的程序，然后按照该源的指示运行自己的机器语言例程。这种类型的程序称为解释器。基本，dbase4和python都是解释的源。在所有情况下，所有代码都在运行（即解释器运行）时间。  
### 回答 8
不，为什么代码必须转化为任何东西？  
只要有人能够设计和实施它们，事情就不可能运作。那么，为什么不可能让它变成不同的方式？  
口译员可以执行任何您设计的内容 - 您只是开发一个读取您可能设计的任何语言的程序源代码，并立即执行它所说的。  
但是，由于硬件只能运行特定机器语言，因此需要通过软件实现每种其他形式的表达式。但是，如果您尝试解释低级代码，因为口译员无法理解您的目标（因为它太低的目标太低了，因此无法清除），它不能通过大量优化事物。所以它最终会很慢。  
这意味着软件实施的机器只能在旨在运行的语言足够高级别的语言时才能胜过硬件机器。今天的编程语言很少，因此很难看出VM差异的本机机代码（使用不仅仅是口译员的非常高级VM而是通过微小的边缘）。  
据说，软件实施的机器具有今天的设计灵活性的好处。这意味着没有限制可以完成的内容。他们可以是真正的跨平台，因此，由于正在使用新的架构，因此，由于正在使用新的架构Rosetta 2在缓解这个问题时做得很好。  
为什么仍然如此绑在硬件上？只有计算密集型应用程序可以从直接控制硬件中受益。否则，如果可以了解在极高级别的软件机器上运行，则该行业将更加先进。而且我不一定意味着JVM或类型，这不是比硬件更高的水平。我谈论设计高级语言和机器的可能性，可以推动计算机科学的未来，其中应用程序永远不会负责正确处理和处理资源，以及应用程序的整体目的是源代码完全是什么。  
请注意，Word代码已经不适合当前的高级编程语言可以描述，因为您没有编码/解码它，因为语义很清晰。  
*请注意，解释器中的任何优化步骤仍将是某种形式的编译，即使您可以选择编译到以解释器运行的平台的机器代码以外的东西。实际上，当前的VM通常利用AOT和JIT汇编，实际上最终分别在运行时将中间代码转到本机代码。  
### 回答 9
其次，像Java / C＃这样的部分解释语言有一些名为JIT编译的东西，它不具体允许在运行时执行任意代码，但它确实可以通过编译C来处理意外数据  
有三种方式，这个问题的答案是一个响亮的没有  
首先，像JavaScript这样的完全解释的语言可以在运行时实际上运行任意代码，可以创建一个输入字段，在其中编写一些代码并运行，因为这些语言完全执行而不编译（他们被另一个程序解释为单词，因此名称）  
第二，像Java / C＃这样的部分解释语言有一个名为JIT编译的东西，它不具体允许在运行时执行任意代码，但它可以通过编译代码来处理意外数据来处理该数据只有一次遇到的数据（主要通过泛型）  
最后，像C ++这样的完全编译的语言可以逐步相反方向，其中代码永远不会在运行时执行，而是它完全在编译时运行。对于这种情况，在可执行文件中甚至没有机器代码。  
当然，它可能对这些类别的一些或所有这些类别更广泛地工作而不是解释的，我知道该机制至少提到了所提到的特定语言，并且我认为这可能与语言类有关（虽然实际上没有理由是像C＃这样的语言，但是，例如，能够具有编译时间代码执行）  
### 回答 10
它不是。  
例如，许多编程语言具有常常称为eval（）的机制，您可以在其中构建字符串并将其执行为代码：  
<ol> action =打开文件= address.txt str = action + +文件eval（str）action = close str = action +文件eval（str）action = delete str = action +文件eval（str）</ ol>  
<li>动作=打开</ li>  
<li>文件= address.txt </ li>  
<li>动作=关闭</ li>  
<li>操作=删除</ li>  
<li> str =动作+ +文件</ li>  
<li> eval（str）</ li>  
str中的代码无法在编译时进行评估，因为编译器无法确切地知道，直到运行时可能是什么。出于这个原因，大多数具有此功能的语言是解释的语言，而不是编译语言。  
### 回答 11
在编译程序和执行它之间没有直接路径。 [编辑：假设典型的现代系统上的传统逐步汇编。]  
假设文件hello.cc包含以下内容：  
<ol> #include <iostream> int main（）{std :: cout <<你好世界！\ n; } </ OL>  
<li> #include <iostream> </ li>  
<li> </ li>  
<li> int main（）{</ li>  
<li> std :: cout <<你好世界！\ n; </ Li>  
<li>} </ li>  
现在考虑在Linux中的此shell会话：  
<ol> $ g ++ hello.cc -o hello $ ./hello你好世界！ $ </ ol>  
<li> $ g ++ hello.cc -o hello </ li>  
<li> $ ./hello </ li>  
<li>你好世界！ </ Li>  
<li> $ </ li>  
一旦G ++编译并链接这个程序，它就在磁盘上坐在那里。如果我在该命令之后停止，我的新编译程序将只是无限期地坐下来，无所事事。  
当我最后执行它时（上面的第二行），它执行此编译  
在编译程序和执行它之间没有直接路径。 [编辑：假设典型的现代系统上的传统逐步汇编。]  
假设文件hello.cc包含以下内容：  
<ol> #include <iostream> int main（）{std :: cout <<你好世界！\ n; } </ OL>  
<li> #include <iostream> </ li>  
<li> </ li>  
<li> int main（）{</ li>  
<li> std :: cout <<你好世界！\ n; </ Li>  
<li>} </ li>  
现在考虑在Linux中的此shell会话：  
<ol> $ g ++ hello.cc -o hello $ ./hello你好世界！ $ </ ol>  
<li> $ g ++ hello.cc -o hello </ li>  
<li> $ ./hello </ li>  
<li>你好世界！ </ Li>  
<li> $ </ li>  
一旦G ++编译并链接这个程序，它就在磁盘上坐在那里。如果我在该命令之后停止，我的新编译程序将只是无限期地坐下来，无所事事。  
当我最终执行它时（上面的第二行），它就像任何其他一样执行这个编译的程序。我刚编制的事实很大程度上是无关紧要的。*  
真的，你的问题归结为当我开始新计划时会发生什么？  
在UNIX™派生系统上，这涉及FORK（）/ exec（）或道德等价物。 fork（）创建一个新的进程，即当前一个的副本，exec（）用指定的可执行文件替换当前进程。 （这是一种简化; Fork（）和exec（）有多个变体。）  
诚实我只能与* nix模型说话。  
至于新进程计划的时间，以及其给定的优先级，这取决于OSS策略和配置。我知道Linuxs政策多年来已经多次改变了。例如，Linux已将策略转移到fork之后是否在叉子之后立即运行策略。 （克隆3让您启动暂停的子，或vfork停止父，或者用可runnable叉。）  
我知道Linux和Windows都提供命令行工具，以启动具有特定优先级和CPU关联设置的程序。在Linux中，taskset和chrt命令提供。在Windows中，它是Start命令。我肯定的麦斯卡也是如此，但我不知道他们。  
* OSS检查签名可执行文件作为安全层的一部分，可能会根据商业证书的商业软件相比，我将自己编译的可执行文件不同。至少，我知道它会发生在我的mac上。  
### 回答 12
该过程称为Bootstrap。而且，具有编写的语言编译器，其中没有编译者在其编译的语言中写入编译器，我觉得有资格解释它是如何完成的。  
因此，这里是1979年的如何在Softech工作时为interdata 8/32（Minicuper）写了一个编译器J73 / C的编译器。  
et中提琴。  
当然，如果您早期引导，您只有一个子集编译器，您必须完成编译器。但这只是他们说的一小部分节目。  
### 回答 13
首先，停止将自己与周围的人进行比较，他们可能会足够快地了解编码过程，即使在理解简单的人之前也可能开始编写复杂的代码，但在我的经验中，那些需要更长时间学习的人来说是最好的编码器及其代码往往更具创造力。不要寻求帮助。无论解决方案多么困难，都试图弄清楚自己，无论需要多长时间，除非该项目有截止日期，在这种情况下，使用HELL.STICK在问题上有多难，不给向上。不要依赖书籍，直到你有一些编程经验，那么书籍就是有道理的。歌词拼图和玩游戏帮助锻炼你的脑子。最多的编码人员不希望另一个编码者在行业中，这就是为什么他们有点让他们有点变得更加困难是（这并不意味着编码也很容易）。只有在您停止从别人的帮助下，只有在别人的帮助下，您就可以擅长编码，除非绝对必要的，否则不要要求帮助。  
我知道几年只有他们已经在该领域才能代码的人只是因为他们依赖于他人或其他代码。  
最后，如果你真的很感兴趣，请不要放弃，你将失去探索建立在代码上的全新世界。  
### 回答 14
所以到广告  
我在MC6800上的机器代码中做了第一个编程。第一点是十六进制通常使用而不是二进制，因为它们易于互换并且更紧凑。何时见0x86F0我也看到1000 0110 1111 0000。  
然后回到运行机器代码程序，您有三个步骤：  
在编写程序时，您将使用十六进制，而不是二进制，因为它是制造文档的方法，指令集并更快地写下。这是MC6800的完整指令集，我记忆了最常见的。  
因此要添加两个数字，我会写下汇编程序代码，例如要添加2 + 2的程序并给出结果：  
LDAA＃2  
adda＃2  
SWI.  
然后我会查找操作码并填写那些  
86 02 LDAA＃2  
8b 02 adda＃2  
3F SWI.  
所以现在我有我的程序86 02 8b 02 3f。  
第二步是上传它。我很幸运的是我构建的系统有一个7段LED显示器和十六进制键盘，所以我可以用12个按钮按下这个。有些机器具有二进制交换机基础装载机，这5个字节程序需要大约50个切换到加载。使用二进制装载机将用眼睛读取您的六内的程序，然后用手进入二进制，因为大脑努力与二元写作相同，但物理努力要少得多。  
最后一步是运行它，按下一个按钮，完成。  
### 回答 15
这是根据我目前对编程语言的理解。我不是通过培训的计算机工程师。任何人都可以自由地纠正或改进此答案：  
### 回答 16
答案是他们不能。  
考虑以下简单的C程序，理论上应该在具有C编译器的任何操作系统或处理器上运行。它没有做任何事情，但这是无关紧要的  
<ol> int main（void）{返回0; } </ OL>  
<li> int main（void）</ li>  
<li> {</ li>  
<li>返回0; </ Li>  
<li>} </ li>  
如果在运行Linux的X86 PC上编译此操作，则生成的机器代码将是X86处理器。可执行图像将以Linux进程启动器理解的格式。  
通过您问题的逻辑，您应该能够将可执行文件复制到基于Windows X86的PC并运行它。但Windows期望可执行文件在.com或.exe格式中，具有预定义的标题  
答案是他们不能。  
考虑以下简单的C程序，理论上应该在具有C编译器的任何操作系统或处理器上运行。它没有做任何事情，但这是无关紧要的  
<ol> int main（void）{返回0; } </ OL>  
<li> int main（void）</ li>  
<li> {</ li>  
<li>返回0; </ Li>  
<li>} </ li>  
如果在运行Linux的X86 PC上编译此操作，则生成的机器代码将是X86处理器。可执行图像将以Linux进程启动器理解的格式。  
通过您问题的逻辑，您应该能够将可执行文件复制到基于Windows X86的PC并运行它。但Windows期望可执行文件以.com或.exe格式，具有预定义的标题等。它不会运行该程序。  
或者，root您的Android手机。再次，它不会运行。 Linux操作系统将作为可执行文件识别文件（它具有正确的格式，您可以chmod + x文件使其可执行），但它不会运行，因为文件中的机器指令适用于x86处理器。  
当然，您可以将源文件复制到Windows机器，重新编译并运行它。您还可以使用跨编译器，例如GCC来编译它的ARM并将其复制到Android手机。  
### 回答 17
两者都不。  
可执行文件（或动态加载的库）是二进制文件 - 一个字节序列（与文本文件相对，这是一个字符序列）。字符也可能只是字节（我们调用此类文件纯文本或ASCII文本文件），但根据字符集和编码，字符可以由多个字节组成，并且它们的宽度可能不是在UTF-8编码中的相同字节，例如，一个字符可以是1,2,3或4个字节长。  
但是二进制文件（当我们调用内存中加载的可执行文件和库并由CPU执行）远远超过数字表。首先，在大多数架构中，指令代码序列也不是固定宽度。说明可能或可能没有参数 - 简单的指令，例如在2个CPU寄存器中添加值，或者nop（no nol）只需要一台机器字，而更复杂（即CISC架构）指令应更长;例如MOV（从内存地址复制单词到CPU寄存器），接下来是源地址等。此外，二进制文件还包含常量数据文字（如初始化器-e.g。纯文本字符串），符号表，调试信息（可选地）和加载器的其他元数据...  
简而言之，该文件具有一个相对复杂的组织，不能通过任何叫做数字表的手段。如果您进一步对可执行文件如何看起来像，请查看可执行文件和可链接格式 - 例如，维基百科。  
### 回答 18
首先，让我们熟悉以下事情： -   
源代码： - 主要包括描述现实世界逻辑的一组指令。它以人类可读形式，以任何高级语言编写，如C，C ++，Java，Python等。  
汇编代码： - 由表示寄存器的助记符或符号组成，（在运行时间期间使用的内存）以及集合电子操作。  
机器代码： - 仅包括电压水平形式的低电平电子指令。机器代码有时也称为对象代码。  
如果您希望，您可以访问下面的链接。  
是什么  
首先，让我们熟悉以下事情： -   
源代码： - 主要包括描述现实世界逻辑的一组指令。它以人类可读形式，以任何高级语言编写，如C，C ++，Java，Python等。  
汇编代码： - 由表示寄存器的助记符或符号组成，（在运行时间期间使用的内存）以及集合电子操作。  
机器代码： - 仅包括电压水平形式的低电平电子指令。机器代码有时也称为对象代码。  
如果您希望，您可以访问下面的链接。  
组装和机器代码之间有什么区别？  
现在编译器以下列方式将源代码转换为机器代码： -   
步骤1.将源代码转换为对象文件（机器代码），只能单独运行特定的CPU架构或处理器。这是按以下方式完成的： -   
编译器首先将源代码转换为其装配等效物。这种简单，因为源代码中使用的功能和子程序只不过是一组汇编助记符。组合指令集可能是或可能不会转换为其十六进制等价物。有时，每行十六进制代码都描绘了二进制指令的确切数字转换，并且在其他时间编译器已经使用它的字典，将十六进制代码转换为二进制指令集。该二进制指令集不仅包含电子指令，还包含有关操作，调试等内存分配的信息。  
步骤2.链接： - 对于在操作系统环境中可执行的机器代码，编译器链接或修改源代码通过将其与包含用于运行程序的必要资源的其他文件，并且资源可以是多件事如： - 操作系统控制台，终端，OS控制台的标准菜单项，有关访问某些内存部门的特定权限的说明。  
下面的流程图描绘了所有操作： -   
脚注： -   
有关更深入的洞察力，必须去参加这些链接： -   
编译器设计教程 -  Geeksforgeeks  
图像源码：-http：//www2.hawaii.edu/~takebaya/ics111/process_of_programming/process_of_programming.html  
### 回答 19
这取决于你的意思是简单的，甚至是完全资格的问题。  
简单的a = b可以很简单。如果b由编译器知道是一个常量，那么代码可以像：  
将立即常量加载到寄存器中  
但是，如果a是一个类型和b的一个复杂对象是另一个类型的复杂对象是不同类型的另一个复杂性，则可以查找将b类型转换为a的类型，以及复制构造函数，并根据对象组成的是什么对于每个成员值，额外的复制构造函数或常规构造函数。由于A的旧价值正在消失，您也可能也会看析构函数。  
如果=运算符已过载，则甚至可能更糟糕。如果A和B是模板，事情就能真正失控！  
真实的故事：我的一位同事抱怨他没有改变他的代码中的任何事情，现在它正在崩溃。 （通常是一种监督）。但实际上，他是正确的。他没有改变他的代码。但是#include文件已更改，以便重载的函数调用为字符串构造函数创建了一个临时变量，该临时变量在返回悬垂指针时迅速删除（我认为它可能是编译器中的错误......）。  
这就是为什么在C ++中编程充满危险的原因：即使是简单的看语句也可以有隐藏的缺陷。  
### 回答 20
他们做到了。他们是谁？好吧，你的父母和他们的父母，他们的父母，以及尽可能远的父母。语言被认为是。编译器是思想。电脑是大脑。机器语言是神经元射击的模式。在软件之前，湿润是尚未超过的。  
湿式软件创建软件，并尝试通过使其更像自身来完善软件;即，在其创造者自己的形象中。因此，最高级别的编程语言的最终表达是纯粹的思想，并且自追溯以来已经存在。  
