---

title: c / c ++中的const的点是什么？如果使用常量值，为什么会让它将其分配给变量？
date: 2022-01-23T22:08:15+08:00

---




## c / c ++中的const的点是什么？如果使用常量值，为什么会让它将其分配给变量？  
### 回答 1
这个主题大量涵盖了类似的问题：  
我写了一些答案，一个问题，一个问题，一个相关问题：  
<SPAN> JOE ZBICIAK·3Y </ SPAN>  
<span> 3y </ span>  
如果不清楚，我是Const和Constexpr的巨大粉丝。我试图康复我所能的一切。如果它缺少特定变量，那么我知道我在某处修改它。  
在函数原型中，参考或指针参数上的const告诉我该函数不会通过该指针或引用修改所引用的对象。 Const-Permified会员F.  
这个主题大量涵盖了类似的问题：  
我写了一些答案，一个问题，一个问题，一个相关问题：  
<SPAN> JOE ZBICIAK·3Y </ SPAN>  
<span> 3y </ span>  
如果不清楚，我是Const和Constexpr的巨大粉丝。我试图康复我所能的一切。如果它缺少特定变量，那么我知道我在某处修改它。  
在函数原型中，参考或指针参数上的const告诉我该函数不会通过该指针或引用修改所引用的对象。课程中的Const-Pervifired成员函数告诉我，成员函数不会以外观可见的方式修改该类的实例。  
有些人甚至建议使用lambdas初始化具有复杂初始化的const变量。我在一般代码中有复杂的感情，在函数的身体中说。  
但是，我绝对使用Constexpr变量来获得编译时初始化。非常适合在编译时生成查找表！  
<ol> constexpr数组查找= [] {std :: array <int，256>查找{}; //代码计算表返回查找; }（）; </ OL>  
<li> constexpr数组查找= [] {</ li>  
<li> std :: array <int，256>查找{}; </ Li>  
<li> //代码计算表</ li>  
<li>返回查找; </ Li>  
<li>}（）; </ Li>  
一些额外的想法：  
Const变量具有名称和具体数据类型。该名称用作文档，该类型提供编译时类型。  
如果将const（或constexpr）应用于像int的基本类型，并且其初始化程序是编译时间常量，则C ++可以在需要编译时常量的位置使用得到的变量。这不起作用;但是，我们使用$ dayjob使用枚举进行类似的效果。  
您可以用两种语言中的#define foo（123）做同样的事情，但你丢失了一些类型的检查。宏通过文本替代工作。我试图避开它们，因为它们在编译器看到之前有效地编辑程序文本。根据您使用的工具链，以及您如何调用它，宏可能对调试器不可见。 （IIRC，Clang和GCC中的标志-GGDB3将使它们可见GDB。）  
遗憾的是，一个地方必须使用宏是值控制预处理器指令，例如#if和#elif。这就是为什么C使用#defines for true和false而不是标题<stdbool.h>中的枚举。[1]我们实际上在$ DayJob中有一个错误，在那里我们将True / False实现为枚举（自定义工具链），而且#if foo未灭火，因为foo被定义为true。枚举对预处理器不可见，并且在该表达式中，它将其视为0. *哎呀。  
<a> [1] </a>  
最后，有原始值。使用原始值并不会告诉您该值的含义。对于一点代码，可能不是问题。随着该项目的规模和范围和开发人员数量增加，魔术数字变得更加模糊。  
例如，考虑此代码，解除阵列中的单词到字节，以及逆操作：  
<OL> for（int i = 0，j = 0; i <32; i + = 8，++ j）{array [j] =值>> i; for（int i = 0，j = 0; i <32; i + = 8，++ j）{值| =（uint32_t）阵列[j] << i; } </ OL>  
<li>阵列[j] =值>> i; </ Li>  
<li> </ li>  
<li> for（int i = 0，j = 0; i <32; i + = 8，++ j）{</ li>  
<li>值| =（uint32_t）阵列[j] << i; </ Li>  
<li>} </ li>  
比较：  
<ol> for（int i = 0，j = 0; i <kbitspord; i + = kbitsperbyte，++ j）{array [j] =值>> i; for（int i = 0，j = 0; i <kbitsperw; i + = kbitspertype，++ j）{value | =（wordtype）阵列[j] << i; } </ OL>  
<li> for（int i = 0，j = 0; i <kbitsperw; </ li>  
<li> i + = kbitsperbyte，++ j）{</ li>  
<li>阵列[j] =值>> i; </ Li>  
<li>} </ li>  
<li> </ li>  
<li> for（int i = 0，j = 0; i <kbitsperw; </ li>  
<li> i + = kbitspertype，++ j）{</ li>  
<li> value | =（WordType）阵列[J] << i; </ Li>  
<li>} </ li>  
现在这些数字的意图和含义更明显。它是谁？是的。但即使是不知道C或C ++的人也有更好的想法现在正在发生什么。  
而且，奖金：如果数据类型需要稍后更改，则更容易此操作。  
*在一个#if中，在宏扩展后，它将用pp-number 0替换任何剩余的标识符（例如true），然后继续评估表达式。  
脚注  
### 回答 2
可以在执行期间初始化const。likeconst int x = read_value（）;  
x是const，但它的值在编译时是未知的。  
我们可以通过引用传递const。我们不能用文字或巨蟹来做到这一点。  
关于const的主要事情是我们需要它在团队中工作。一个程序员设置变量修改器const，因此其他人无法改变它，他可以编写一个程序，确保它不会改变 - 或者至少，如果有人想要改变它，他将被迫使用const_cast，这被认为是一件坏事，所以他会试图找出为什么是const。  
### 回答 3
它通知编译器变量的值不会更改。它有几个后果，但他最重要的是：  
### 回答 4
在基本类型如整数的情况下，您可能希望提供一个解释性名称，以便在需要时更容易理解代码或更容易更容易更改常量的值。编译器可能会生成常量编号，而不为实际变量分配任何内存。  
如果Const变量是一个对象，它必须自己的内存并像任何其他变量一样构造和破坏。因此，恒定不会改变其形式，无法在施工后未经修改。  
### 回答 5
在变量上使用Const限定符不是关于值本身的值，这些值可以在编译时间或甚至在运行时计算（即，在代码实际运行之前可能不是已知值）。 Const限定符只是告诉编译器，一旦将该值被计算并分配给变量，您的其余代码都不会被允许更改该变量。因此，在某种意义上，它不是一个恒定的值，如42像素一样固定和已知前面。这是一个常数在某种意义上，一旦将值分配给它（可能会在运行时计算，并且可能从程序的一个运行到下一个程序可能会有所不同），则不允许更改变量的值。编译器强制执行此规则（虽然它可以通过指针围绕指针并施法康强，但这不是推荐的练习）。  
另一个，实际上更常见，使用const是在函数定义中的指针参数上。当将指针传递到阵列或缓冲区中的函数时，您可能希望放心，函数只会读取数据并不会更改数据。在这种情况下，应将指针参数声明为指向要常规数据的指针。在C ++中，Const参考参数告诉用户该功能不会修改参考参数的值......它在该功能内部有效地只读。  
您甚至可能有一个const vlatile变量，它会吹来c ++新人的思想。它是const，因为您的代码不允许更改值（即，从您的代码的透视中只读），但它也是易失性的，因为一些其他线程，硬件设备等可以在任何内容改变值时间。例如，设备控制器的状态寄存器可能是constverile，因为您只能读取它，但设备控制器可能导致其值在任何时刻更改。这种情况显着说明了const不是关于价值是一个常量的，而是关于编译器会让你做什么（即，它不会让你为它写一个新值）。  
还有其他用途。例如，Const用于C ++成员函数，该函数承诺不会更改对象的内容（指向该指针）。这有效地声明了隐含的该指针作为指向要常规数据的指针。  
这不是C ++中Const的详尽列表（考虑到这一点，是沿两个单独路径发展的两个单独的语言）。  
### 回答 6
从C ++透视回答（可能不适用C）  
您可能使用const的原因：  
<OL> 9999 </ OL>  
<li> 9999 </ li>  
自己的意义很少  
<OL> Const Short ClientPort = 9999 </ OL>  
<li> const short clientport = 9999 </ li>  
告诉你更多  
### 回答 7
假设您正在编写一个使用代表电子表格内容的对象的功能。如果该表格中有很多数据，则创建要传递给函数的副本可能非常昂贵。如果您通过引用传递给它，那么无论对象的大小如何，复制到函数的数据都具有常量大小。  
但是现在你有一个问题，因为来电者无法确定你不会修改他们的对象。因此，您声明了输入A Const Reference，并保证您不会进行任何更改，每个人都很开心。  
### 回答 8
在C和C ++ Const中的手段在此范围内不会修改此操作。它与恒定值无关。  
如果您检查后账户余额，那么您所需的金额不应该可修改。在这种情况下，银行账户数据被保护为“const”。  
<OL> #include <Vector> #include <iostream>使用命名空间std; void print（const vector <int>＆v）{//您无法编辑v在此功能中int n1 = v.size（）; const int n2 = v.size（）; // v是const，所以它很好地声明它的大小变量为const n1--; cout <<错误的大小<< n1 << \ n; cout <<正确尺寸<< n2 << \ n </ ol>  
<li> #include <vector> </ li>  
<li> #include <iostream> </ li>  
使用命名空间std; </ Li>  
<li> </ li>  
<li> void print（const vector <int>＆v）{//在此函数中无法编辑v </ li>  
<li> int n1 = v.size（）; </ Li>  
<li> const int n2 = v.size（）; // v是const，因此将其大小变量声明为const </ li>是好的  
<li> n1--; </ Li>  
<li> </ li>  
<li> cout <<错误的大小<< n1 << \ n; </ Li>  
<li> cout <<正确尺寸<< n2 << \ n </ li>  
在C和C ++ Const中的手段在此范围内不会修改此操作。它与恒定值无关。  
如果您检查后账户余额，那么您所需的金额不应该可修改。在这种情况下，银行账户数据被保护为“const”。  
<OL> #include <Vector> #include <iostream>使用命名空间std; void print（const vector <int>＆v）{//您无法编辑v在此功能中int n1 = v.size（）; const int n2 = v.size（）; // v是const，所以它很好地声明它的大小变量为const n1--; cout <<错误的大小<< n1 << \ n; cout <<正确尺寸<< n2 << \ n; } </ OL>  
<li> #include <vector> </ li>  
<li> #include <iostream> </ li>  
使用命名空间std; </ Li>  
<li> </ li>  
<li> void print（const vector <int>＆v）{//在此函数中无法编辑v </ li>  
<li> int n1 = v.size（）; </ Li>  
<li> const int n2 = v.size（）; // v是const，因此将其大小变量声明为const </ li>是好的  
<li> n1--; </ Li>  
<li> </ li>  
<li> cout <<错误的大小<< n1 << \ n; </ Li>  
<li> cout <<正确尺寸<< n2 << \ n; </ Li>  
<li>} </ li>  
### 回答 9
很多答案，但只有Ken Gregg [https://www.quora.com/profile/ken-gregg]才到目前为止。但让我们从一开始就开始。  
不可动提器[https://en.m.wikipedia.org/wiki/immutable_object]是阻止其值覆盖的变量的功能。为什么在编程中如此重要？  
当软件维持到长期意外的变化，在其所谓的不改变时对变量值可能对程序具有灾难性后果...  
### 回答 10
您可以拍摄Const-Pervied对象的地址。这些物体也可以在常量不能的程度上进行打印。  
在C ++中，Const-Cormized对象可用作Const-yessions，阵列大小，枚举器值和案例标签。  
### 回答 11
它告诉编译器标记尝试修改Const-Pervied对象的任何代码。  
如果您派上易于编写一个将指针作为参数的函数，但您不希望修改指向对象 - 例如，如果您有一个函数，则为某些东西搜索某些东西，您可以't希望您的功能意外修改数组的内容，例如  
<ol> bool查找（const int * arr，size_t size，int val）{...} </ ol>  
<li> bool查找（const int * arr，size_t size，int val）</ li>  
<li> {</ li>  
<li> ... </ li>  
<li>} </ li>  
Const限定符意味着编译器将发出诊断，如果查找尝试写入* arr或arr [i]。它还告诉任何人使用该功能  
它告诉编译器标记尝试修改Const-Pervied对象的任何代码。  
如果您派上易于编写一个将指针作为参数的函数，但您不希望修改指向对象 - 例如，如果您有一个函数，则为某些东西搜索某些东西，您可以't希望您的功能意外修改数组的内容，例如  
<ol> bool查找（const int * arr，size_t size，int val）{...} </ ol>  
<li> bool查找（const int * arr，size_t size，int val）</ li>  
<li> {</ li>  
<li> ... </ li>  
<li>} </ li>  
Const限定符意味着编译器将发出诊断，如果查找尝试写入* arr或arr [i]。它还告诉任何人使用它不会尝试修改输入数组的函数。  
许多字符串库都像Strchr或strcmp函数uld char *参数一样，这是确切原因的。  
### 回答 12
对我来说，它是单个命名变量的有用值的浓度。希望，一个非常可识别和描述性的名字。读取具有变量名称的代码是更容易理解的，例如， max_files，只是看到坐在那里的一些数字，并不完全明白这一价值的实际手段。如果您对编程相当新的编程，很容易认为真实的世界发展过程是大量的团队合作，这意味着您更常常不适用于代码您没有创建的代码。可读性是一个重要的礼貌。我甚至可能会回到一些代码我几年后写回来，如果我看到在某些算法中使用的硬编码值我可能不记得它代表了什么。  
当您可能希望在必要时更改可能重要的价值数量/定义所以它可能是更改值的众多工作所代表的任何工作。在更改后，将更容易找到该变量的所有位置，以验证新值不会破坏某些东西作为副作用。  
所以......可读性，即时理解和规划未来的变化，以便他们更简单，更快，全面。所有人都在我的书中获胜，我很确定它真的不涵盖使用const的所有好处。  
### 回答 13
*****旧放屁警告****  
恕我直言，是什么让C ++难以使用的一切都与它现在大约有十几种不同的语言填充到单个包装器的语言，每个人都针对不同的应用技术和/或效率，安全之间的权衡，和特色。在实践中，这意味着，当您在遇到遇到的术语时，您在遇到之前从未听过的术语是非常常见的，因为它们是在您偶然发现的语言的不同分支中，并且谷歌以来的错误消息令人惊讶地困难解释很少是不言自我解释的 - 你需要喝醉了相应的kool  - 援助来弄清楚你所做的（而不是你认为你所做的事情）以及如何解决它。  
这是与大多数流行的软件发生的事情，但开放来源允许真正的英雄藤壶数，以将自己附加到您正在寻求使用的有用功能。如果你真的需要1000个以上页来描述你的实现语言，那么我已经做错了......  
****老屁警告 - 祝你有美好的一天！ ****  
### 回答 14
也许你应该在C ++上读取Linus Torvald的诽谤，以及为什么它不用于Git或Linux内核。或者看看今天的热点，如python。Python解释器代码中没有C ++，只有C.在Scipy中我们确实有一些C ++，但按优先顺序是最不期望的语言;我们宁愿在Python或C中保留事物。这不是巧合。  
### 回答 15
你认为这个Java代码：  
<ol>公共类HelloWorld {公共静态void main（String [] args）{system.out.println（hello world）; }} </ OL>  
<li>公共类HelloWorld {</ li>  
<li>公共静态void main（String [] args）{</ li>  
<li> system.out.println（你好世界）; </ Li>  
<li>} </ li>  
更容易向初学者解释而不是执行同样的事情吗？ ：  
<ol> #include <stdio.h> int main（int argc，char * argv []）{puts（hello world）;返回0; } </ OL>  
<li> #include <stdio.h> </ li>  
<li> </ li>  
<li> int main（int argc，char * argv []）</ li>  
<li> {</ li>  
<li> Puts（Hello World）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
Java代码包含许多唯一概念，初学者只需要了解物品的工作原理。类，类访问级别，静态方法，字符串数组，方法访问级别，静态属性等是复杂的概念。相同程序的C版本非常漂亮  
你认为这个Java代码：  
<ol>公共类HelloWorld {公共静态void main（String [] args）{system.out.println（hello world）; }} </ OL>  
<li>公共类HelloWorld {</ li>  
<li>公共静态void main（String [] args）{</ li>  
<li> system.out.println（你好世界）; </ Li>  
<li>} </ li>  
更容易向初学者解释而不是执行同样的事情吗？ ：  
<ol> #include <stdio.h> int main（int argc，char * argv []）{puts（hello world）;返回0; } </ OL>  
<li> #include <stdio.h> </ li>  
<li> </ li>  
<li> int main（int argc，char * argv []）</ li>  
<li> {</ li>  
<li> Puts（Hello World）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
Java代码包含许多唯一概念，初学者只需要了解物品的工作原理。类，类访问级别，静态方法，字符串数组，方法访问级别，静态属性等是复杂的概念。相同程序的C版本非常简单。  
无论如何，由于几个因素，我考虑C和C ++更好的选择，开始学习代码：  
关于C和C ++ Dying的想法只是天真。孩子们认为，在最可爱的技术上撰写为手机或漂亮的微服务是世界需要的一切。可能是我们大多数人所需要的一切，但如果发生这种情况，它是因为在那些令人难以置信的框架和更高级别语言的背后，存在一个复杂而美丽的基础设施（通常用C和C ++写）抽象出来的所有东西他们认为他们没有其他任何东西要担心他们的应用程序工作。  
### 回答 16
C有丰富而持续的文化。可以编写90％的C中写入的项目  
如果C ++可以做到所有内容，甚至更多，为什么C仍在使用？  
这将是一个不受欢迎的答案，但答案是文化。  
人类不是完全客观的法官。这并不是说C ++客观地比C更好，也不能说C ++可以做到所有C能力。后者通过方式不真实。现代c有许多特征C ++没有，但现代C粉丝也将经常无法指出这些功能的特征，尽管令人挑剔的态度是更好的。  
C有丰富而持续的文化。在C ++中可以轻松地写入C ++的90％，尽管C粉丝将索赔，C ++的重量较重，较慢或更少能够在OS和ES中使用。 C ++解决方案实现通常具有比C解决方案实现更快的运行时配置文件。一个C ++程序最终可以在模板滥用时最终有一个值得注意的编译时间和非零融合量，但是模板从膨胀的任何严重关注点都有很长的路要走，而不是那个二元尺寸是更大的优先于绝大多数情况的速度，但在利基案例中，二元尺寸对KB的水平绝对重要，您可以简单选择不使用模板。问题解决了。  
C ++的最大问题以及为什么C仍然如此经常使用，即C ++是一种大规模的语言，具有许多提示，工具和技巧，以掌握一个人的自我掌握，并且有一个同样大量的C开发人员才能更好或者更糟糕的是不愿意，无法做出这么大的努力投资。  
抛弃，管理C ++编译器的复杂性像PIC板一样，你几乎没有我们的现状：很多C ++开发人员，喜欢他们的大量（经常超大）工具集，以及很多C的开发人员宁愿将C ++责怪为语言，而不是接受C ++是一种能够在所有相同空间中工作的完全精细的语言，但最终是一种他们没有时间投资的语言。  
### 回答 17
指针的名称是存储地址的变量的名称。并且指针指针的变量在那里是一个棘手的。该变量存储在内存中，指针点和它隐藏在指针下方。它更接近金属。这就是为什么它被认为是较低的水平。指定第一个修饰符：const dimentype * pointer_name;您指定较低级别的常量。它与指针指针_Name点的变量有关。当您指定更高级别的const; someype * const pointer_name;您为指向Pointer_name本身指定指向指针的常量。您可能会更改目标变量，但您无法更改Pointer_name中存储的地址。  
### 回答 18
这是一个很好的问题，以说明初学者只是复杂的软件get.imagine：  
你刚刚在你的梦想公司工作，几乎没有通过了面试。这家公司很大，让我们说这是Apple.your第一天在编码上工作，你被要求实现一个解决方案来筛选出现垃圾数据在日志中你想要有效地做到这一点，你知道你的经理保持密切关注你，以确保你可以跟上球队。你读了代码，看看你需要做的一切实施解决方案是在源代码中更改一些不知情的命名，看似无用的变量。您更改变量，所有测试通证和您的实现看起来很好。一个月后，一个不同国家的服务器集群失去电源关闭，导致系统重新启动。对于某种原因，当服务器重新启动时，无法找到崩溃之前的数据。您更改的变量实际上应该用于帮助使用崩溃日志来帮助找到数据没有标准的英语字母数字洛杉矶nguares.no奇迹在ASCII的日志中有垃圾数据（标准英文）构建.Since变量已更改，服务器无法恢复数据。费用苹果公司300万美元兑赛季普通街估计恐慌导致苹果股票价值下降3％，这与公司价值约为300亿美元。当然我们作为读者知道是什么造成的错误，但谁知道在Apple找到原因之前多久了？希望没有服务器此前之前。其他开发人员应该让它变得更加清晰，变量非常重要。为什么他们没有发表评论，说//不要改变  
他们可能就像你一样，只是试图用快速实现给团队留下深刻的印象。它工作了，测试通过了，实现是坚实的。像你的那样。开发人员之间的信息不断丢失。不断地失去。 .sometsimes你正在研究由实习生编写的代码，他们甚至不知道英语。你永远不会知道。这些问题是软件中的真实性，大多数预见的设计语言都在这些问题.bugs是更容易预防和修复人类错误。软件充满了错误，人类错误和大量的奇怪的组合2.要诚实，我的例子根本不是很现实，因为任何大公司，尤其是苹果公司都是方式更多的工具和检查到位，以防止这些错误，否则这种类型的灾难将在他们的范围内每小时多次发生。这些错误和噱头经常发生。苹果公司的高管和任何人都知道它不能预期它的开发人员可以理解Codebase.so的所有突出性，以回答你的问题，这是为了防止人们改变不应该改变的事情，即使乍一看你认为他们应该知道他们应该知道无论如何都要减少怪异事故可能导致变量发生变化的可能性，如服务器的时钟变得不同步和更改系统堆栈上的错误数据。在我的经​​验中，通常用于设置一个配置定义的范围。我只是想到了一个非常相似的最近榜样，我帮助我的室内生解决了他的公司在升级到rails 5.a全局变量已经设置为false，而没有改变文件一年来升级铁轨，构建破坏了，除非你将它改为真实。问题是，公司的没有人知道的变量是什么。这个公司是Ruby / Rails社区和CodeBase的主要贡献者S，所以你可以想象他们非常陷入困境。事后我没有听说过这件事，因为*敲门*  
编辑：这是一个真正陷入困境的东西。关于iPhone的初学者，这是一个iPhone ......它似乎没有理由每6个月冻结/崩溃一次？可能更多，也许少？我猜平均是3个月，但我们会猜为他们提供疑问的好处，以便为数学简单起见.Llet每年发出一次，使其简单。据估计，在全球范围内估计有2.28亿iPhone。如果一只iPhone平均崩溃一次，这意味着26,000名苹果客户无缘无故地遇到每小时崩溃。  
### 回答 19
 -  C ++的肤浅相似性  
这是一个复杂的事情，结合了：事实，过时的事实，神话，并根深蒂固的未经证实的信念。在这里，它会：  
事实：  
 - 比C ++更容易学习。一个好的Java或Python程序员将有一些问题，C指针和缺乏课程，但将在一个月或两个月内完成熟练。这是一些雇主愿意投资的事情在对比中，在C ++中可以花费一年时间才能获得合理的水平;不是专家水平，只是为了合理的水平。这是获得新人才的巨大缺点，与C相比。  
 -  C ++到C的肤浅相似性导致了很多问题。最多的C ++实践与C和Java最佳实践完全不同。所以熟练的C程序员倾向于效率地编写C ++代码：努力，可读性，错误和运行时速度。（更正原始）指针，手动管理资源，使用宏（RESEATE C Oferation）通过附图而不是通过引用来传递参数，使用宏转到，既不使用Range-for Auto，不正确，不使用过载，还有更多。这些错误是自然为初学者，可以在路上造成很多麻烦.-在C ++中的场景资源管理后面。例如，一个琐碎的std :: string可以在堆上分配内存。这可能会在许多嵌入式系统上造成麻烦堆分配I. Sa Taboo.here是关于此处的方式，但他们需要对分配者的纪律和知识.- C ++中的例外成本。例外 - 支持在CPU方面是免费的，但在CPU方面几乎没有零成本展示info.这在嵌入式系统上会使c ++更有问题.Exceptions可以禁用，但这种复杂性错误处理尤其是构造函数.-大标准C ++库。标准C ++库的对象代码，即使是最小的可执行文件也是如此通常非常大。它是一个实现问题，一些编译器可能能够减少这个尺寸。可以避免避免占用所有这些内存的标准C ++部分（如语言环境和IOStream），但是它不会完全是c ++。 -  Big C ++代码的编译比编译类似的C代码慢  
希望C ++模块将解决此问题（在C ++ 20或C ++ 23中）。但是，编译速度是一个真正的问题，许多智能人员在十年内工作。我希望模块能够成功进入C ++ 20，这将是固定的。在发生这种情况下，有些方法可以通过更智能的软件工程来最大限度地减少这个问题，并且对该主题有许多CPPCON演示文稿.outdated事实：  
C具有比C ++更好的硬件支持。它曾经是如此，十年或两步。甚至是GCC，即在那里的最便携式编译器，是用C ++编写的。这意味着如果GCC可以是系统上的本机编译器然后，C ++可用。如果gcc可以交叉编译，那么很可能它可以编译system.overall c ++可能就像c，只要编译团队愿意港口港口（可能甚至康复）开发自己的编译器。注意：请注意，正如我在上面的事实部分所写的那样，移植标准库可能是一个问题。这主要是由于其规模，以及它使用堆的使用图书馆是低级别的基元，这可能是端口的。这并不意味着核心语言不如C的便携式较少。  
神话  
引用Linuss仇恨的人忘记了1991年或1992年的某个地方，Linux在G ++而不是GCC.AT中成功编译了那个时候G ++非常糟糕，而且没有比GCC更糟糕的代码。只有那个，它在C ++之前很长standard.atta那个时候，g ++甚至没有一个正确的模板支持.linux内核没有与g ++合作。我猜测许多c程序员被旧的c ++编译器烧毁，形成了他们的意见，然后留下了厌恶.since，可怕的C ++的神话开始传播。实际上，C ++曾经是可怕的。  
### 回答 20
要了解这一点，您将从左右读取声明：  
### 回答 21
它相当不可能，但它可能。  
很多人都不记得这一点，但在个人计算中，帕斯卡尔曾经有C现已的状态。低水平的例程（并且仍然是）在装配中写入，但帕斯卡尔在中间使用，用于复杂的惯例和API。一些第一个微型计算机C编译器具有Pascal关键字，以补偿堆栈约定的差异。在Windows上有遗留。  
C可能是因为函数指针，堆栈蹲和在大多数人知道什么之前使用structs喜欢物体的方法。我的一位朋友，在人们仍然争吵帕斯卡和哥斯说，帕斯卡尔是一个充满蒸馏水的水枪。 C是一个.357的巨大，默认情况下，指向你的头部。你想给学生的哪一个，当一个愤怒的熊在周围时，你想要哪一个？  
重要的是要注意更多现代语言往往涉及消除强大和危险的东西。关于C的危险事物可能会永远留在身边。唯一会摆脱C的东西会像危险，但明显更好，那似乎不太可能。  
### 回答 22
这之间的区别在于范围。一个真正的全局变量具有全局范围，并且在您的程序中可见，即  
<ol> #include <stdio.h> int my_global_var = 0; int main（void）{printf（％d \ n，my_global_var）;返回0; } </ OL>  
<li> #include <stdio.h> </ li>  
<li> int my_global_var = 0; </ Li>  
<li> int </ li>  
<li> main（空白）</ li>  
<li> </ li>  
<li> {</ li>  
<li> printf（％d \ n，my_global_var）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
my_global_var是真正的全局，并且在程序中的所有内容名义上可见，虽然要在其他模块中可见，但您需要一个extern int my_global_var;在其他C文件中，如果您有多文件项目。在程序启动到0时初始化全局变量，无需显式初始化。  
静态变量可以具有本地范围，但不是AlloCa  
这之间的区别在于范围。一个真正的全局变量具有全局范围，并且在您的程序中可见，即  
<ol> #include <stdio.h> int my_global_var = 0; int main（void）{printf（％d \ n，my_global_var）;返回0; } </ OL>  
<li> #include <stdio.h> </ li>  
<li> int my_global_var = 0; </ Li>  
<li> int </ li>  
<li> main（空白）</ li>  
<li> </ li>  
<li> {</ li>  
<li> printf（％d \ n，my_global_var）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
my_global_var是真正的全局，并且在程序中的所有内容名义上可见，虽然要在其他模块中可见，但您需要一个extern int my_global_var;在其他C文件中，如果您有多文件项目。在程序启动到0时初始化全局变量，无需显式初始化。  
静态变量可以具有本地范围，但未在堆栈上分配。它可以具有少于全局范围，虽然 - 如全局变量 - 它驻留在可执行文件的.bss段中（以及与所有BSS变量一样，如果缺乏明确的初始化，则将其初始化为0，虽然我喜欢显式初始化初始化文件以供文档目的）。函数中的静态变量将在函数的调用中保持其值，即  
<ol> #include <stdio.h> int myfunc（int val）{static int my_static_var = 0; my_static_var + = val;返回my_static_var; } int main（void）{int myval; myval = myfunc（1）; printf（第一个呼叫％d \ n，myval）; myval = myfunc（10）; printf（第二个呼叫％d \ n，myval）;返回0; } [代码结束] $ ./a.out第一个拨打1秒拨打11 </ ol>  
<li> #include <stdio.h> </ li>  
<li> int </ li>  
<li> myfunc（int val）</ li>  
<li> {</ li>  
<li> static int my_static_var = 0; </ Li>  
<li> my_static_var + = val; </ Li>  
<li>返回my_static_var; </ Li>  
<li>} </ li>  
<li> int </ li>  
<li> main（空白）</ li>  
<li> {</ li>  
<li> int myval; </ Li>  
<li> printf（第一个呼叫％d \ n，myval）; </ Li>  
<li> myval = myfunc（10）; </ Li>  
<li> printf（第二个呼叫％d \ n，myval）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
<li> [代码结束] </ li>  
<li> </ li>  
<li> $ ./a.out </ li>  
<li>第一个拨打1 </ li>  
<li>第二个呼叫11 </ li>  
请注意，My_static_var中的初始化在MyFunc（）中发生在编译时发生，并且不会在每个功能调用时发生。如果你以前没有看到这个，这可能会令人困惑。  
您还可以具有顶级静态变量。这些都是宣称他们被声明的文件的本地文件，如Dima KoroLev所提到的，因此它们有效地具有文件范围。  
