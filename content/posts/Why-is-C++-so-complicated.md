---

title: 为什么C ++这么复杂？
date: 2022-01-23T22:08:21+08:00

---




## 为什么C ++这么复杂？  
### 回答 1
这里的优秀答案（自然，来自Nathan和Sergey）。  
我会补充一点，C ++可能是今天唯一的主流语言，这并不真正给出遗迹看起来很简单。由于其现有的市场份额和某些铁核 - 忍者 - 宁静的心态和狮子股的狮子份额，其目前形式的C ++并没有有利于最重要的简单性高于更重要的优先事项，例如灵活性和用于代码的经验丰富的读者的可读性。  
因此，合理的，许多经验丰富的专家争论C ++不比Java或C＃或Python或JavaScript更难;他们会引用非常有效的积分。  
不要忘记的重要原因是简单的事实，即连续需求，并且连续地，从字面上归零，对制作C ++一种似乎尚未熟悉努力理解语言的人似乎简单的语言从基础上。  
### 回答 2
这取决于你的意思复杂。而且，我怀疑，在您的编程背景上。  
第一个实现的是C ++基于C，并且有效的C程序将非常接近于有效的C ++程序（类型void *的行为*是一个值得注意的例外。）  
像C，C ++让你非常接近硬件。如果你写的话  
<ol> a = b + c * d; </ OL>  
<li> a = b + c * d; </ Li>  
您几乎可以可视化编译的汇编语言（这是通用的伪代码，但一旦将Opcode助记符转换为该机器的汇编语言，就会在大多数机器上工作）。  
<OL> LOAD C MULT D添加B Store A </ OL>  
<li>负载c </ li>  
<li> mult d </ li>  
<li>加b </ li>  
<li>存储一个</ li>  
然而C ++给你一个l  
这取决于你的意思复杂。而且，我怀疑，在您的编程背景上。  
第一个实现的是C ++基于C，并且有效的C程序将非常接近于有效的C ++程序（类型void *的行为*是一个值得注意的例外。）  
像C，C ++让你非常接近硬件。如果你写的话  
<ol> a = b + c * d; </ OL>  
<li> a = b + c * d; </ Li>  
您几乎可以可视化编译的汇编语言（这是通用的伪代码，但一旦将Opcode助记符转换为该机器的汇编语言，就会在大多数机器上工作）。  
<OL> LOAD C MULT D添加B Store A </ OL>  
<li>负载c </ li>  
<li> mult d </ li>  
<li>加b </ li>  
<li>存储一个</ li>  
然而，如果您想使用它，C ++会给您提供大量电源。标准模板库为您提供了java.util中的集合界面的大部分功能。  
并且输入/输出库比Java.IO更容易使用，并且比C中的STDIO LIBRARY更简单（和更少错误）。  
使C ++比其他面向对象的语言更困难的事情之一是内存在您的控件下。如果要分配一些内存（直接通过Malloc（）或 - 更有可能 - 通过新的运算符，您必须记得在您完成时删除它，或者您将耗尽内存。OTOH，如果删除这个对象太快，你可以留下悬空的指针，那点进入内存池，通常具有灾难性的结果。  
但是这有两个好处：  
### 回答 3
C ++复杂性源于三种非常不同的来源。  
首先，您拥有C ++设计理念的基本原则：您从不支付您不使用的费用。  
这意味着，在每种情况下，如果需要，在每种情况下，默认行为都应避免非明显的隐藏成本，并且如果需要，应避免这种明显的隐藏成本（为调用析构函数和转换算子等提供C程序员的内容）。运行时惩罚的事情是刻意的，以促进（像通过价值这样的方式删除的东西，这在下一步的第二个复杂来源下落下），这意味着一些用于程序员的构造，但是在C ++中，其他语言的程序将难以利用或彻底无法使用。  
其次，您有一个伴随兼容性的遗留性，都与早期版本的C ++和C.其中一些是C ++中高度不幸的构造的来源。 C型包括一个难板，直到模块使其进入C ++，陷入了后果。预处理器宏观不幸的是不受约束并且能够污染可怕的污染。这也是一个不幸的遗产，不能陷入困境。遗产延伸到世界各地的Codebases仍然普遍存在的过时成语。 C ++不是一种年轻语言，以及早期的遗产，当知情课程毕业时，从未完全消失。  
第三，您有一个发现的偶然和不幸的发现，最初用于提出CS预处理器宏的模板语言是在编译时执行的特定功能语言。因为这不是它的设计目的（与日语不同的语言不同，或者正在为生锈开发的语言）语法是复杂的，并且经常笨重。尽可能多地改善了这一点，旧语法仍然存在 - 第二点再次 - 虽然它可能不是成语优选的方法，但如果您可以处理模板元编程 - 并且只有库开发人员应该真正处理这一层 - 你需要知道旧的东西只是为了阅读遗留代码，你将不可避免地绊倒。  
作为奖励第四，C ++标准库是精益的，并添加到它是一个保守的过程，因此有时您需要在标准库之外用于您需要的内容，这意味着处理您自己的图书馆或第三方风格，质量和复杂性不一致的图书馆。  
### 回答 4
自1999年以来，我是一个C ++软件开发人员。近年来，我对Java，C＃和JavaScript有一些曝光。  
就个人而言，我从来没有理解为什么人们认为C ++很难。我想到了两个原因：  
1）他们认为C ++很难，开始学习其他简单的语言，并发现此后难以学习C ++。  
C ++是我的第一语言，所以我早点掌握了。您不必在C ++中使用所有高级概念。您可以轻松地以任何其他语言轻松地开始编写简单算法。  
2）他们不是工程师，不懂基本的计算机架构。  
我是一个  
自1999年以来，我是一个C ++软件开发人员。近年来，我对Java，C＃和JavaScript有一些曝光。  
就个人而言，我从来没有理解为什么人们认为C ++很难。我想到了两个原因：  
1）他们认为C ++很难，开始学习其他简单的语言，并发现此后难以学习C ++。  
C ++是我的第一语言，所以我早点掌握了。您不必在C ++中使用所有高级概念。您可以轻松地以任何其他语言轻松地开始编写简单算法。  
2）他们不是工程师，不懂基本的计算机架构。  
我是电气工程师，C ++中的一切都对我有意义。 C ++是一种计算机语言，而许多其他语言的设计更像是人类语言。例如，我不明白人们如何对无法控制内存分配和数据结构的语言来满意？他们可能认为有人非常聪明地为他们这样做。但是这是错误的。每次我等待NetBeans开始使用Multicore CPU的超级现代MacBook Pro时，我提醒自己Java可以在一个大型项目上有多慢和低效。  
Java及其克隆，C＃基于OOP概念，一切都是对象。很多人认为这种方法发生了失败。另一方面，C ++不受OOP限制。我认为C ++将持续很长时间。 Java最终将让位于JavaScript，也许去，C＃只要Microsoft所做的那么，但没有什么可以替换C ++。  
有一件事我不喜欢C ++尽管如此 - 链接器。链接器可能是C ++中的那些部分中的一个，因为它的第一版本的C ++变化了很少。首先我必须指定标题文件的路径，然后找到该库并指定此问题也是不方便的。它已经解决了许多ides。  
### 回答 5
你交易简单的控制。  
虽然C ++更难使用，但它可以为您提供对机器资源的绝对控制，如果您是一个好的C ++编码器，通常意味着明显更高的速度：C ++的测试比Java快7倍，而且比PHP快20倍。 ，除非您重新调整Java和PHP编译器和口译员，或运行Java和PHP比平常更好的特殊测试。  
小说，易于使用的编程语言对于简单的用例很好，就像计算机科学课程中的小型实践一样。但是，现实世界应用（人工智能，实时系统，计算愿景，视频名称，专业软件开发，手术系统开发，驾驶员开发等）具有极端要求简单的编程语言无法满足。  
当您尝试开发更难的软件时，您开始发生这种情况。曾经尝试使用.NET制作远程屏幕控制应用程序？除非您激活一个看起来很多C ++的特殊未受保护模式，否则工作太慢了。曾尝试创建需要数百万迭代的重型搜索算法吗？我在一个每个人都使用他们喜欢的语言的课程，我用过C ++;他们的算法花了几分钟，矿山花了不到一秒钟（尽管所有这些都被准确实施）。你认为光环，愤怒的小鸟和其他AAA游戏是简单的语言，如C＃和Swift？再次认为，为什么90％的AAA游戏是用C ++写的（以及优化的比特）的原因。它可笑如何进行生物学相关模拟的一些Python脚本需要数天才能在C（现实生活故事）中需要几个小时时运行（在分布式处理环境中）。并且不要让我开始使用机器学习算法......  
如果语言为您提供所有内存相关的工作，则无法进行这一点，如果需要垃圾清洁剂，如果需要您需要框架或运行时机器来解释它，或者程序在运行之前没有编译成二进制文件。 C ++很难，因为您需要在引擎盖下做其他语言的东西。 C ++很难，因为它类似于机器的说法，不要让人类发言。 C ++很难，因为结果应该易于编译，而不是易于调试/披风。  
它的交易，它用于构建您正在使用的操作系统的编程语言，您现在正在使用的Internet浏览器，手机中的操作系统，您可能使用的桌面办公软件，许多视频游戏您已经购买，当然还有其他编程语言的编译器。当您了解它时，它有效，世界上充满了C ++程序员的雇用。并且它永远不会变得更容易使用，因为这将是针对目前语言的目的。  
### 回答 6
很难努力do.c＃和Java设计了  
在C ++中包含文件，在C＃中使用语句，并在java.similar概念中导入语句。关于java中的最终关键字和静态读取的最终关键字在c＃中与c ++中的const关键字的类似概念。我对谈话感兴趣语言中复杂性的概念可能变成了不必要的障碍，以排除访问有用的资源。它是我的观点，即C ++不复杂，但与Java和C＃的技术复杂程度不同，但是以不同的方式分享.A语言复杂性的简短思考  
轻松难以努力DO.C＃和Java的设计使得当您使用这些语言编写代码时，只要您观察到相应的语法，请检查为null引用，那么您的代码应该正确运行（缺乏逻辑设计漏洞）。在较短的时间内更容易获得C＃和Java的所有权利。这就是为什么我推荐他们为专业环境和人们新的软件开发的人寻求简化的路径创建程序.c ++无法更加复杂，它是在一般情况下简单的方便。有区别。复杂性是什么？复杂性意味着你无法弄清楚一些东西来管理进程的能力，因为操作变量的数量压倒了你的认知能力来解决情况.C ++不符合复杂性的定义，作为一种语言，因为大多数设置了对C ++的结构研究的人可以成功地学习和应用。专家使用术语复杂性来描述C ++，因为这是唯一想到的单词，但他们用错误的Sense.C ++，这种语言无法更加复杂，而且，C ++允许您创建比你无法直观地掌握的更复杂的技术解决方案，如果您不熟悉这种解决方案如何运行。喜欢...在C ++中看模板转换，但如果你没有很好地掌握他们，你不知道你在看什么。缺乏熟悉程度而不是复杂性.perpleity是你知道你所在的地方并且仍然无法弄错的是在Java和C＃中的复手性  
Java 1.0和C＃1.0均比C ++不那么复杂。真正的企业级Java 8.0和C＃6.0每位都是复杂的，作为最复杂的C ++ 14.Starting Out，学习1.0样式Java（来自20世纪90年代）和C＃（来自2000年代）比开始直接跳转到C ++ 14。从1.0样式仍然在教程中仍然教授的学习曲线以及在企业中使用的Java 8.0和C＃6.0的许多文本书籍比较大得多在过去的10年里，翻译的东西（忘记了所有不同的库）。C ++和Java / C＃的产品差异  
关键区别在于，在java / c＃中，您有一个简单的工具，可以简化一切。在IDE中，从系统命名空间开始使用点表示法，请将您发送到您尝试执行的事情的方式。又称智能代码完成，C ++没有广泛地设计用于智能代码完成，并且在IDE中使用时可能会效益更低。您不能在C ++中的IDE中的主层次结构中的方式与Java和C＃自动编程环境和工具相同的程度。 .java和c＃都旨在将您放在自动编程模式。您按期限键和您可以使用的对象/方法的名称显示在弹出列表中显示.Try编写Java或C＃延长时间，没有错误，没有IDE，他们的真实深度将你拉到另一边，在那里存在C ++ .Function和地址与对象和编程助手  
C ++很难。你不能窗扉打扮它并说它不是很难因为语法。你可以非常熟悉C ++语法，如果你想要的话，在几个月里。你可以写入C ++代码几个月后，一些熟练程度，如果您已经进行了编程语言的经验。语法是您的挑战。您的挑战是您的事实，即您的手指提示的所有功能都没有自动下降。您必须明确地查找C ++标准库标题文件。其他挑战是一切都不是一个对象。您必须使用自己坐在的函数。从C ++继承的是你将从划线旋转的期望。  
### 回答 7
有很多原因，为什么C ++复杂。事实上，C ++为什么是复杂的问题......也很复杂。必须爱情递归。 ;-)  
C ++旧  
这门语言是在1979年开始设计的。设计师缺乏新语言的经验，因此他们没有知道要关注的内容。他们添加了一堆特征，当时可能看起来像一个好主意。  
它已经有几十年来，以便继续生长。  
c ++被卡住了  
在添加后，很难从编程语言中获取功能。数百万线代码取决于它们。  
C ++很受欢迎  
popul.  
有很多原因，为什么C ++复杂。事实上，C ++为什么是复杂的问题......也很复杂。必须爱情递归。 ;-)  
C ++旧  
这门语言是在1979年开始设计的。设计师缺乏新语言的经验，因此他们没有知道要关注的内容。他们添加了一堆特征，当时可能看起来像一个好主意。  
它已经有几十年来，以便继续生长。  
c ++被卡住了  
在添加后，很难从编程语言中获取功能。数百万线代码取决于它们。  
C ++很受欢迎  
人气支持添加新功能和复杂性，因为有很多用例，因为语言的工作总是在许多冲突的需求下进行。随着时间的推移，大多数编程语言变得更加复杂，包括Python，Java等。  
C ++由委员会设计  
它是一种标准化的语言，具有很多人的贡献。他们能够模块化设计并扩展它，这很难让一个人理解这一切。  
C ++没有设计限制  
这被称为特色蠕变，设计人员只是无法抵抗另一种良好的功能，而不会停止考虑整体复杂性。  
C ++演变  
多年来，这么多的设计已经进入了这种语言，即它难以保持一致性。  
C ++没有在程序员上测试其设计  
大多数语言，如原始的C ++，由少数或没有设计体验的人设计。他们不会打扰在实际程序员上测试他们的设计，以确保它有效。他们只是为了尽最大努力，并称之为一天。  
出于不同的方法，请参阅仲裁编程语言。它称为世界上第一个基于证据的编程语言，因为它实际上在部署之前测试了实际用户的语法。 Quorum是2014年发布的学术语言的利基，所以该技术最近是相当的。  
C ++已编译  
编译语言比脚本语言更复杂。它们必须与特定机器的低级功能相对应。  
Python是一种脚本语言，Java在虚拟机上运行。他们可以更简单。  
C ++是强大的  
该语言专为专家而设计，而不是新手。他们更多地关心完成的事情，而不是关于他们的代码多么漂亮。  
C ++是C顶部的kludge  
C ++被设计为与C兼容的源代码，因此它会在其上添加更多功能。  
对于不同的方法来设计基于C语言，请参阅数字火星D.  
D和Java在被设计时都有C ++，所以他们能够避免它的缺陷。  
不要修理它，更换它  
即使你想制作C ++更简单，你也可以。现有源代码太多取决于它。这就是为什么所有竞争对手都试图替换它而不是改善它。  
有关更多示例，请查看如何：  
还有很多。几乎所有现代语言都旨在通过更换它们来改善他们的前辈。  
### 回答 8
你开始了C. C的整点是制作一个小型流线型的语言，该语言只是在实践中证明的特征。这是对PL / 1等语言的反应，其规格耗尽了数千页。小语言不仅更容易学习，它更容易进入多个平台。  
当Bjarne Stroustrup决定在C顶部建立一个完全对象导向的语言时，有三个大的优势。首先，很多人已经知道C.第二，因为C是一种小语言，它适合增加功能。最后C在许多平台上实施，通过建立在C之上，您不仅具有良好，可靠的库的利益，通过交叉编译到C（如早期实现中始终完成）C ++基本上从大门出来的情况下...虽然我可以在那些早期的交叉编译时告诉你，它是谋杀调试。  
结果是天才的工作，尽管我们现在知道它远非完美。这是一种当时人们认为OO语言应该拥有的一切的语言。问题是当世界对OO编程有很多经验时，C ++已经证明具有非常有限的实用程序（操作员重载和多重继承），并且缺少已被证明是方便的其他功能（接口） 。加上计划刚刚越大，而不是过去。结果是，现代眼睛C ++比严格必要的更复杂，并且要求您做重复的工作来解决某些小限制。  
还认为今天智能手机吹走了那个时代的超级计算机;今天的小型嵌入式系统比当天的大钢更强大。 C ++针对的一些系统在单个MHz范围内具有时钟速度，如果RAM，则为数十千字节。即使在处理例行任务中，资源效率也至关重要，并且相应地设计了语言。例如，您自己管理内存，而不是依赖自动垃圾收集，因为RAM是珍贵的。  
但多年来，线性时间表现变得不那么倾向，记忆便宜和丰富，我们与OO有很多真正的经验。这导致语言设计人员专注于通过程序员削减重复的任务，并向他们转向鼓励容易读取程序的实践，例如使用哈希表作为索引和默认方式来索引一切。哈希在当天非常有用，但是当你经常计数千字节以避免记忆疲惫时，你不想使它成为隐含的​​默认值。现在我们不担心如果一个程序使用超过严格需要的数百千字节。  
结果是现代语言感觉更简单使用和学习，尽管在技术上，他们的执行情况更加简单。 CPU执行的操作序列通常比在C或C ++中的类似程序中更详细地更加精细，这就是为什么这些语言仍然存在世界上的原因。您使用的是低级控制和最小对象代码复杂性很重要。  
### 回答 9
其他贡献者未涵盖的东西是C ++以这样的方式演变出来，即每个有效的C程序都是有效的C ++程序。C ++继承了C的疣，加上它必须在它们上构建显着的新功能。  
现在C ++是一个承认的成功，很容易说这种复杂性是不必要的，应该/应该被淘汰。但是在当天回来，程序员可以逐步学习C ++，并逐步构建其代码基础。从C下降的复杂性是C ++成功的关键部分。  
### 回答 10
C ++是其中最多的编程语言之一。它支持多个范例和编程模型。其中一些是从头开始的，有些是在演变的那样添加的。让我们只命名语言支持的一些范式：  
使用OO概念的动态多态性。  
静态多态性使用模板和过载。  
使用Lambdas进行半功能编程。  
程序编程（继承自C）。  
因为语言是如此多样化，它也非常复杂。特别是对于未经专业的程序员。当你有这么多选择来做点什么  
C ++是其中最多的编程语言之一。它支持多个范例和编程模型。其中一些是从头开始的，有些是在演变的那样添加的。让我们只命名语言支持的一些范式：  
使用OO概念的动态多态性。  
静态多态性使用模板和过载。  
使用Lambdas进行半功能编程。  
程序编程（继承自C）。  
因为语言是如此多样化，它也非常复杂。特别是对于未经专业的程序员。当你有这么多选择做某事时，你怎么知道什么是正确的途径？这是经验踢的地方。经验丰富的C ++开发人员知道使用什么以及何时。他们知道如何将不同的范例结合起来获得最佳设计，可以解决多种设计选择和要求。把它们加起来。语言非常复杂。但它会给你完全自由。因此它的支持者。  
### 回答 11
因为C ++永远不会限制程序员思考，并且不会遵循固定的模式，如Java或Go，例如（对不起，我不是故意在这些中嘲笑这些语言，但我只是想说明一些其他语言进行比较使用C ++）C ++为您提供足够的自由来完成您想要的事。你有很多方法来实现一个目标。例如，如果要设计一种销毁地球的方法，您有许多选择。您可以写一个函数：void destroy_the_earth（行星和地球）; / *行星是一个类名。 ParameterPlanet和地球可以通过* /这是面向过程的编程。  
您还可以设计一个名为Planet的类，并设计一个名为Planet_Destructor的类成员函数，就像这样;类行星{public：planet（）=默认值; //省略其他构造的函数...... / *这些是一些其他类成员函数* / void planet_destructor（）; //为植物行星制作的类成员函数...私人：... //一些私有变量}这是面向对象的编程。  
您甚至可以使用模板编程。 （富有的编程和元编程之间存在一些基本差异，但我不想为此问题说毫无关系）您可以在驱动程序中设计一个类模板并将其实例化。现在，您可以添加私有变量，如：std :: shared_ptr（std :: vector <t >> ptr; / *指向一个保存类型的向量是从该类别实例化的任何对象* / void检查（size_t i，const std :: string msg）; / *您必须添加检查功能以确认我不是超出范围* /  
现在你仍然不满意。你肯定这个程序仍然不完美，但你想设计一个辉煌的。您希望将派生类添加到继承类地球上，如：类地球：公共行星{};课程火星：公共行星{}; ...现在你必须添加虚拟类成员函数，你将考虑使用虚拟继承来预防如何每个独立类的歧义。你开始对你的计划感到恶心。最后，面对你的生产，有这么多的错误，种族条件和记忆腐败，你爆发了，哦，哦，sh * t！为什么C ++这么复杂？！  
现在让我们回到问题的重点。 C ++希望满足每个程序员遵循原始编程习惯。您可以选择C ++中的某些特定功能来进行不同的项目。但它要求您掌握C ++的每一个细节，包括C ++语法，图书馆功能的各种使用（STL）等。  
但我认为C ++不应该进一步扩展。对于原始新兵，学习曲线如此突然。 C ++连续地放置补丁以弥补以前的设计缺陷。它的肩膀负担太重。所以放弃一些特征是唯一的方法。  
我非常讨厌语言设计师对用户施加威胁。我喜欢编码，没有限制。而C ++让我有权这样做。希望C ++变得越来越好，而不是我的一厢情愿。  
### 回答 12
C ++教导您如何手动进行优化编译器的工作。它为您提供了大量优化原语，并使您留下了哪一个用于在哪种情况下使用的决定。规则和条件如此复杂，你不能倾斜并享受你的旅程。 C ++文化围绕性能和易用性旋转。它驱使您一直思考代码的所有方面，使您有一种控制怪胎。  
我知道，控制水平是某些领域的祝福，例如低级系统编程和安全关键应用，但仍然是一般编程的矫枉过正。  
### 回答 13
与C相比，C ++并不复杂。与Java，Python和其他高级oops语言相比，它似乎似乎很复杂。由于C ++从C内存分配派生，指针概念似乎更难掌握Java或Python开发人员。为了解决这些问题，C ++引入了智能指针，共享指针等的概念。这个概念在提升方面与线性代数，伪随机数生成，多线程，图像处理，正则表达式等一些其他操作引入了升级以及其他操作单元测试。  
### 回答 14
因为询问的人是一个新手，或者是一个自学的程序员，他们在一个信誉良好的大学上没有采取CS课程，你从那里讲授了许多语言，而是学习了1-2种语言和坚持他们。  
复杂，是的，它可以变得有点复杂。无论如何，它（应该）是一个圆圆形程序员的任何基本培训的一部分。易于学习只是不是设计优先事项，实际的事情是。向后兼容C，您不需要额外费用（仍然很难在嵌入式系统上工作），等等。  
你知道，我做了业余木工，我不去所有的锯都很酷，我知道如何使用锯，但角磨机很复杂，糟透了。为什么这么多人将是程序员如此诅咒判断贸易的工具？  
如果您在腰带下有几十年的行业工作，您可以发出合理的判断何时何时。如果您开始，您需要先学习，您无需判断相关信息。  
### 回答 15
因为，底部到顶部：  
但可能最重要的是，正如维基百科[1]所说的那样，这是一种通用编程语言。它具有必要的面向对象和通用的编程功能，同时还提供低级内存操作的设施。你不需要更多的解释。  
<a> [1] </a>  
我可以说的一件事。有更难的编程语言来学习，但他们中的大多数都是如此，  
脚注  
因为，底部到顶部：  
但可能最重要的是，正如维基百科[1]所说的那样，这是一种通用编程语言。它具有必要的面向对象和通用的编程功能，同时还提供低级内存操作的设施。你不需要更多的解释。  
<a> [1] </a>  
我可以说的一件事。有更难的编程语言来学习，但大多数都是如此，使用五倍令人兴奋的使用。例如，所有功能编程语言都在那里。他们的代码优雅，雄伟，简单而精彩，强大，直接。 C ++就像使用量子领域。有时会发生奇怪的事情，你无法解释。事情可以流行进入和摆脱存在。但是C ++可以非常授权，就像它给你写出宇宙规则的手段。很少有语言可以让你像C ++一样的上帝......）（编辑：IE。为您提供创建宇宙和其中的人，然后让您想要辞掉工作并将这些FSCK互相扼杀众神和种族差异......）  
脚注  
### 回答 16
这是因为C ++是一种尝试将C扩张到外在其性质之外的字段。  
如果你拿一个尸体并试图制作一个活着的人，你就会得到弗兰肯斯坦。  
如果您拍摄C并尝试将其转换为面向对象的语言，则会获得C ++  
### 回答 17
作为程序员，通常，在尝试向问题写出解决方案时，希望为普通社区做出贡献，并且可能会制作一个降压或两个，你很快就会意识到所有已经解决的简单问题都已解决。  
所以下一件事是解决更复杂的问题或提出独特的解决方案，因为没有人想到解决问题。  
无论哪种方式，无论您使用什么语言，它都会变得更加复杂。如果我可以赚100,000美元，每年可以在c中找到10个数字的平均值，你打赌我会这样做，而不是写一个竞争的RDBMS引擎或竞争的操作系统。  
无论哪种方式，C / C ++允许您以更可管理的方式表达此复杂性，而且恕我直言更好，而不是任何其他语言。  
如果您看不到C ++在这方面更简单，那么您尚未受到足够的挑战，以了解语言可以为您做些什么。  
就标准委员会和已经进一步贡献的其他人而言，您可以看到一旦您开始在厨房中添加太多厨师，那么它可能会变得更加复杂。没有不尊重委员会成员。  
请记住，如果它不适用于您，或者如果它会使您尝试解决的内容，请选择不使用功能。此外，如果您在学术环境中学习C / C ++，则可能会专注于传递考试的语言的所有方面。当你开始使用真实世界的设置时，你会发现自己使用较少的cout和更多的printf，甚至认为printf可能在某些设置中危险，然后您将写得更加安全的例程，使其难以犯错误（作为人类）。  
我从解决问题的角度学习了语言，让客户在更少的麻烦中更加可预测。我自己学会了它（在伟大的作者的帮助下），在我写的第一个，第2和第3个等的所有错误中，我写的迭代/版本。  
C ++是一个长期的倡议。如果您不愿意在森林和学习的森林中长期徒步旅行，那么您就不会在正确的光线下看C ++。  
你也可以问同样的踢钢琴或小提琴。  
### 回答 18
我认为复杂性来自C ++给您提供的手柄。您为比较提供的语言列表是用户级别的高度抽象。大多数东西都在图书馆内完成。虽然现在C ++有许多图书馆支持，但它仍然没有那么抽象。此功能的一个优势（是的，对我而言，它是一个特征）是您需要了解库的基础原则，以便在C ++中正确使用它。有效地使用STL并不容易。由C ++提供的手柄可帮助您以高度自定义的方式编写代码，并有助于操纵系统。复杂性的另一个原因来自C ++是一种多范式语言。  
但是，当您设计一个高度复杂和高效的系统时，所有这些复杂性都会支付更好。需要更好的软件（可管理，消耗和强大）的系统，也需要更好的内存和速度管理。  
### 回答 19
它实际上取决于你如何使用它。 C / C ++的复杂部分是您如何使用指针动态管理变量和内存使用的方式，并且它会如何设计数据结构以满足要存储信息的记忆分配的有效代码。 C / C ++主要用于系统编程，即用于创建此类系统，平台，机制，用于其顶部的所有内容，其在没有开销的情况下大大有效地执行。例如，您使用C / C ++创建OS，一个系统将控制OS中的每个输入，访问硬件，处理您的数据和记忆，处理您的软件/应用程序，等等。为了创建这样的系统，该系统将管理所有这些东西，您需要使用变量和指针来管理数据结构来管理CPU执行的存储器使用。这种低级处理应避免超过内存使用率，这对系统不利。为了避免这种开销，您必须构建伟大/有效的算法和设计数据结构，用于管理您的系统，以实现Memories使用，以便它导致高效，快速和低开销系统。  
这是使C / C ++复杂的是什么，您构建了大量高效的算法和数据结构，以管理低开销和快速响应系统的存储器使用。  
### 回答 20
来自经验  
在我谦虚的意见中，C ++本身并不复杂，尽管在使用Java，Python，Ruby甚至JavaScript时，诸如管理依赖项等特征，但在练习中更加困难。  
从新手的角度来看，C ++有很多功能，不值得第一个硬，你想要解决一个非常简单的问题，你不想处理忆膀管理，指针和低水平的东西（除非问题明确涉及这些东西）。因此，作为新手，你找到了冰山，你的问题只是顶部，所以似乎复杂了。  
从经历（以许多语言而是特别的语言而不是C ++）程序员角度来看，C ++只是另一种语言，它实现了很多有用功能的特征，可能会或可能无法帮助您解决特定问题。另一方面，解决实施细节和对C ++项目的语法和工作流程的感觉是距离起点的两个步骤：实际上在语言中写入和读取代码并关注文档！  
### 回答 21
我喜欢C ++。我尊重Bjarne Stroustrop。我喜欢CPP标准团队正在做的事情。与每个其他语言不同，C ++是唯一一致的，后向可靠的语言。甚至Java都没有完全向后倒置。 Python绝对是不是。  
然而，尽管我喜欢这种语言，但我承认这是非常复杂的。 （CPP）。为什么？有很多和许多语法规则，然后是C ++编译器的许多不同版本。因为标准并不详细地详细信息，并且允许某些事情，您发现使用MingW32编译的是什么编译与Visual C ++。甚至与mingw64编译。  
我现在已经用语言编程了3年，仍然是头痛。我下载Windows SDK要使用shlobj.h来使用shbrowseforfolder（）;在我尝试在Minggw32上编译时生成一百万个错误。似乎只支持Visual CPP。  
Visual CPP有一些操作员对该编译器是独一无二的，该编译器使编译COM程序在其他编译器上不可能。有些运算符获取COM对象的UUID。我不得不用Visual CPP制作一个实体并将其链接到My Minggw项目。  
但从sys / stat.h标题中签出struct _stat。我必须通过strict _stat var声明该类型的对象;我不能说_stat var;这是非常奇怪的，我多年的经历没有帮助。  
### 回答 22
就个人而言，我发现难以管理内存并按值和参数使用参数（＆param）。创建并销毁对象时，要理解它是非常困难的。  
### 回答 23
我认为它是最逻辑的语言，我唯一会说的是一点复杂是让自己的char阵列，指针和管理记忆挂起，而不是依赖gc。  
你比C ++更复杂!!😀  
### 回答 24
我认为答案真的很明显。答案是因为你不明白它（C ++）。经验丰富的C ++程序员不会认为是特别困难的。  
### 回答 25
这是因为它如此冗长，与更容易解释的语言不同，因为那个编译的人真的必须做所有事情。  
### 回答 26
当系统增长到它必须处理多种操作的程度时，需要复杂性。  
想象一下你周围的东西：甚至没有进入抽象的比较，只是观察自己的身体;只是考虑一个你身体的单个细胞，你得到了照片。  
简单的系统需要简单的操作;如果您查看汇编语言，指令集并不是那么大，对于简单的CPU，但一旦开始处理更复杂的CPU，集合增长。只需查看x86架构，了解有关在该系列中的第一个CPU中进入的腹胀进入了多少。  
你问题的答案都是一个非常简单的问题（它很复杂，因为它处理复杂的过程和系统，所以你不必，除非你想做一些与默认值不同的东西），而且更多涉及的一组推理背后，包括个人倾向，以获得一些概念，而不是其他概念。  
这超出了语言本身。每种语言都以自己的方式复杂化;但有些人给你一个更简单的方法，减少了系统或过程中所拥有的自由量;虽然其他语言允许您尽可能深，以换取复杂性的增加。  
对于只有语言本身旁边的其他背景，这是正确的。使一台机器非常专注于某些东西，您的界面将是基本的;但是您将在设计阶段锁定在机器中设置的那些选项。使用更复杂的机器，允许您实现不同的操作，并且您将必须学习INS和其中。最后没有解决方法，超出了语言的简单语法。它更像是工程处理的存在问题，因为第1天  
### 回答 27
纠正，它既复杂，也是自残。部分这来自与通用编程（模板）这样的语言的电源和近距离 - 内容，并将所有内容一起工作，添加新功能，而不是破坏旧功能。那些东西一次很难做到一下，C ++真的很棒，这是一个很困难，它有多么难以获得合理的更新，同时在Live Softwaree中广泛使用。  
### 回答 28
我在90年代拍了两个学期的c。  
我以为他们应该称为C基本和基本称为复杂。  
C和C ++很容易，因为它是一种高水平的语言，几乎就像说话或写作你想做的事情一样。  
C和C ++以前相当相似。我检查了我的Borland C ++ 3.1本书，它确认了我记得的是，一个常见的Printf，那就是正确的，C ++没有使用cout。此外，C和C ++使用括号，但是现在当我看到C ++时，使用printf isnt并且使用<<箭头而不是括号  
我不得不说C ++自从我使用它时变得更加困难。 E.  
我在90年代拍了两个学期的c。  
我以为他们应该称为C基本和基本称为复杂。  
C和C ++很容易，因为它是一种高水平的语言，几乎就像说话或写作你想做的事情一样。  
C和C ++以前相当相似。我检查了我的Borland C ++ 3.1本书，它确认了我记得的是，一个常见的Printf，那就是正确的，C ++没有使用cout。此外，C和C ++使用括号，但是现在当我看到C ++时，使用printf isnt并且使用<<箭头而不是括号  
我不得不说C ++自从我使用它时变得更加困难。即使是我的turboc ++和borland c ++编译器也没有cout或<<箭头，所以我不知道为什么或改变。  
回到我的朋友和我是编程的时候，我们为乐趣而且最受吸引力或教导自己，因为C和C ++很容易。我只带了大学课程为结构化的学习氛围。但是我仍然只针对乐趣，同样我知道的是，我知道的是使用C的所有原因是因为我们的BBS软件是用C编写的，我们想修改源代码。  
所以id说，如果c ++就像我看到的一个例子，我在几天前看到了<<和cout，id说它现在的hsrder现在只有90年代，因为我学到了原始的方式，而不是目前的eyy，而且我没有想再次重新学习。  
### 回答 29
因为它是一种无形的语言。它还没有标准化到其标准库中，其他语言具有标准化的常见事物，例如数据库。C ++可以访问指针地址概念，这意味着您可能有2个单独的对象，但它可能共享某些成员字段的存储器。与Java不同，您有强的分离，使得Object1真正拥有其成员字段和Object2拥有自己的成员字段。通过有意识的努力，在C ++中可以进行这种分离。  
### 回答 30
如果您想要一个编程语言要做的是简单的事情，那么它不一定是复杂的。基本并不复杂。但是 - 你能用它做什么？  
你所吸取的越多，你使用它就越多，它的复杂就越少。  
### 回答 31
不是。  
如果您指的是指针的使用情况与引用VS值 - 它就可以更平原。  
例如，在Java中，一切都是指针（几乎）。它只是隐藏着一个漂亮的包裹。  
如果您考虑过，Python通过对象引用的传递比C / C ++中的value / Reference更加复杂的概念。  
无论如何，它只是一种语言。  
### 回答 32
部分是C遗产，需要编制成相当不灵活的机器代码，它预计内存以特定的方式工作。  
之后，用一堆作为标准图书馆完成的东西，并在提升方面是比必要的更复杂。  
C ++没有地址的整个编程领域：异构并行处理，并且粘隙是好的，而不是C ++  -  17的所有复杂性。然而，编译器作家不知道如何做到这一点，所以他们一直在添加他们可以在哪里的复杂性。  
### 回答 33
现在有效的程序没有错了 - 但是  
因为C ++是一个非常糟糕的语言。 C ++是由Bjarne Stroustrup设计的，他当时没有特别语言设计技能。当时与OO概念结婚，似乎是一个好主意，但它真的不是。 C有自己的问题，也是由Dennis Ritchie设计的 - 也没有特别的语言设计技能。 Ritchie真的错过了HLL的角度 - 这是面向问题的制作程序员生产（高效），而不是计算机导向机的制作效率。  
现在没有任何问题进行高效的程序 - 但考虑因素随着时间的推移而变化。算法效率是不同的，更重要。 C由时间的技术非常有限。它的真正时间从那些局限性中继续前进，那个时间的思想试图保护这些有缺陷的语言，好像存在一些优点。  
我和其他人已经广泛写了关于C ++中的缺陷：  
http://ianjoyner.name/c++.html.  
### 回答 34
与C的C ++相比，C ++非常复杂。 C永远不会去。为什么？原因您需要C进行任何类型的编译器。我只关心c，因为它不需要任何翻译。您的源代码将被直接转换为机器语言。  
为什么C ++不是C＃？  
C ++是一种OOP语言。它在不同的操作系统中工作，如Windows，Linux等。但C＃仅支持Microsoft OS。如果你想学习所有时间可用的OOP语言。学习C ++。您可以轻松转换为C＃。  
不要尝试将C ++或C＃与C进行比较。它是完全不同的游戏。没有限制。就像你有一个扎根的Android。你没有任何界限。  
### 回答 35
问：为什么C速度比C ++更快？A：不是。 C ++更快。  
非正式地，每个C程序都是C ++程序，并且Visual C ++，GCC和CLANG中的编译器后端是相同的，因此它很可能是真正等效的程序生成相同的代码，因此以相同的速度运行。  
这意味着每个C-oder-over-c ++基准使用不同的程序，通常将高调的C代码与天真C ++代码进行比较。当C ++也有阵列时，它们将C阵列与C ++向量进行比较。它们比较C堆栈上分配的C alloca（），以c ++新增，它在堆上分配。他们使用C ++分配行为的特殊知识来编写一个基准，其中C跑得更快，比如John Harrop在此线程中执行，当使用相同知识的C ++程序员可以通过限制动态的范围来加速其代码到等效级别。分配变量如下片段所示（注意每个分配周围的额外卷曲括号）。  
<ol> for（int i = 0; i <1000; i ++）{{vector <int> a（1000000）; x + = a [0]; } {vector <int> b（1000000）; x + = b [0]; } ... </ OL>  
<li> for（int i = 0; i <1000; i ++）</ li>  
<li> {</ li>  
<li> {vector <int> a（1000000）; x + = a [0]; </ li>  
<li> {vector <int> b（1000000）; x + = b [0]; </ li>  
<li> ... </ li>  
C restrict关键字是一个异常，在C ++中不可用，这可能会使一些C程序运行得更快。  
因此，剩下的是C ++功能不存在于C ++程序更快。包括内联函数和模板的功能，使中转化优化更加丰硕，更快的算法（std :: sortus与qsort（）），c ++长度+缓冲区字符串与c null终止字符串，c ++异常处理与铲斗之行时尚的返回错误代码相比，毫无疑问，许多人比我不能立即打电话。  
然后我们拥有C ++功能，使得更容易编写最佳代码，如虚拟功能与IF / else if chains或switch语句。使用函数指针，可以从C获取C ++的性能，但仅具有特殊知识。 （我承认，当您不需要它们时，也可以使用虚拟功能，并将C ++程序减慢。）  
回答这个问题的大多数人（包括我到目前为止）不提供证据支持他们的索赔。我钦佩约翰哈罗夫这样做，即使我争取了他的结果。  
### 回答 36
我仍然不时在工作中写下C ++，但在某些时候，我确实从Avid C ++学习者到了只在绝对必要时写下C ++的人的改变。  
我在高中做了一点竞争力的编程，谢谢我幸运的是，在毕业前得到建议，在毕业前没有担心大学入学考试。我一直在使用C ++，但大多只是作为一个更好的C / Pascal，所以我以为我应该了解更多关于为更大项目做好准备的语言。  
我开始阅读更多文章和一些关于C ++的厚书，这给了我一种语言的复杂性的味道，但我发现掌握了这种强大的工具令人兴奋和刺激的挑战。每次我学到了一些新人都不知道的新东西，我都感到聪明，完成了。  
这是直到我从有效的C ++系列中阅读小书籍，这被广泛推荐为必须阅读。我慢慢地来实现我倾向于做的很多事情是默认错误或以某种方式咬人的方式，除非采取额外的护理。我意识到，为了正确地做事，我基本需要始终需要在我脑海中携带那100多个规则。 Stroustrup说，C让自己在脚上轻松射击; C ++让它变得更加困难，但是当你这样做时，让你的整个腿关闭，但是C ++开始感觉像一个装满的霰弹枪总是指着我的脚，我发现了额外的精神负担非常分散注意力。有趣的是，我对C ++的了解越多，我就越不安。这也是当我开始观察声称掌握C ++的人有怀疑的人：他们要么非常聪明，要么没有知道他们在谈论什么（比后者更常见）。  
对于幸运的人，仍然想知道复杂性是什么？，下面是斯科特·梅耶尔的有趣谈话，有效的C ++的作者，可能会给你一个想法。这是来自CPPCON 2017的最近谈话，它向您展示了琐碎的类的简单构造函数时，您面临的复杂性。 C ++的一系列rants常见的答案是读取的答案。  
事实是，我没有劝阻本身的复杂性，但复杂性大多是偶然的：这是复杂的往往不是因为生活从根本上很难，但由于这种语言在其他目标中设计了这种方式，例如，向后兼容性，即使是C代码，它已经制作了C ++成功的语言，但不是一种客观的好语言。  
让事情变得更糟，复杂有时也意味着他们无意识。例如，Stroustrup对模板成分造影的黑色魔法的发现是着名的，这根本不是他愿景的一部分。然而，他决定保留（如果不鼓励）这种黑客的原则的编译方式。因此，C ++ Metaprogramming的力量随着不幸的是，困扰着巨大的深奥和易于错误的语法而具有很少的工具支持。  
我决定与这些困难挣扎并没有真正让我成为一个更好的软件开发人员。编译器不会阻止我做错事或危险的事情，因为它信任我（一个可以证明任何语言设计决定的论据），即使它捕获错误，它通常只闻到了无息错误的页面消息。当我想了解一些图书馆函数的行为时，我学会了试图尝试阅读和理解源代码很可能徒劳（因为谁知道千页语言规范的黑暗角落，它剥削以实现所需的行为），一个心态我只设法搬到其他语言后慢慢改变。  
我决定在生活中有更好的事情要做。  
今天，十年后，我很高兴我没有进入C ++的时间。现在，通过更多的编程经验一般，我开始找到一些更可管理的复杂性，并且规则有点易于记忆。我仍然尽量避免使用C ++，并且当我别无选择时，迫切会谨慎行事。  
### 回答 37
以下是C ++复杂的某种方式：  
我不包括此列表中的内存管理。如果您遵循关于使用智能指针的最佳实践，C ++中的内存管理并不困难。  
### 回答 38
好吧，说C比C ++更好是一点斗争......你可以在C中在C ++中写得完全相同的代码 - 它将编译并以完全相同的速度运行并运行。  
因此，这些场地上的C ++绝对没有缺点。  
然而，C ++是一种可怕的复杂语言 - 即使它到目前为止我最喜欢的语言代码 - 我是第一个同意它太复杂和绝对臃肿的语言。  
其中C ++大约20年前是完美的。  
所以我建议您找到C ++的部分您发现有用的（类，哎呀，更强的打字，一些语法改进，模板） - 和d  
好吧，说C比C ++更好是一点斗争......你可以在C中在C ++中写得完全相同的代码 - 它将编译并以完全相同的速度运行并运行。  
因此，这些场地上的C ++绝对没有缺点。  
然而，C ++是一种可怕的复杂语言 - 即使它到目前为止我最喜欢的语言代码 - 我是第一个同意它太复杂和绝对臃肿的语言。  
其中C ++大约20年前是完美的。  
所以我建议您找到C ++的部分您发现有用的（类，哎呀，更强的打字，一些语法改进，模板） - 并转储您没有找到有用的东西...以及您发现可怕的内容。  
在个人水平 - 工作很大。  
但是，在一个大团队的C ++程序员 - 你在那些想要沉迷于最新的C ++修订的复杂性的人之间，并在大量的书中使用的那些伎俩......以及像我这样的人选择工作的人并忽略那些没有的东西。  
这变得非常困难......一些程序员正在制作其他人无法理解的代码......这是一场灾难。  
对于Linus Torvalds  - 他正在运行一个巨大的项目，达到了数千个贡献者......如果其中一些贡献使用最新的C ++功能，结果将是Linux的主要问题......可能是它的死亡。  
所需要的是卫生间子集 - 大于c的某个，但小于C ++的最近修订。  
谷歌（例如）对其的C ++程序员提供了一组规则，这些规划程序禁止某些构造 - 并限制其他人的使用到他们真正需要的地方。这似乎是一个完全合理的方法。  
所以 - 没有......没有疑问C是比C ++更弱的语言。 C ++显然优越。但是，这里需要纪律。  
我真的希望有人能够在C +  - 一步之上的思想上方C +  - 但是几步比C ++更简单。使C +成为C ++的真正的C + C +。倾倒不必要的杂乱 - 保持清洁和简单。  
（很多人都会强烈对我不同意这一点）  
### 回答 39
当然，一旦你有一个受欢迎的人  
释放Winston Churchill：[在那里进行大量任务] C ++是最糟糕的编程语言，除了从时间尝试的所有其他编程语言。  
C ++的主要缺点是它是复杂的。该死的复杂。无话可逆地复杂。掌握C ++需要数年 - 即使那么你将犯错误（特别是如果您的项目没有限制合理的架构和最佳实践）。这种慢慢改变（特别是核心指南是右方向的一步，但过程仍然很慢。  
当然，一旦你有一个不容易到达的流行物 - 那么会有酸葡萄索赔（无论葡萄是酸的葡萄）。毕竟，我们没有使用C ++，因为它是一个糟糕的语言听起来比我们不使用C ++的要好得多，因为我们懒得了解它（NB：上面的两个借口都是非参数;唯一的真实参数是C ++不是我们特定项目的合适工具，因为......）。  
这是说，一旦你知道C ++，它就会像任何大小的任何项目一样轻松地用作微风。当然，有一个项目，C ++是一个矫枉过正（有时是一个巨大的矫枉过正） - 但对于超越网络前端的严肃的多百万-LOC项目 - 它往往很好。  
至于开发人员的生产力 - 严格的编译时间键入等往往会在（子）项目超过100-500K LOC之外，往往会吹出水中的脚本语言。严格键入的GC收集语言，如Java和C＃，与C ++相同（并且是一个可行的替代方案，用于相当几（子）项目），但随着项目的增长，它们总是处于危险之中跑进了一些奇怪的stw问题（和/或在语义记忆泄漏中）。至于C  - 虽然您当然可以在C中维护大型项目，但C ++恰好对更大的项目更加卑鄙。  
和表现明智的正确写入C ++击败了GC收集的语言和C.当然，我知道C的常见误解，即C比C ++更快 - 但是在相同的抽象级别和正确写入的C ++通常不是这种情况（好的，有拐角案例限制，但它们是很少还是很远）。此外，C ++模板通过C提供了显着的性能改进（它的经典示例是QSORT（） -  VS-STD :: Sort（）），基本上允许保存运行时间接;这对现代CPU特别重要（与R-R运营成本相比，间接成本上涨了100倍）过去30年来）。 BTW，通过添加CONDEXPR和IF CONSTEXPR构造在最近版本的C ++中，进一步扩展了这种优势。此外，我也知道，GC应该比手动malloc（）更快 - 但是对于Malloc（）/ free（）对的15 x64周期中的最近的C ++分配器 - 这些索赔极不可能（以及我们'重新考虑吞吐量而不是延迟，这些索赔可以恰好零用机会）。当然，运行时性能只是考虑的一个因素，但是当情况下，C ++成为顶级竞争者之一。  
总结并再次重新迭代：[有很多任务] C ++是最糟糕的编程语言，除了从时刻尝试的所有其他编程语言。  
### 回答 40
我有兴趣了解这个比较的指比。 C ++是旧学校，即使是最近的整容，那么那些接触到更高层次或更现代语言的人似乎有点难度，但让我告诉你 - 远远差不多。  
<ol>＃导入整数+算法.h @implementation整数（算术） - （id）添加:(整数*）添加{return [self整数] + [self整数] + [添加整数] </ ol>  
<li>＃导入整数+算法.h </ li>  
<li> </ li>  
<li> @implementation整数（算术）</ li>  
<li>  - （ID）添加:(整数*）添加{</ li>  
<li>返回[self整数：[self Integer] + [Addend Integer] </ li>  
我有兴趣了解这个比较的指比。 C ++是旧学校，即使是最近的整容，那么那些接触到更高层次或更现代语言的人似乎有点难度，但让我告诉你 - 远远差不多。  
<ol>＃导入整数+算法.h @implementation整数（算术） - （id）添加:(整数*）添加{return [self整数] + [self整数] + [添加整数]; } </ OL>  
<li>＃导入整数+算法.h </ li>  
<li> </ li>  
<li> @implementation整数（算术）</ li>  
<li>  - （ID）添加:(整数*）添加{</ li>  
<li>返回[self整数：[self整数] + [添加整数]]; </ Li>  
<li>} </ li>  
<OL>将WS-NUM1划分为WS-NUM2。将WS-NUMA除以WS-NUMC剩余WS-REM的WS-NUMA。 </ OL>  
<li>将ws-num1划分为ws-num2。 </ Li>  
<li>将WS-NUMB除以WS-NUMC余量WS-REM的WS-NUMA。 </ Li>  
<ol>（$ l =加入（，<>））=〜s /.* \ n / index（$`，$＆＆）>> = $ [||打印$＆/ ge; </ OL>  
<li>（$ l = join（，<>））=〜s /.* \ n / index（$`，$＆）>> = $ [||打印$＆/ ge; </ Li>  
最后，尽管对其超大的，不断扩大的功能设置并给予了足够的绳索，但足够的绳索射击自己的脚（这是一个非常主题的实际书的标题[1]），C ++仍然是国王系统编程。通过所述功能集提供的灵活性和控制级别恰恰是其用户会错过的是它们切换的内容。任何真正的C ++替代方案都必须通过更正交的设计来提供相同程度的控制 - 但它不能具有较少的重要复杂性。它必须允许对资源的低级控制。  
<a> [1] </a>  
脚注  
### 回答 41
对于记录，我喜欢C ++。它非常强大，有用，在很多方面优雅。我有机会一直在各种各样的项目中使用它。  
也就是说，在我对专业软件开发人员的经验中，各级学生和教师，个人不喜欢C ++编程语言落入以下类别的一个或组合：  
 * C ++是复杂的，因此具有长的学习曲线。很多人开始学习C ++可以迅速......  
### 回答 42
拥有权利的同时也被赋予了重大的责任。 - 本叔叔  
这几乎总结了它。  
但是C ++不是最强大的，甚至不是长射击。最强大的是什么？  
C ++非常强大，因为它非常接近CPU。它使您的代码快速变得非常快，但您必须写入大量代码。使用C ++进行多线程或异步编程是最糟糕的噩梦。很难使用。但今天使用的几乎所有操作系统都是用C ++写的。计算机上几乎所有驱动程序都写于C ++。  
C ++曾经是世界上最流行的语言之一。但就像它一样  
拥有权利的同时也被赋予了重大的责任。 - 本叔叔  
这几乎总结了它。  
但是C ++不是最强大的，甚至不是长射击。最强大的是什么？  
C ++非常强大，因为它非常接近CPU。它使您的代码快速变得非常快，但您必须写入大量代码。使用C ++进行多线程或异步编程是最糟糕的噩梦。很难使用。但今天使用的几乎所有操作系统都是用C ++写的。计算机上几乎所有驱动程序都写于C ++。  
C ++曾经是世界上最流行的语言之一。但就像据说一样，当你看到的只是钉子时，你的所有问题都是用锤子解决的。只有20  -  30年前，几乎所有问题都是指甲。编写的大多数软件不是数据库，金融，游戏或文字处理器。它们是操作系统，BioS，驱动程序以及当您的应用程序运行时，这是当时唯一跑的东西。当您进行单词处理器时，您必须为所有打印机制作驱动程序。人们确实选择了其他人的软件，因为它支持他们的显卡和打印机，你们所有这些都要写作，你自己。  
然后事情发生了变化。 CPU成为多核，今天您可以在1个CPU上有12个核心，但每个核心比早期型号慢速度慢。因此，获得良好的速度，您必须编写多线程代码。这是为什么C ++今天不流行的原因。另一个原因是我们今天的程序员比我们20  -  30年前更多的程序员。人们不会再制造经营系统和司机了解更多。我们正在制作网站，卡路里计数器，星形地图，游戏，谜题，数据库，融资应用只是为了命名几种变体。这些应用程序不必快速运行，因为他们花了99％的时间只是等待来自用户的输入，也因为计算机非常快。您无需从头开始执行C ++程序的步骤。但是你可以。今天有框架，使C ++看起来像正常的编程语言，做正常的应用程序。您可以在不执行单个指针链接列表的情况下写下任何应用程序，也可以进行按位操作，但如果您需要它，则在那里。  
C ++功能强大，因为您可以在任何级别输入它。您可以成为一个完整的初学者，或者您可以成为40年节目体验的Astro物理学家，C ++将完全是您的佼佼者。只有新语言和工具更好地解决您的问题的情况下的情况更少。您的所有问题都不是不再指甲，所以挑选工作的正确或右均线工具。但是，知道这一点，您今天使用的大多数工具制作应用程序和解决方案是在C ++中建立的。  
一个工具不需要受欢迎  
### 回答 43
首先，重要的是要记住它是最多增长的标准图书馆。这只是可用的事情，你可以使用或不使用。  
没有一个简单的原则，导致添加到C ++的新功能。每个功能都填充了特定的需求。要举个示例的虚拟成员函数实际上与设备驱动程序与功能指针表一样类似于C ++之前存在的东西。该技术刚刚逐渐呈现并容易出错。  
如果有特殊的功能，您感觉c ++不需要，您应该问他们为什么是语言。如果他们知道你想要看到的树木，人们更容易同意森林太大了。  
### 回答 44
你更容易掌握什么意思？  
如果您想知道整个语言，语法和库，则C具有更短的标准。需要更少时间了解它的大百分比。  
但是，如果您想要更快地开始执行有用的东西，那么C要求您了解如何实现更多数据结构。使用C您必须知道如何实现和管理动态阵列和/或链接列表。在C ++中，您需要的只是声明和使用STD :: Vector。而不是在C中实现红黑树或AVL，只需使用STD :: Map或STD ::在C ++中设置。最初，您甚至不需要知道如何在C ++中创建堆上的对象。  
因此，如果您想完成复杂的事情，您将能够在C ++中学习如何在C ++中执行它们。  
但是，如果出于某种原因，您想要实现自己的容器，那么有一个很好的机会将在C中花费更少的时间。学习实施通用容器所需的C ++所需的所有相关部分将比学习相当于相当于C.幸运的是，只有很少的程序员需要在C ++中实现容器。  
与C相比，C ++有许多陷阱和优势。由于您将与C ++更早地富有成效。由于陷阱，它将需要更多的时间来学习最佳实践，以便在C ++中制作最快和最安全的代码，而不是将你带到C.移动到C ++比我曾经在C中的成本更高，但它确实如此不带我太久。  
