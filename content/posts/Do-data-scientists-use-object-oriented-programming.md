---

title: 数据科学家是否使用面向对象的编程？
date: 2022-01-23T22:08:03+08:00

---




## 数据科学家是否使用面向对象的编程？  
### 回答 1
在TEC中的大型机器学习码条  
在大多数情况下，没有。  
就像Satvik Beri说，功能规划对于典型的数据科学管道非常有用，而性能比代码可维护性更为重要。数据科学家一般不适用于大型码名。他们编写小脚本和原型。  
然而，大多数数据科学家使用机器学习库，其中许多都大量使用OOP，至少是用Python编写的那些。主要例外是r，这是一种纯粹的功能语言。一个严格在R和SQL工作的数据科学家将永远不会触摸OOP。  
在科技公司的大型机器学习码条中，我怀疑OOP也很普遍，但这些主要由机器学习工程师和数据工程师开发。  
### 回答 2
我避免它喜欢瘟疫。有许多工具可以使用（r，matlab）谢天无常地包含很少的OOP。这是我陷入困境的主要原因之一，直到我的小组在我必须在Python中编程时找到软件工程师。  
### 回答 3
当然，了解OOP的一些概念，但是你  
一般来说，没有。  
如果您正在编写必须快速的机器学习代码，您将使用高度矢量化的代码。您将围绕性能进行大量决策，这些性能不会整齐地对应封装和接口。  
如果您正在编写数据流水线，功能编程更好：您通常正在占用少量输入数据集并产生少量的输出数据集。并行化非常重要。像不可变性和幂的概念会让你的生活更容易。  
当然，了解OOP的一些概念是有用的，但您可能不会使用大部分时间。  
### 回答 4
面向对象的编程具有它的好处。它创建可重复使用的代码，这些代码围绕着良好的理解模式。优点是，一个新的开发人员更容易理解这些模式以工作在现有代码上。它还允许其他项目使用一个项目。从本质上讲，当您正在进行OOP时，您正在构建构建块，然后您正在连接那些构建块。如果您的构建块足够通用，则可以快速创建新的内容。  
OOP的缺点是很难学习，并且需要大量的前期设计。如果您没有Buildics块开始，则必须开始构建这些块。并建造积木很难正确。  
结果是，OOP对于居住多年和年多年的系统非常棒，并且在团队正在构建可以重用彼此的代码的不同应用程序的情况下。  
换句话说，OOP非常适合工厂的商店。想象一下，你有一个玩具厂，一周制作玩具卡车，玩具飞机第二。如果创造了玩具卡车的工厂可以将玩具飞机商店变成过夜，这不会很好。您可以移动机器并调整它们以获得您想要的内容。这基本上是oop的所作所为。构建块，可以在大规模上转移以做新事物。  
数据科学，OTH不是制造业。这是调查。它或多或少就像侦探工作一样。数据科学家有一个谜团来解决：SOEMTHECT，就像我如何预测甜甜圈像甜甜圈一样的人与咖啡有多少人？他们赶紧赶说是什么让人们喜欢甜甜圈。亨克：也许，甜甜圈与咖啡的偏好与客户的职业有关。 （我知道我知道......坏警察笑话）然后，他们试图通过查看数据来测试他们的亨希是真的。如果数据与亨舍匹集，那么他们可以构建使预测的模型。然后他们测试模型以查看它是否准确预测。  
在这种情况下有什么作用的是一堆建筑块，数据科学家可以用来测试他们的猎人。快。数据科学家们又擅长设计那些构建块，但它们擅长使用其他人设计的建筑块来帮助他们回答问题？这些构建块需要设计成在比例下处理大量数据。他们需要快速扭转一些东西。当您发现它不会准确地使预测丢弃时，没有必要给出型号漂亮的OOP结构。无论如何，您将抛弃型号，直到右转型号。  
这就是为什么数据科学家不使用OOP自己;它太耗时了，并从实际做实验中夺走了焦点。它们确实使用使用OOP设计的框架。  
### 回答 5
是的，我愿意。我还使用工厂和策略模式等设计模式。使用OOP允许我的代码可维护。它还使得将项目移动到生产方案。  
例如，查看以下代码，其中我使用出厂模式创建各种动物的实例，然后调用虚拟成员函数make_sound（）：  
<ol> my_list = [] i for i在范围内（10）：my_list.append（make_random_animal（））在my_list中的p：p.make_sound（）</ ol>  
<li> my_list = [] </ li>  
<li>为I系列（10）：</ li>  
<li> my_list.append（make_random_animal（））</ li>  
<li> </ li>  
<li>在my_list中的p：</ li>  
<li> p.make_sound（）</ li>  
我必须不同意一些答案 - 使用OOP不得不冲击性能，就像C ++一样不比C慢。  
### 回答 6
数据科学家经常来自传统计算机科学/软件工程 - 物理，生物学，统计，经济学，电气工程等的背景。  
但最终，他们预计将获得足够数量的编程/软件工程来对其组织和业务来说真正有影响。  
而且，什么是最现代化编程语言和软件工程范式的核心？  
面向对象的编程（OOP）。[https ...  
### 回答 7
A2A：当然，但他们可能不知道他们正在使用它。  
任何时候使用Pandas DataFrame，您都使用熊猫包中创建的对象，而不是原始的python。  
数据科学家是否使用类来创建对象？可能的，但是我认为他们几乎与程序员一样经常做oo。  
这就是为什么，当我教中级Python时，我为学生开发人员，Devops和数据科学教授3种不同的曲目。在开发人员曲目中，我们重点关注OO，而在其他曲目中，我仍然教授OO，但目标是他们的OO知识成为他们可以在他们工作中互动的基础。因此，如果需要，他们可以创建课程，但我的期望是他们可能不会。  
### 回答 8
钍  
是的。最广泛使用的数据科学语言是Python，虽然可以作为程序脚本语言可用，但如果您了解并知道如何应用OOP原则，就会更有意义。  
关键数据科学库，如熊猫，numpy和scikit  - 学习所有依赖于类，方法和属性，而且您应该知道为什么你首先要将回归模型（例如）作为类的实例声明，然后运行拟合方法。  
然而，虽然对OOP的理解很重要，但在避免OOP时，避免OOP的情况有很多情况。  
我得到的印象是，缺乏软件工程技能的数据科学家（但是，定量学位和一些R / SQL知识）最近已经变得更加拥挤，因此最好的差异化因素是转动数据分析的能力进入生产代码。当然，你需要把握OOP，即使你不总是用它。  
### 回答 9
如果要发布Python库或帮助  
有时！  
如果您将制作数据仪表板。用于制作接口的许多框架都基于对象（尽管这变得不那么必要：请签出此Python库，该库利用React：Dash用户指南和文档）  
有时你必须使用预计您编写类的库。 Scikit-Seature和其他ML用于Python的库来铭记。为了做到这一点，您不必深入了解OO原则，但在这些条款中相当舒适的思考肯定是有用的。  
如果要发布Python库，或者使用基于Scentron的开源项目的帮助，您将处理对象。现在，如果要编写自定义异常，则需要编写对象，以及为自定义库提供有用反馈的自定义异常是一个很棒的功能。通过Keras的创建者来看这篇文章，这是一个着名的用户友好的ML库：API的用户体验设计  
有时代码不起作用。即使您大多数以功能性的方式编码，您依赖的某些东西可能会破坏，并且不会显而易见为什么。如果您在Python中，您可能依赖于某些对象。能够阅读OO代码将使您更能让您自己更能够自己修补这些事情。  
您可能会与根据OO代码运行的系统结束。它还使与正在编写OO代码的软件工程师合作更容易。  
您可能会在某些情况下找到oo编程！这一切都有一个主观性的元素。有些人发现对象有助于管理复杂性，其他人发现他们增加了不必要的复杂性。  
就个人而言，我几乎总是用功能性的风格写作。我发现对于我的应用程序，对象在时间/思想/关注方面增加了很多不必要的开销。但它在你的工具上有它的位置！虽然如果你在学习的过程中，除非你对它的压力，否则我不会优先考虑它。  
### 回答 10
OOP可用于抽象偏离复杂性。当我使用它们时，我倾向于手工贝叶斯模型 - 它有助于一直看出所有模型的内部工作。  
在构建模型类之后，我开始在更高的级别工作，测试模型参数以及没有什么。用干净的界面执行此操作更容易。  
### 回答 11
一些统计数据（2017年）：  
以及R和Python的比较：  
### 回答 12
是的，我愿意。当您的特定用例具有很多怪癖和要求时，您必须获得创意。对我来说，我解决了我的问题的方式是重新创建我自己的课程，这些课程模拟了其他包已经做的。  
### 回答 13
将每个数据点映射到沉重和复杂的对象或可能是不合逻辑的（但肯定的）。然而，以单例或参数对象的形式将代码组织到模块中，其中继承层次结构只是一种代码重用和组织的模块的形式，完全没问题，根本不沉重。  
在凝聚力和静态而不是动态的模块可以在不同时间和各种组合中处理数百万数据点，并且在各种组合中，没有这种数据本身必须被包裹为单独的物体。模块可以直接与另一个实现代码模块化，而不是通过拥塞数据对象层次结构来定义逻辑关系。  
虽然普通的Java甚至Python对象本身非常轻，但如果您已经拥有大量的数据数组，则可以确定一个小型对象，以充当指向指向这些阵列的指针/委托，而这些阵列没有包含任何数据的这些阵列所有（只是一个索引到某些阵列），而不是生成可能的数千个和数百万个对象，然后使您的（可能的分层）模块在这些指针上工作。一个富有的指针进入数据阵列，甚至是多个相关数据阵列，或可能是窗口或过滤，将以明确和灵活的方式允许在原始数据集中非常干净和简洁的程序，而不是您的将数据和逻辑放在许多短的寿命的对象中，只是因为OO很酷。这些富有的指针对象可能/应该是不可变的（请参阅持久数据结构），以允许在无状态模块和其层次结构之间安全传递周围这些指针。有些指针可以指向数组，一些临时数据或用户输入，有些人可以从磁盘读取，或者数据库或http  - 但逻辑的模块将是完全重量轻的，从未实例化，从未被实例化，永不摧毁。  
因此，功能/不变（以及逻辑，对于此事项）范例不一定与组织层次结构中的组织过程矛盾，程序/函数模块层次结构不必意味着许多可变对象。主流oo弄错的是，可变和层次结构必须掌握 - 他们没有。作为人类，我们有智能识别，不必使用完全按原始规定的所有可用功能，甚至可以使用它们。参数类型（例如，Java中的泛型，C ++中的模板）可以至少尽可能容易地使用（可变的）数据完全绑定到它们。  
它真的关于多态性和组成，而不是物体 - 这是一个可以对任何东西都意味着什么，而且最复杂的多态性形式没有任何东西没有发现，而不是通常被称为OO语言的，只是主要的结构功能和程序逻辑。  
### 回答 14
为什么？好的，让我给你两个非常简单的例子。这是Python的一个类。<ol>类人：def __init __（self，name，年龄）：self.name = name self.age =年龄</ ol>  
<li>类人：</ li>  
<li> def __init __（self，name，年龄）：</ li>  
<li> self.name = name </ li>  
<li> self.age =年龄</ li>  
现在，如果你构建一个对象  
<ol> person me =人（安东尼奥，33）</ ol>  
<li>人=人（安东尼奥，33）</ li>  
没有什么能阻止我说  
<ol> me.age = 66 </ OL>  
<li> me.age = 66 </ li>  
这避免了整个封装的想法。现在让我们看看你是否有一个C ++类。<ol>类人{public：person（std :: string名称，int年龄）：名称（名称），年龄（年龄）{私人：std :: string名称; int年龄; }; </ OL>  
<li>班级人{</ li>  
<li>公众：</ li>  
<li>人（std :: string名称，int年龄）：名称（姓名），年龄（年龄）{} </ li>  
<li> </ li>  
<li>私人：</ li>  
<li> std :: string名称; </ Li>  
<li> int年龄; </ Li>  
<li>}; </ Li>  
现在，当你构建一个对象时。<ol>人我=人（安东尼奥，33）; </ OL>  
<li>人我=人（安东尼奥，33）; </ Li>  
当你尝试做  
<ol> me.age = 66; </ OL>  
<li> me.age = 66; </ Li>  
编译器将在脸上吐痰  
为什么？好的，让我给你两个非常简单的例子。这是Python的一个类。<ol>类人：def __init __（self，name，年龄）：self.name = name self.age =年龄</ ol>  
<li>类人：</ li>  
<li> def __init __（self，name，年龄）：</ li>  
<li> self.name = name </ li>  
<li> self.age =年龄</ li>  
现在，如果你构建一个对象  
<ol> person me =人（安东尼奥，33）</ ol>  
<li>人=人（安东尼奥，33）</ li>  
没有什么能阻止我说  
<ol> me.age = 66 </ OL>  
<li> me.age = 66 </ li>  
这避免了整个封装的想法。现在让我们看看你是否有一个C ++类。<ol>类人{public：person（std :: string名称，int年龄）：名称（名称），年龄（年龄）{私人：std :: string名称; int年龄; }; </ OL>  
<li>班级人{</ li>  
<li>公众：</ li>  
<li>人（std :: string名称，int年龄）：名称（姓名），年龄（年龄）{} </ li>  
<li> </ li>  
<li>私人：</ li>  
<li> std :: string名称; </ Li>  
<li> int年龄; </ Li>  
<li>}; </ Li>  
现在，当你构建一个对象时。<ol>人我=人（安东尼奥，33）; </ OL>  
<li>人我=人（安东尼奥，33）; </ Li>  
当你尝试做  
<ol> me.age = 66; </ OL>  
<li> me.age = 66; </ Li>  
编译器将在脸上吐出你，告诉你你不能改变类的私有成员。你不应该做。这就是你有什么方法，这就是API的工作，而应该工作。详细信息.Now采取此示例（从doc / html / boost_asio / mefile / phec11 / buffers / profire_counted.cpp  -  1.70.0）中复制/ emply_count.c）：  
<ol> #include <boost / asio.hpp> #include <iostream> #include <memory> #include <utility> #include <vector> #include <ctime>使用boost :: asio :: ip :: tcp; //参考计数的不可修改的缓冲区类.Class shared_const_buffer {public：//从std :: string.explic shared_const_buffer（const std :: string＆data）：data_（new std :: vector <char>（数据.begin（），data.end（）））），buffer_（boost :: asio :: buffer（* data_））{} //实现constbumeSequence要求.typepef boost :: asio :: const_buffer value_type; typedef const boost :: asio :: const_buffer * const_iterator; const boost :: asio :: const_buffer * begin（）const {return＆bucker_; } const boost :: asio :: const_buffer * end（）const {return＆bucker_ + 1;私人：std :: shared_ptr <std :: vector <char>> data_;提升:: asio :: const_buffer buffer_; }; Class Session：public std :: enable_shared_from_this <session> {public：session（tcp :: socket套接字）：socket_（std :: move（套接字））{} void start（）{do_write（）;私人：void do_write（）{std :: time_t now = std ::时间（0）; shared_const_buffer缓冲区（std :: ctime（＆现在））;自动自动（Shared_from_this（））;提升:: asio :: aasync_write（socket_，buffer，[self]（boost :: system :: error_code / * ec * /，std :: size_t / * length * /）{}）; } //用于与客户端通信的套接字。  
### 回答 15
首先，请确保非常了解令人遗憾的编程。您知道您的变量，语句，条件，分支机构，......首先。不要试图在此之前理解对象方向。如果您正在执行C ++，请确保您也知道动态内存分配。您不想混合如何使用如何使用面向对象的功能进行编程。  
接下来，忽略所有的设计和原则。弄清楚是面向对象的编程。查看代码样本，您可能会看到这些关键字。类，对象，方法，公共，私有，新，抽象，虚拟，界面...使用面向对象编程中使用的语法元素。要知道这些元素是否有什么关系。  
去编写代码，写很多，使用这些元素。代码不需要意味着什么。新A（）。B（c）很好，关键是要弄清楚你真的了解这些语法元素如何工作。尝试奇怪的东西，在抽象课上实施抽象方法。在纯接口上实现方法，从多个类继承，具有相同的方法，编译，查看错误，确保您了解编译错误消息。非常喜欢你的妈妈给你买了一块新的玩具，你试着用各种各样的方式摆弄它来弄清楚它是什么。  
在某个点，您应该获取如何使用这些语法元素。尝试构建一些有用的东西，很快就会弄清楚这些结构化元素根本不是必不可少的，你可以在没有使用类的情况下完成程序。或者只是将所有函数放入单个类中，您开始想知道为什么我们制作了这样一个精心结构，以确保代码分散到处都是。  
只有你学习设计和原则部分，您将学习抽象，封装，利斯科夫替代原理，开放的封闭原理，单一损阻原理等...以及这些原则如何帮助使得代码更加组织。通过您所写的大量代码，您可以开始欣赏确保事情齐全的价值。  
在不知道他们是首先的情况下，您无法以面向对象的方式编程。  
在不知道如何实现的情况下，您无法理解原则。  
在您遇到与代码相关的问题违反它们的问题之前，您无法欣赏原则。  
这就是为什么你想在订单中学习它们，如何，为什么。不幸的是，这样做是非常困难的，这也是有多少教科书和课程，叹了口气。  
OOP的一个清晰的困难是它的价值尚不清楚，直到它是巨大的。但要拥有一个巨大的代码库，您可能已经熟练地熟练地编程了它。在这里，我们去了一个学习面向对象编程的另一个原因以及如何先做。  
重估重估，超出简单的容器类（重用很多），大多数类都不重复使用。忘掉它。  
在一天结束时。对象导向不会增加更多的计算能力。所有它都是组织的概念框架。这对几十几行代码无关紧要，但对大型代码基础非常有价值。  
最后一个单词，对象方向不是唯一的答案。请注意，存在其他范例存在。  
