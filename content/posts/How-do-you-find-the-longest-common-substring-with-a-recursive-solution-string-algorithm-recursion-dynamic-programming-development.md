---

title: 您如何找到具有递归解决方案的最长常见的子字符串（字符串，算法，递归，动态编程，开发）？
date: 2022-01-23T22:08:02+08:00

---




## 您如何找到具有递归解决方案的最长常见的子字符串（字符串，算法，递归，动态编程，开发）？  
### 回答 1
最初，阅读这一点以了解解决方案。  
嗯，现在让我们代码递归解决方案（在CPP中）。  
int解决（int i，int j）{  
if（i == n || j == m）返回0;  
if（dp [i] [j]！= -1）返回dp [i] [j];//如果访问此状态  
if（s [i] == t [j]）返回dp [i] [j] =求解（i + 1，j + 1）+ 1;  
返回dp [i] [j] = max（求解（i + 1，j），解决（i，j + 1））;  
}  
如果您对代码有任何疑问，请评论。  
### 回答 2
在回答您的问题之前，为什么要从递归解决方案创建迭代解决方案？时间复杂性？不，它恰恰相同。可怕性？我说递归解决方案在阅读时更有意义。表现？没有太大差异。由于缓存未命中，迭代解决方案可能会更好。但它真的有巨大的差异吗？我不这么认为。或者由于递归导致堆栈空间耗尽？通常不会发生这种情况，除非有人设置了堆栈限制，除非要更少。  
无论如何，回答你的问题。这一切都取决于递归如何创建迭代解决方案。  
如果是1D DP真的很容易。例如，考虑系列F（n）= f（n-1）+ f（n-2）+ ... + f（n-k）f（n）= f（n-1）+ f（n- 2）+ ... + f（n-k）。迭代解决方案可以写作：  
对于i = 1至n：对于j = n-1至n-k：dp [i] + = dp [j] </ ol>，<ol> dp [n]：  
<li> dp [n] </ li>  
<li>对于i = 1至n：</ li>  
<li>对于j = n-1至n-k：</ li>  
<li> dp [i] + = dp [j] </ li>  
根据递归的情况，在2D DP的情况下，事情可能会得到一点猛拉。如果它是类似的（i，j）= f（i-1，j1）+ f（i-1，j2）+ ... f（i-1，jk）f（i，j）= f（i -1，J1）+ F（I-1，J2）+ ... F（I-1，JK），然后我们注意到一行的答案取决于前一行的答案，所以我们填写我们的DP表行 - Wise.Now，考虑像f（i，j）=σ= if（i，k）+ f（k，j）f（i，j）=σk= ijf（i，k）+ f（k j）。在这种情况下，它有点难以实现迭代解决方案。我们需要在这里以对角线方式填充DP表。（思考一下，你应该能够正式化）。  
随着尺寸的增加增加了写作迭代解决方案的难度。有时，可能根本无法编写迭代解决方案。以及为什么甚至在编程竞赛中浪费宝贵的时间，当备忘录的递归时，递归时都是相同的。  
### 回答 3
自上而下方法的问题：  
自上而下方法的好处：  
如何以自上而下方式对自下而上的方法的好处：  
C ++中的示例代码：  
Ubuntu Pastebin.  
### 回答 4
动态编程用于解决多项式时间内的问题，更快的时间更快，然后蛮力方法  
要解决DP问题的任何问题，您可以按照以下步骤操作  
动态编程配有很多练习。必须尝试解决各种经典DP问题以便接触击球。  
有一个快乐的编码:)  
### 回答 5
谢谢你的A2A。  
直接到了这一点，只要你看到你可以解决给定的问题如果你可以解决类似的较小问题，则有递归。  
让我们参加一个很好的例子，因为斐波纳契数，因子，数字列表总和必须都是你的，以及其他人。  
考虑解决众所周知的数独游戏。  
是的，让我们用递归来做。  
从左上角框开始并一次移动每行一列（然后向下到下一行的开始等）。  
假设有效的数字（您只有1-9）的框。现在，  
谢谢你的A2A。  
直接到了这一点，只要你看到你可以解决给定的问题如果你可以解决类似的较小问题，则有递归。  
让我们参加一个很好的例子，因为斐波纳契数，因子，数字列表总和必须都是你的，以及其他人。  
考虑解决众所周知的数独游戏。  
是的，让我们用递归来做。  
从左上角框开始并一次移动每行一列（然后向下到下一行的开始等）。  
假设有效的数字（您只有1-9）的框。现在，如果您可以根据这一假设解决其余难题，您解决了数独谜题。  
这是伪代码：  
<ol>功能solve_sudoku（当前框）如果填充所有框返回true;结束如果填充当前框返回结果：solve_sudoku（下一个框）;结束//假设每个可能的数字的所有9个可能的数字如果该号码有效，则在框中尝试该号码，如果您可以解决困难的其余部分返回true，则在框中尝试该编号;结束结束返回错误; //您无法解决它结束</ ol>  
<li>功能解决_sudoku（当前框）</ li>  
<li>如果填充所有盒子</ li>  
<li>返回true; </ Li>  
<li>如果当前盒子填充</ li>  
<li>退回结果：solve_sudoku（下一个框）; </ Li>  
<li>结束</ li>  
<li> </ li>  
<li> //假设所有9个可能的数字</ li>  
<li>为每个可能的数字从1到9 </ li>  
<li>如果该数字有效</ li>  
<li>在框中尝试该号码</ li>  
<li>如果可以解决困难的其余部分的_sudoku </ li>  
<li>返回true; </ Li>  
<li>返回false; //你无法解决它</ li>  
<li>结束</ li>  
最后一个词：每当可以解决较小的同样难题时，可以递归。  
注意：几乎所有递归问题都可以通过动态编程来解决 - 有些是直观的，有些不是。  
干杯!  
### 回答 6
即使在递归中，我们也将问题划分为其子问题，但我们从顶部开始，即从最大的问题（不同于DP，我们从最小的P.  
动态编程意味着使用子问题的解决方案来计算更大问题的解决方案。我们从最小的问题开始，并努力达到更大的问题。对所有问题的解决方案可以存储在阵列或矩阵中。因此，在计算较大问题的解决方案时，已经计算了所有子问题的解决方案，并且需要再次计算并不需要计算。这是一个自下而上的方法。  
即使在递归中，我们也将问题分为其子问题，但我们从顶部开始，即从最大的问题（不同于DP，我们从最小的问题开始）。这是一种自上而下的方法。  
让我们考虑计算FIB [1] = 0和FIB [2] = 1的NTH FIBONACCI号码的问题。在DP的情况下，从最小的问题开始，从最小的问题开始计算，即FIB [3]并计算FIB [4]，FIB [5]，... FIB [n]。但是，在递归中，我们从FIB启动[N]本身并让递归决定接下来需要的内容。  
现在是重叠子问题的问题。如果递归用于解决具有重叠子问题的问题，那么最终会一遍又一遍地计算相同的东西。就像在Fibonacci示例中一样，FIB [N-2]将计算两次（在计算FIB [N]时以及计算FIB [N-1]）。这将导致指数复杂性。但是，如果我们使用递归的备忘录的特征，那么递归解决方案将工作以及DP One（减去函数调用开销），因为每个子问题的解决方案将仅计算一次。  
因此，在没有重叠的子问题的问题中总结（如在计算n！）递归时与DP相同。但是在存在重叠子标数的问题中，递归+备忘录与DP相同。  
回复您的其他问题：  
DP的想法是使用子问题的解决方案来计算较大问题的解决方案。递归可以被认为是实现这个想法的一种方法。正如我所说的那样，实现DP的思想的另一种方法是使用阵列/矩阵来存储子问题的答案并使用循环来计算矩阵的每个单元格。其中一个单元格将持有所需的答案。  
### 回答 7
[数学] \ [/ math]  
从根本上，动态编程将取决于一些递归结构。然而，您解决的原始问题制定可能不会最初具有递归定义，因此您可能需要自己提出。例如，查看以下问题：  
Minu1，U2，⋯，Un∈Usubjecttoσk= 1nc（英国）σk=1nwkuk≤bminu1，u2，⋯，un∈uσk= 1nc（英国）主题taσk=1nwkuk≤b  
WK≥0WK≥0。这个问题没有显示任何超明显的递归结构。但是，您可以通过定义变量来构造递归结构：  
XJ + 1SJ + 1 =ΣK= 1JC（UK）= XJ + C（UJ）=ΣK= 1JWKUK = SJ + WJUJXJ + 1 =ΣK= 1JC（UK）= XJ + C（UJ）SJ + 1 = σk= 1jwkuk = sj + wjuj  
其中x0 = s0 = 0x0 = s0 = 0。现在，鉴于我们将{UK} {UK}视为一组连续决策，在我们将问题恢复时，可以使用动态编程来解决这种情况  
Minu1，U2，⋯，un∈Usubjecttoxnsn≤bxk+ 1 = xk + c（英国）sk + 1 = sk + wkukx0 = s0 = 0minu1，u2，⋯，un∈xsubjecttosn≤bxk+ 1 = xk + c（英国）SK + 1 = SK + WKUKX0 = S0 = 0  
动态编程很容易处理这个问题结构，特别是如果使用Bellman方程[1]。  
<a> [1] </a>  
我希望使用这个例子，你看到动态编程始终取决于一些递归结构，因为它是如何运作的根本，因为它是关于将问题破坏子问题的问题，但是一个可以从动态编程中受益的问题T总是在开始时处于递归形式。  
脚注  
### 回答 8
给定64位整数，找到龙节  
Anup Buchkes答案涵盖了一些不错的递归和动态编程问题。如果您想练习更多，那么有许多在线评委，如Codechef，其中有很多这样的问题被困难分类。  
对于按位运算符，我推荐我准备好一段时间的资源，虽然回到了一个面试执教团队，我领导：按位运营商练习。它包含5个问题，每个问题都可以在少量不同的效率下解决，每个级别都逐渐越来越难。  
这是我最近遇到的另一个好问题：  
给定64位整数，在其二进制表示中找到连续0的最长运行（不要考虑前导0s）。  
如果nn是整数的值，并且d = lognd =log⁡n是整数的二进制表示中的数字数，  
（更容易）在O（logn）= o（d）o（log⁡n）= o（d）时间内解决。（更难）在O（loglogn）= O（logd）o（log⁡logən）= o（logəd）时间。你还能得到O（1）O（1）空间吗？  
位双击Hacks是位于位运算符上的另一个伟大资源。它是一个着名的页面，你可以从那里获得很多想法。  
我希望这有助于，祝你的学习运气。  
### 回答 9
最长的常见子序列（LCS）是动态编程中的流行问题之一。在LCS中，您必须找到最长的字符串，可以通过从第一序列中删除少量元素以及从第二个序列中删除少量元素来获得同样，对于字符串ABCDEFG： -   
ABC，ABG，BDF，AEG，'ACEFG，..等是它的子序。所以一串长度n有2 ^ n不同可能的子序列。您可以在geeksforgeeks.lets表示您有一个归档两个序列，  
P：ABCBDAB.  
问：BDCABA.  
如果从第一序列删除，a-c-b（abcbdab）和c-a（bdc  
最长的常见子序列（LCS）是动态编程中的流行问题之一。在LCS中，您必须找到最长的字符串，可以通过从第一序列中删除少量元素以及从第二个序列中删除少量元素来获得同样，对于字符串ABCDEFG： -   
ABC，ABG，BDF，AEG，'ACEFG，..等是它的子序。所以一串长度n有2 ^ n不同可能的子序列。您可以在geeksforgeeks.lets表示您有一个归档两个序列，  
P：ABCBDAB.  
问：BDCABA.  
如果从第一个序列中删除，来自第一个序列的A-C-B（ABCBDAB），以及第二个序列的C-A（BDCABA），您将获得两个输入的常见实例：BDAB  
可以从上面序列获得的其他LC是：BCAB和BCBA  
算法：  
考虑输入序列是长度I和j的x [0..i-1]和y [0..j-1]。l（x [0..i-1]，y [0..j -1]）是两个序列X和Y的LC的长度。对于字符串，AGGTAB和GXTXAYB，它们的最后一个字符是匹配的，因此可以使用递归方法导出LC的长度，如下所示：  
L（AGGTAB，GXTXAYB）= 1 + L（AGGTA，GXTXY）  
正如您可以看到上述图像，该方法首先确定右下角的LCS字符，并逐渐向上移动。**如果两个输入字符串中的字符相等，则它们是LCS的一部分。我们考虑打印的字符并且在对角线上移动[I-1] [J-1]  
**如果它们不同，我们朝向左[i-​​1] [j]或[i] [j-1]，这取决于它们中的哪一个具有更高的数字.source：打印最长的常见子序列  
<ol> / *动态编程lcs问题* / #include <iostream> #include <cstring> #include <cstdlib>使用namespace std; / *返回X [0..M-1]，Y [0..N-1] * / void LCS的LCS长度（Char * x，char * y，int m，int n）{int l [m +1] [n + 1]; / *后面的步骤构建底部上升时的L [M + 1] [n + 1]。当L [i] [j]包含x的lcs的长度[0..i-1]和y [0 .. J-1] * / for（int i = 0; i <= m; i ++）{for（int j = 0; j <= n; j ++）{if（i == 0 || j == 0）l [i] [j] = 0;否则if（x [i-1] == y [j-1]）l [i] [j] = l [i-1] [j-1] + 1;否则l [i] [j] = max（l [i-1] [j]，l [i] [j-1]）; }} //以下代码用于打印LCS INT index = l [m] [n]; //创建一个字符数组来存储LCS String Char LCS [索引+ 1]; lcs [index] = 0; //在LCS [] int i = m中，从右下底部最底角和//一个存储终止字符//从右下角的角色和//一个存储字符。而（i> 0 && j> 0）{//如果x []和y中的当前字符是相同的，则//当前字符是LCS（x [I-1] == y [J-1]）的一部分）{LCS [Index-1] = X [I-1]; //在结果中放置当前的角色 - ; J--;指数 - ; //缩小I，J和索引} //的值如果不一样，那么如果（l [i-1] [j]> l [i]） [J-1]）I--;否则J--;打印lcs cout << x <<和<< y <<的lcs是<< LCS的LCS; } / *驱动程序要测试上面的函数* / int main（）{char x [] = aggtab; char y [] = gxtxayb; int m = strlen（x）; int n = strlen（y）; LCS（x，y，m，n）;返回0;输出：AGGTAB和GXTXAYB的LCS是GTAB </ OL>  
<li> / *动态编程LCS问题的实施* / </ li>  
<li> </ li>  
<li> #include <iostream> </ li>  
<li> #include <cstring> </ li>  
<li> #include <cstdlib> </ li>  
使用命名空间std; </ Li>  
<li> </ li>  
<li> / *返回x [0..m-1]，y [0..n-1] * / </ li>的LCS的长度  
<li> void lcs（char * x，char * y，int m，int n）</ li>  
<li> {</ li>  
<li> int l [m + 1] [n + 1]; </ Li>  
<li> </ li>  
<Li> / *以下步骤在下底时构建L [M + 1] [N + 1]。  
### 回答 10
虽然递归可能比采用的相互作用方法更直观（并且可能不那么繁琐），但这不是一个符号正弦值，所以我只推荐够了解它（即：不是真的很强大，就像这个问题  
为了不受欢迎的风险，也可能甚至可以获得一些排名，让我回答不，不是真的，我会进一步争论。  
掌握更多的CS基本概念可能肯定有助于，但本身并不是一个强有力的要求，因为您实际上严格（重点）需要在基本上没有递归，你可能会遇到作为开发者。  
虽然递归可能比采取的相互作用方法更直观（并且可能不那么繁琐），但这不是一个符号正弦值，所以我只推荐理解它（即要求）能够拔出简单的递归Katas，然后用DP尝试，看看是否可以在递归时变得更好。  
希望这有助于，快乐的学习和编码:)  
### 回答 11
递归基本上是一种循环构造，它利用了执行环境提供的资源。在编写递归解决方案时，您应该始终记住以下内容：  
所以话说，对于一个简单的递归解决方案，尝试想象一种使用循环和堆栈的算法。循环上的终止条件是您的基础情况，您可以使用函数调用替换任何PUSH +继续操作。  
作为一般提示，我还建议避免递归中的副作用。例如，如果您需要总函数调用的计数，请不要通过在功能范围之外突变一些封闭的变量来执行。相反，尝试通过深度参数，每次调用该函数时都会添加一个。然后，您可以将其作为函数返回的一部分。请记住，如果您需要从函数返回中获得多件信息，则可以始终通过对象或数组，而不是仅传递一个原始。  
