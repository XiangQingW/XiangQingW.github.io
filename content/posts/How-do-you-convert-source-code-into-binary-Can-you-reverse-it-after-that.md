---

title: 如何将源代码转换为二进制文件？在那之后，你能反转吗？
date: 2022-01-23T22:08:22+08:00

---




## 如何将源代码转换为二进制文件？在那之后，你能反转吗？  
### 回答 1
您运行编译器以生成二进制代码。此过程无损，因此您可以轻松地更改为源文件并再次尝试  
### 回答 2
您使用翻译器将源转换为二进制（目标）。翻译是计算中的一个主要话题。基础是，所有的“图灵完整”语言都具有相同的能力和可以计算的限制。这是计算的最终，超越我们必须具有智能计算机的智能。  
鉴于没有任何语言或计算机可以做的并且没有魔法指导或语言构造，我们可以在理论上从任何东西转化为其他任何东西。这意味着当我们从源转移到目标时，我们应该能够反转它。在实践中，这不是那么简单。  
源程序意味着人类可读。我们将源代码转换为二进制翻译编译器。程序员选择呈现的名称和ID。计算机不关心，所以名称被删除，也许用更加神秘的东西如1美元，2美元（这就是为什么ID中的标志的语言如此糟糕），或者它们被绝对或相对地址所取代（相对地址给出了一个系统灵活性，因为程序未固定到位置）。  
如果我们想逆转翻译，我们已经丢失了有意义的名称，并且机械（程序）翻译将无法恢复。即使是一个读取这样的逆向的人也会发现很难猜测意图是什么。  
现在一些翻译系统可能包括目标中的原始名称，以便像调试和程序转储一样。  
在高级语言之间翻译也难以保存语义，因为它们都有不同的范式。即使他们基于类似的概念，它们仍然难以翻译。我曾经在艾菲尔赛到Java翻译（不是我的想法）上工作过，但结果真的并不令人满意（因为Java没有Mi，也许Java到埃菲尔可能会更容易，但是埃菲尔不允许一些东西的东西像xf：= <value>，它是可怜的oo和打破封装）。  
这就是为什么低级机器具有非常一般但非常小的步骤，以便高级语言可以很容易地转换为二进制。  
### 回答 3
你问的第一个只是编译成二进制（有几个步骤）。  
但第二个不能完成。  
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。  
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。  
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。  
一个简单的程序（非常简单）可能需要数月才能改变  
你问的第一个只是编译成二进制（有几个步骤）。  
但第二个不能完成。  
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。  
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。  
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。  
一个简单的程序（非常简单）可能需要几个月的时间来反转它足以可以理解一个复杂的程序可能不值得，除了核心部分。甚至所以曾经尝试过它必须是某种天才甚至尝试。  
### 回答 4
如果您使用编译编程语言，通常称为编译，则将源代码转换为二进制文件。编译由一个名为Compiler的程序完成。  
较低级别的编程语言通常称为汇编语言，并用汇编语言编写的文本通常由一个名为ASSEmbler的代码处理，该代码产生二进制代码。  
与John Thorton的答案相反，我会说这个过程绝对是破坏性的，即，你不能从二进制获取原始源代码 - 无论如何。这甚至适用于汇编代码。让我通过比喻的比喻来解释这一点。 2 * 3 + 8-0 = 142 * 3 + 8-0 = 14您是否可以根据以下两个事实重新构建原始方程式？  
如果您尝试重新构建原始公式，您最终可以使用：2 * 1 + 26-14 = 142 * 1 + 26-14 = 14。你看到了挑战吗？编译失去了像变量名称（除非您有一些外部/全球可访问的变量），代码逻辑流（因为代码和注册优化，折叠和折叠循环等） - 它基本上挂钩了您的代码。  
所以没有，你无法扭转编译过程。 （除非您具有非常具体的情况和非常简单的未优化代码。）  
### 回答 5
一般而言，您将代码打破到解析树中......例如：  
a = 2 * b + c;  
成为：  
<ol> [=] ------- | | [A] [+] ----------- | | [*] ----- [c] | | [2] [b] </ ol>  
<li> [=] ------- </ li>  
<li> [a] [+] ----------- </ li>  
<li> [*] ----- [c] </ li>  
<li> | | </ Li>  
<li> [2] [b] </ li>  
整个程序成为一个巨大的树木结构的东西。  
所以现在你走过树，在每个步骤中递归地生成机器代码。  
你需要一个作业 - 但是，你需要[a]和别的东西 - 所以你走下树 - 看到你需要一个[+]运算符 - 以及你需要一个[*]和你需要的[2]和[b]。所以，因为我们拥有一切  
一般而言，您将代码打破到解析树中......例如：  
a = 2 * b + c;  
成为：  
<ol> [=] ------- | | [a] [+] ----------- | | [*] ----- [c] | | [2] [b] </ ol>  
<li> [=] ------- </ li>  
<li> [a] [+] ----------- </ li>  
<li> [*] ----- [c] </ li>  
<li> | | </ Li>  
<li> [2] [b] </ li>  
整个程序成为一个巨大的树木结构的东西。  
所以现在你走过树，在每个步骤中递归地生成机器代码。  
你需要一个作业 - 但是，你需要[a]和别的东西 - 所以你走下树 - 看到你需要一个[+]运算符 - 以及你需要一个[*]和你需要的[2]和[b]。因此，由于我们拥有乘法所需的一切 - 我们可以写出一些机器代码：  
<OL> MOV R1,2 MOV R2，B Mult R1，R2 </ OL>  
<li> mov r1,2 </ li>  
<li> mov r2，b </ li>  
<Li> Mult R1，R2 </ Li>  
好的 - 所以现在我们弹出备份一个级别的递归，我们现在知道[+]必须将乘法的结果添加到[d]中，所以我们也许我们写出来  
<OL> MOV R2，C添加R1，R2 </ OL>  
<li> mov r2，c </ li>  
<li>添加R1，R2 </ Li>  
现在我们跳回另一个级别，我们现在知道[=]必须将算术（寄存器R1中）的结果存储到所指向的位置：  
<OL> MOV A，R1 </ OL>  
<li> mov a，r1 </ li>  
......我们已经完成了。  
当然，为了这个答案 - 我已经显示了汇编语言代码而不是机器代码 - 但是编译器可以很容易地生成二进制等效应。  
这是超级简单化 - 一个真正的编译器想要优化代码 - 因此它将重新排列说明以更快地制作措施。  
因此，例如，它可能会在解析树上进行传递，并注意计算2 * B可以通过添加B到自身来更便宜地完成...因为在大多数计算机上，添加比乘法更快。  
所以它会在开始生成机器代码之前重新排列解析树。  
它还必须建立一个称为符号表的东西来记住变量'a'，'b'和'c'的位置，实际上位于内存中 - 以及它们的类型。如果'b'是浮点，并且'c'是整数 - 那么它必须生成额外的代码以在执行添加之前将整数转换为浮点表示。  
### 回答 6
是的。这是一个例子。  
回到20世纪80年代，我是商业计算机游戏Dungeon Master的铅开发商。我很肯定，我是只有两个具有完整原始源代码的人之一。  
游戏批判性和商业化均享有相当大的成功，但是从那以后可以说甚至享有更大的成功。今天有活跃的粉丝网站，原始发布超过25年，而且相当多的独立反向工程实施。人们已经逆转设计了自定义图形压缩，数据文件格式，复杂的复制保护等，但我最近与其他人走出去过其他一切的人联系。  
法国的Christophe Fontanel多年来一直维持非官方地下城大师百科全书，这一直令人生意地逆转完成的全部C和装配源代码，几乎所有它释放的大多数平台上的游戏。他已经追踪了用于编译每个版本的编译器的版本 - 不仅仅是制作编译器，而是它的特定版本。我真的无法对他所做的事情做法，所以我将只是粘贴2015年3月的一部分内容，他给我发了电子邮件。  
我近年来没有发布许多更新，但我仍然花了很多时间在DM上工作，因为我做了一个非常疯狂的事情：我一直在努力全面逆向工程游戏。不要害怕，我不打算将港口释放到新平台，我只是对了解一切有效。我从DM和CSB的ATARI ST版本开始（仅用于CSB的游戏磁盘）。我想充分了解游戏的内心工作，包括狡猾的复制保护。我成功地超出了我的初始期望。我现在拥有自己的源代码，可以编译和生成与您构建的原始版本中的完全相同的可执行代码。好吧，几乎完全是因为我在当时使用的Megamax C编译器的旧版本1.1版本，版本1.2我认为，它在少数情况下产生略微不同的代码。甚至有条件编译指令允许编译任何版本的引擎（从早期的DM 1.0，没有任何版本号为1.2，也是CSB 2.0和2.1）。我在沿68000个装配，atari st硬件，拆卸，解答，编译器，链接器等的方式学到了很多。又一顺便说一下，在研究代码时，我发现了很多剩余的错误:-) （你还提供技术支持吗？）。特别是一个令人讨厌的错误，可以重复对象。即使在CSB 2.1中也没有固定，尽管有可见，但围绕箱子的管理努力！然后我继续使用Amiga 2.x版本（包括游戏演示）。我还有重建源代码，它与Aztec C 3.6a编译器完美地编译所有这些版本。我还没有在Amiga版本3.x上工作。我现在正在PC 3.4版，完成了99％。但是我有一些问题来使代码非常完美，这让我怀疑我使用完全相同的编译器，然后（编译器执行的代码优化而不是原始游戏）。 ATARI上的CSB实用程序磁盘和所有AMIGA 3.x版本（以及其他）使用自定义FTL可执行文件格式。这一切都让我发给我的第一个问题，喜欢问你（可能不是你所期望的问题！）：你还记得什么编译器用于开发各种游戏版本吗？ - 在PC上，我已经使用了涡轮增压++ 1.01，但我不确定你没有使用另一个版本，如Turbo C ++ 3.0，或Borland C ++ 3.0或3.1 .-用于Apple IIG版本的编译器？它是在Macintosh或直接在Apple IIG上开发的吗？ - 使用哪些编译器在Atari St上制作CSB实用程序磁盘？和amiga版本3.x？我怀疑你写了一些转换器来拍摄链接器生成的可执行文件并将其转换为您自己的FTL文件格式吗？我认为他们在Macintosh上编写了交叉，这是真的吗？通过查看汇编代码，似乎并非所有版本都使用相同的编译器。  
它只是展示了狂热的奉献精神可以做到的。  
更新：Christophe Fontanel已发布与他的作品中的联系。  
### 回答 7
因为计算机语言是符号.A编译器将符号转换为code.Take此简短程序：  
main（int argc，char * argv []）{for（i = 0; i <10; i ++）{printf（quora规则！）; }}  
几乎所有的一切都有象征。常量（10和Quora规则！）是数据。用于符号告诉编译器启动使用符号I和常量10的类型循环，以确定何时退出循环何时退出循环。该循环打开和关闭括号符号符号在循环的每个迭代期间执行代码.Printf告诉编译器（因为它不是关键字或接受的语言标点符号）来制作在其他地方定义的子程序调用。编译器实际上输出此文本文件：  
<ol> .file ss.c .section .rodata .lc0：.string quora规则！.text .globl主要.type main，@function main：leal 4（％esp），％Ecx Andl $ -16，％ESP Pushl％ -4（％ECX）PUSPL％EBP MOVL％ESP，％EB​​P Pushl％ECX Subl $ 20，％ESP MOVL $ 0，-8（％EBP）JMP .l2 .l3：movl $ .lc0，（％esp）调用printf addl $ 1，-8（％ebp）.l2：cmpl $ 9，-8（％ebp）jle .l3 addl $ 20，％esp popl％ECX popl％EBP LEAL -4（％ECX），％ESP RET .Size Main，。 -Main。ident gcc：（gnu）4.1.2 20080704（Red Hat 4.1.2-52）.section.note.gnu-stack ,, @ progbits </ ol>  
<li> .file ss.c </ li>  
<li> .section .rodata </ li>  
<li> .lc0：</ li>  
<li> .String Quora规则！</ li>  
<li> .text </ li>  
<li> .globl main </ li>  
<li> .type main，@function </ li>  
<li>主要：</ li>  
<li> Leal 4（eSP），％ECX </ Li>  
<li> Andl $ -16，％esp </ li>  
<Li> Pushl -4（％ECX）</ Li>  
<li> Pushl％EBP </ LI>  
<li> movl％esp，％ebp </ li>  
<Li> Pushl％ECX </ Li>  
<li> subl $ 20，％esp </ li>  
<li> movl $ 0，-8（％ebp）</ li>  
<li> JMP .l2 </ li>  
<li> .l3：</ li>  
<li> movl $ .lc0，（％esp）</ li>  
<li>呼叫printf </ li>  
<li> Addl $ 1，-8（％ebp）</ li>  
<li> .l2：</ li>  
<li> cmpl $ 9，-8（％ebp）</ li>  
<li> jle .l3 </ li>  
<li> addl $ 20，％esp </ li>  
<li> popl％ECX </ Li>  
<li> popl％ebp </ li>  
<Li> Leal -4（％ECX），％ESP </ Li>  
<li> Ret </ Li>  
<li> .size main，main </ li>  
<li>。ident gcc：（gnu）4.1.2 20080704（红帽4.1.2-52）</ li>  
<li> .section .note.gnu-stack ,, @ progbits </ li>  
让我们看看这里的几件事。请注意，Quaroa规则的字符串！在线时出现在顶部（.string）3.在左边是一个标签.lc0，它将在运行中解析为地址Time.Remmember .Now看看Line 17.这是一个JMP指令，它表示将执行移动到.l2，它是第22行的标签.execution将在标签后的第一行移动到第23行。这是一个比较与10-1的Hex为90-1的9-1美元的指令，代码-1中的原始循环不变，因为编译器使用小于或等于。该设置CPU内核内部的一些标志转到下一个指令，该指令是jle jumpor -less-thano-arequal.so如果上一个比较小于或等于10-1（$ 9），它会在第18行上移动到标签.l3.％ebp是寄存器和-8是添加到寄存器的偏移量。该偏移量是存储局部变量的程序堆栈。这意味着我们在C代码中的变量I实际上存在于STA中CK并仅作为堆栈顶部的偏移（8个字节背部）引用（8个字节）。没有引用变量名称，只需将-8添加到寄存器％的值来计算内存中的地址如果我们在源代码中使用了变量名称时间而不是i i over i over i of obp。这只是编译器已转换为地址的符号（它恰好相对于另一个地址）。您看到了第16行这被设置为零，因为我们在for循环中初始化为0。所以我们确实将跳转到标签.l3.at行19 .lc0的地址被移动到寄存器％eSp.recall .lc0是字符串我们想要打印。对printf但printf的调用是链接器的存根。  
### 回答 8
我的童年后我有同样的问题。因为我的懒惰，他们只有在我上大学并学到了几个主题时才得到回答。信息技术简介，Java的编程简介，数字设计，计算机组织和介绍。到微处理器。所以覆盖在260小时内完成的事情可能是困难的;但是，我试试我的最好。假设你知道基本的Java或C并切断了编程部分。我没有将从编译器设计中包含额外的详细信息，我还没有学习.imagine一段代码  
if（a [i]> val）a [i] ++  
即使是一个简单的片段，也可以将其翻译成装配朗格星的东西。（如何？ - 请参阅编译器设计和正则表达式）  
注意：寄存器是一些可以存储信息的内存元素.rx是指注册号码x  
LDR R6，= VALLDR R6，[R6] LDR R0，= AMOV R1，＃3ADD R2，R0，R1LDR R3，[R2] CMP R3，R6BLS SKIPADD R3，R3，＃1LDR R3，[R2] SLIP：SWI 0x11  
逐行解释行.Lines 1,2在r6中加载变量val的地址，然后转到该地址并检索值.we存储R0中的数组的地址，R1.R2中的随机索引3包含地址＆a [3]（希望您熟悉指针）我们将该位置的值加载到R3中，并将其与R6（VAL）中的值进行比较，如果它小于或等于，我们将向标记为跳过的指令。（ BLE）如果没有，它将添加一个到值，并将其存储回来.swi 0x11是结束程序.now拍摄指令，例如，添加r3，r3，＃1  
我们需要将其转换为二进制表示法。我们有32位存储此信息，这就是我们如何进行。图片：来自课堂幻灯片  
我们必须填写空白.Cond  - 代表条件代码。如果要进行指令，则应忽略。当它被忽略时。opcode  - 是要识别指令所做的 - 乘以，添加，减去等.rn rd和操作数2用于存储要使用的寄存器。在指定的添加指令中，我们将如下方式翻译。监控程序 - 没有条件/应始终发生 -  1110opcode  - 添加 -  0100S  -  0忽略了Novern  -  0011RD  -  0011哈希和哈希和操作数2位将表示需要将1添加到它。该任务组装级别语言到机器可读二进制代码是由汇编潜水更深入的。在最低级别，我们使用门实现逻辑功能。他们携带出现简单的操作，或者，不等级，你可以始终找出比特的特定组合被传递为输入。如果我设计一个门来标识指令代表添加，ILL通过位对于Gate  -  0100的操作码。有效输入n和Gate，我需要所有的比特是1.so如果我补充第一个，第三和第四位并传递所有四个位，并且门给我一个输出为1，指令是一个和指令。有杀菌剂，所有组合都可以如此表达，我们可以拥有一组相应的门，解码器和其他电路来执行该任务的标识。但这只是该做什么。要做，通过处理器中生成的控制信号来回答。这是处理器如何看内部：  
PC  - 程序计数器 - 存储所执行的指令的地址* MAR  -  Memory地址寄存器 - 存储Heremdr  -  Memory数据寄存器的任何地址到/从中需要传输数据 - 存储接收/要发送的数据.Y  - 暂时存储其中一个操作数。算术和逻辑单元 - 执行数据/结果的全部操作z，temp临时存储.IR  - 指令寄存器 - 存储当前指令正在处理的rn  - 注册器解冻器  
指令解码器和控制逻辑 - 解释指令意味着什么，并确实被要求做的事情。这就是我们的答案谎言。*我知道它存储了下一个指令的地址，但我简化了它:)  
所以在这里发生了什么？跳过数字设计提供的整个基础，侮辱了解理解工作似乎是至关重要的。（如果有兴趣 - 读取各种国家和有限状态机器）  
有一个时钟产生定时信号。本CO符合整个工作。  
### 回答 9
如果只有分配是您的担忧  
如果它是一个简单的C ++程序，没有大部分外部库，基本上您只需编译程序并链接所需的库。在执行这些内容时，您将获得一个二进制文件（如果是Windows的.exe）可以分发。  
现在，如果它是一个涉及非标准外部库的软件项目，如opencv，qt等，您将不得不与二进制文件一起分发必要的库。例如：假设您已编译了程序和链接的库，如abc.dll，xyz ，dll等。并获得了一个二进制文件程序.eexe（incase windows）。  
您可以分发Program.exe，您必须提供一种用户可以将ABC.DLL或XYZ.dll等安装到必要的目录。  
或简单地将所有DLL和库中的所有DLL和库作为UR Program.exe的所有DLL和库放在同一文件夹中。  
创建安装人员喜欢专业公司。  
现在，最后，如果您希望像其他专业公司一样分发您的软件，请使用安装程序。  
如果是Windows和Visual Studio C ++ IDE我建议，请使用InstallShield Limited Edition创建安装程序程序，这将帮助您创建具有所有许可协议的安装程序等。InstallShield将允许开发人员提供创建桌面快捷方式的选项，等等 。此外，您还可以告诉InstallShield将库复制到适当的目录和Program.exe到指定的目录。最后，它还允许您创建一个卸载程序，该卸载程序可以帮助最终用户轻松卸载软件。  
用户运行安装程序后的最终产品将是桌面中程序的快捷方式，控制面板中的卸载程序以及安装到相应目录的软件。  
在基于Debian的Linux Distrs的情况下  
使用DEB Packer将软件打包到适当的.deb文件中，包含所有必要的配置和依赖项。  
### 回答 10
事实上，那些是C的日子  
我住在新泽西州，距离贝尔实验室曾经找到的地方。在我的街区里，一名老年妇女在50年代末期的婴儿期在其婴儿期间，这是一个老年人。在那些日子里，程序员非常接近硬件指令集。她在球队上写了汇编者！不是福特兰语，或cobol甚至是象征汇编语言。她在原始机器语言程序上工作，使能汇编程序员使用符号指令和地址。想一想。有人必须在那些日子里这样做。  
事实上，这些是计算机控制台有白痴灯的日子，除了他们是因为任何人而是白痴。每个内部寄存器都有一个光线来指示每个位的状态。它还有一个开关来设置每个位+/-。这使您能够一次截然无常地输入指令和数据。它听起来令人讨厌，但这是一个研究实验室，他们处于技术领先地位。它被称为Bootstrap，这是第一个引导到更高级别语言的启动步骤。 （上部照片是Univac，较低的是IBM 360）  
我的第一台PC是TRS 80.我在该机器上学会了大会。汇编程序将打印出我的符号代码和旁边，它将在十六进制中打印装配的结果。将十六进制扩展为二进制文件是一个简单的任务。然后我将拥有不可能长的0s和1s，它们看起来难以置信。在下面的代码中，第二列是十六进制中的机器代码。  
让我们将一个十六进制指令从下面转换为二进制。第一行110170，在二进制中转换为100010000000101110000。 （Windows中的内置计算器有一个程序员视图，它在二进制，十进制，十六进制和八进制中工作。）  
但它是渗透的！反病毒软件分析师做什么？有一个名为逆向工程的软件类别，它采用了exe文件并删除了。它与代码打破真的是同样的工作。回想一下，打破德国谜团的人也是现代计算的先驱之一：Alan Turing。  
我看到了一个雇佣广告一次，用于恶意羊群。他们正在寻找一个对谜题感兴趣的人，脑干扰，模式识别和其他这种追求。图灵将是这份工作的完美候选人。  
有些人看起来像夜间天空一样的图像，完美地理解它。系统程序员可以与二进制代码进行相同的操作。但它确实上班了。  
### 回答 11
（编辑：如果您想要一个快速的glympse关于如何构建Sums二进制数的机器，只需查看在答案结束时链接的视频）  
计算机不是魔法机器，使用一些奇怪的镜际法，当您打开和关闭电压时会发生事情发生。  
计算机最好被视为极其复杂的开关系统，以互相拨动，以便产生一些结果。  
逻辑电路的最基本的构建块是三个不包括的设备，或者  
这些是绘制逻辑电路示意图时这三个家伙的符号：  
（下表显示输入和输出的所有可能组合）  
好的，这是用于构建CPU（以及任何其他类型的二进制逻辑电路的乐高块。  
我不知道是否知道二进制编号系统，但我们正在使用它只是因为数字，只使用仅2位数字表示而不是10，可以轻松用作逻辑电路的输入......例如它相当容易构建执行数字和数量的逻辑电路（使用上述部分）：  
这是一个执行两个4位数字的和的电路（即：它能够将值范围为0到15的两个数字，在我们的十进制符号中）：  
每个矩形都是众所周知的电路，称为完全加法器，总和两个位，也接收来自先前的全加法器的携带位，为以下完整加法器产生携带位。如果要构建两个32位数字的电路（这是大约40亿的数字），您只需通过连接32个完整的加法器来扩展上述布局  
这是完整的加法器电路的样子：  
在电路中，您看到了一个我没有解释的符号，这是NOR运算符：它只是一个或之后不是：只有当其中至少一个输入为1时，它的输出才为0  
现在，我不想说明一个CPU的所有积累（你可以找到那样的书......了解这些书籍是非常可行的：就像使用乐高块一样，你只需要应用你的逻辑思维，你不需要任何科学背景）。我只是想让你在正确的轨道上意识到计算机中没有什么魔法。  
CPU只是安排的复杂电路系统，以便执行存储在存储器中的指令。但是，指令实际上是32位1S和0S的流，其切换CPU的内部电路。  
与乘Carillon播放被编码为旋转鼓上的凸块的音乐一样，CPU执行存储在其存储器中存储的节目。这是漂亮的机械。只是更复杂的方式。  
您应该注意的是，您真的不需要使用电力来构建逻辑电路。您可以使用压缩空气操作的阀门构建3个基本构建块（以及，或不），或者您可以使用机械执行器（杠杆）。在这种情况下，您只需代码0和1，与0V和5V不同，但您也能够使用机械发条机的数字。  
我们正在使用电力，因为这允许建立最快的电路，但在过去的东西中已经设计和构建了：http：//www.computerhistory.org/babbage/  
编辑：在这里，您可以找到一台机器的视频，总和完全由木头和大理石构建的4位整数：  
它是由Matthias Wendel设计和建造的工程师，该工程师对木工具有强烈热情。在这里，YouBcan找到了内部工作的详细说明：二元大理石添加机  
P. S. Matthias Wendel非常精彩......如果你喜欢木工和力学，他的网站展示了大量的巧妙发明。他甚至建造自己的木工机（带锯，桌子，讲座，......）。  
### 回答 12
我刚刚毕业于电脑科学，我做了一些自由职业者，所以这个答案可能并不完全是你所寻找的，但我已经从客户那里听到这个术语。  
据说，如果客户向您展示最可能是一块软件或应用程序的东西，也许是一个网站，也许是客户自己以外的其他人制作的，您将要做的编码符合其实际介绍该软件的编码，网站或应用程序将被称为反向编码。  
复制的软件可能不是精确的复制，但肯定会确保其父母的常见或基本功能。  
