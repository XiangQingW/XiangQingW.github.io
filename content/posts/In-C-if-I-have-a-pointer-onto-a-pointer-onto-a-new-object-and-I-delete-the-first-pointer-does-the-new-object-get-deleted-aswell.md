---

title: 在C ++中，如果我有指向指针的指针进入一个新对象，并且我删除了第一个指针，那么新对象也会被删除吗？
date: 2022-01-23T22:08:14+08:00

---




## 在C ++中，如果我有指向指针的指针进入一个新对象，并且我删除了第一个指针，那么新对象也会被删除吗？  
### 回答 1
看，年轻的大师 - 在现代c ++中，你几乎不要使用原始指针，好吗？你几乎甚至没有写新的或删除了，好吗？我们有分配者和Raii和make_shared和make_unique，它创造了一种指针，但真的很多。  
无论如何 - 我看到答案是教育和有趣的一种，但我看到许多人完全错过了这一点。是的，了解哪些指针以及他们如何工作 - 在你不......  
### 回答 2
让我在前面的指针上消除一堆误解：  
好的，随着这种方式，让我们在最后测试你的理解。最后。问答：  
＃1.在以下代码中删除了多次？<ol> #include <iostream> int * foo（int x）{return new int {x}; } int main（）{int * p; for（int i = 0; i <1000; ++ i）{p = foo（i）; std :: cout << p = << p << << * p = << * p << \ n;删除p; }} </ OL>  
<li> #include <iostream> </ li>  
<li> int * foo（int x）{</ li>  
<li>返回new int {x}; </ Li>  
<li>} </ li>  
<li> </ li>  
<li> int main（）{</ li>  
<li> int * p; </ Li>  
<li> for（int i = 0; i <1000; ++ i）{</ li>  
<li> p = foo（i）; </ Li>  
<li> std :: cout </ li>  
<li> << p = << p << </ li>  
<li> << * p = << * p << \ n; </ Li>  
<li>删除p; </ Li>  
<li>} </ li>  
＃2.Consider此代码：  
<ol> int * pi = new int {42}; int ** ppi =＆pi;删除pi; </ OL>  
<li> int * pi = new int {42}; </ Li>  
<li> int ** ppi =＆pi; </ Li>  
<li>删除pi; </ Li>  
删除pi对ppi做任何事情？＃3.consider这个代码：  
<ol> int i = 42; int * pi =＆i; int ** ppi = new（int *）{pi}; </ OL>  
<li> int i = 42; </ Li>  
<li> int * pi =＆i; </ Li>  
删除ppi对pi做任何事情吗？＃4.consider这个代码：  
<ol> int * pi = new int（42）; int ** ppi = new（int *）{pi}; </ OL>  
<li> int * pi = new int（42）; </ Li>  
<li> int ** ppi = new（int *）{pi}; </ Li>  
两个问题：  
＃4a：删除pi对ppi做任何事情吗？（忽略＃4b）  
＃4b：删除ppi对pi做任何事情吗？（忽略＃4a）  
＃5.Consider此代码：  
<ol> int i = 42; int * pi =＆i; int ** ppi = new（int *）（pi）; std :: cout << ** ppi = << ** ppi << \ n << * pi = << * pi << \ n << i = << i << \ n; ** ppi = 47; std :: cout << ** ppi = << ** ppi << \ n << * pi = << * pi << \ n << i = << i << \ n; * ppi =新int（17）; std :: cout << ** ppi = << ** ppi << \ n << * pi = << * pi << \ n << i = << i << \ n; * pi = 13; std :: cout << ** ppi = << ** ppi << \ n << * pi = << * pi << \ n << i = << i << \ n;我= 59; std :: cout << ** ppi = << ** ppi << \ n << * pi = << * pi << \ n << i = << i << \ n; </ OL>  
<li> int i = 42; </ Li>  
<li> int * pi =＆i; </ Li>  
<li> int ** ppi = new（int *）（pi）; </ Li>  
<li> </ li>  
<li> std :: cout </ li>  
<li> << ** ppi = << ** ppi << \ n </ li>  
<li> << * pi = << * pi << \ n </ li>  
<li> << i = << i << \ n; </ Li>  
<li> ** ppi = 47; </ Li>  
<li> </ li>  
<li> std :: cout </ li>  
<li> << ** ppi = << ** ppi << \ n </ li>  
<li> << * pi = << * pi << \ n </ li>  
<li> << i = << i << \ n; </ Li>  
<li> * ppi = new int（17）; </ Li>  
<li> </ li>  
<li> std :: cout </ li>  
<li> << ** ppi = << ** ppi << \ n </ li>  
<li> << * pi = << * pi << \ n </ li>  
<li> << i = << i << \ n; </ Li>  
<li> * pi = 13; </ Li>  
<li> </ li>  
<li> std :: cout </ li>  
<li> << ** ppi = << ** ppi << \ n </ li>  
<li> << * pi = << * pi << \ n </ li>  
<li> << i = << i << \ n; </ Li>  
<li> i = 59; </ Li>  
<li> </ li>  
<li> std :: cout </ li>  
<li> << ** ppi = << ** ppi << \ n </ li>  
<li> << * pi = << * pi << \ n </ li>  
<li> << i = << i << \ n; </ Li>  
四个问题：  
＃5a.这是什么打印？＃5b.正在执行此代码的方法，是删除pi一个有效语句？＃5c.在执行此代码的情况下，是删除* ppi一个有效语句？＃5d.After执行此代码，是删除PPI有效的陈述？答案：  
＃1.它被破坏了一次。指针变量p是完全一旦达到其终身时间的终身时间（）的终结结束时。它在达到其寿命结束时没有任何事情发生。它永远不会发生在通过删除的情况下删除。＃2.no.delete Pi对PPI没有影响。注意，PPI（例如* PPI）产生对该点的PI.A双重引用的引用（例如** PPI ）产生未定义的行为.Also，删除PPI将无效，因为它指向未与新的对象一起分配。＃3.no.nave pi不知道ppi存在。它应该是什么？另外，删除pi会无效，因为它指向未与新的对象分配。＃4a，＃4b：两者的答案是单位是独立的变量。＃5a：请参阅此处验证。<ol> ** ppi = 42 * pi = 42 i = 42 ** ppi = 47 * pi = 47 i = 47 ** ppi = 17 * pi = 47 i = 47 ** ppi = 17 * pi = 13 i = 13 ** ppi = 17 * pi = 59 i = 59 </ OL>  
<li> ** ppi = 42 </ li>  
<li> * pi = 42 </ li>  
<li> i = 42 </ li>  
<li> ** ppi = 47 </ li>  
<li> * pi = 47 </ li>  
<li> i = 47 </ li>  
<li> * pi = 13 </ li>  
<li> i = 13 </ li>  
<li> ** ppi = 17 </ li>  
<li> * pi = 59 </ li>  
<li> i = 59 </ li>  
＃5b：no.pi指向i。＃5c：是。删除* ppi = new int（17）分配的对象;在线17.²  
＃5D：是。删除由INT ** PPI = NEW（INT *）（PI）分配的对象3.YES，此答案进一步远离您所需的原始问题。  
### 回答 3
所以，你有这样的东西：  
<ol> class x {...这里的东西......};int main（）{x ** ptr_ptr;... ptr_ptr = new x *;* ptr_ptr = new x;...删除ptr_ptr;} </ OL>  
<li>类x </ li>  
<li> {</ li>  
<li> ... ... </ li>  
<li>};</ Li>  
<li> int main（）</ li>  
<li> {</ li>  
<li> x ** ptr_ptr;</ Li>  
<li> ptr_ptr = new x *;</ Li>  
<li> * ptr_ptr = new x;</ Li>  
<li> </ li>  
<li> ... </ li>  
<li>删除ptr_ptr;</ Li>  
<li>} </ li>  
那么，你需要第二个删除* ptr_ptr;[在上面所示之前]。  
或者使用std :: unique_ptr或std :: shared_ptr。  
### 回答 4
双指针w  
不，指针很浅。这意味着删除指针不会导致销毁它指向的存储器。  
删除关键字是对默认析构函数的调用，以便调用它的指针类型。它仅适用于与新操作员动态创建的项目。对于int，double，char等的原语，调用f来自c的常规free（），但对于structs，类，Asnd Onioions它调用了对象的指定的解钉，这主要调用析构函数函数，然后拒绝内存，将其返回免费商店。  
双指针对指针没有任何影响，如果您调用删除，则会对其具有地址的指针。只有双指针本身将被解除分配。如果您仍然具有用于使用新的存储器创建存储的原始指针，这将是无害的，因为您仍然可以调用删除。  
双指针到C ++中对象的用例非常罕见;只有与遗留C代码的接口将是您在现代来源中找到它的地方。  
### 回答 5
问题：在C ++中，如果我有一个指向一个指针的指针到一个新对象，我删除了第一个指针，那么新对象也会删除吗？  
这适用于所有版本的C ++  - 否。您将具有内存泄漏。您必须将指针删除到指针，然后删除指针。首先，它将删除对象，然后它将删除指针。  
其次，没有指向指针的指针 - 这是指向指针或指针的指针，这是代码：  
<ol> //类点点** ptptr，* pt; pt =新点; ptptr =＆pt;删除pt; //现在已经删除了删除PTPT </ OL>  
<li> //类点</ li>  
<li> point ** ptptr，* pt; </ Li>  
<li> pt =新点; </ Li>  
<li> ptptr =＆pt; </ Li>  
<li> </ li>  
<li>删除pt; //现在您的观点已被删除</ li>  
<li>删除ptpt </ li>  
问题：在C ++中，如果我有一个指向一个指针的指针到一个新对象，我删除了第一个指针，那么新对象也会删除吗？  
这适用于所有版本的C ++  - 否。您将具有内存泄漏。您必须将指针删除到指针，然后删除指针。首先，它将删除对象，然后它将删除指针。  
其次，没有指向指针的指针 - 这是指向指针或指针的指针，这是代码：  
<ol> //类点点** ptptr，* pt; pt =新点; ptptr =＆pt;删除pt; //现在您的观点已被删除删除ptptr; //现在已删除了对该点的指针。 </ OL>  
<li> //类点</ li>  
<li> point ** ptptr，* pt; </ Li>  
<li> pt =新点; </ Li>  
<li> ptptr =＆pt; </ Li>  
<li> </ li>  
<li>删除pt; //现在您的观点已被删除</ li>  
<li>删除ptptr; //现在已删除了对该点的指针。 </ Li>  
### 回答 6
你在java中得到更多的托托。  
您可以将所有指针删除到结构或对象，并且仍然坐在那里，直到节目结束或直到时间结束。  
这里没有垃圾收集器。当你完成狗屎时，你必须学会擦拭自己的屁股。如果您无法管理，那么C和C ++真的不是为您的。  
### 回答 7
Whatsapp号码; +1（520）839-5010  
它💯％可以在不触摸它的情况下跟踪你的丈夫手机。  
电子邮件cookespyro@gmail.com，  
whatsapp号码; +1（520）839-5010  
WhatsApp  - 跨平台聊天应用程序制作了头条新闻，当Facebook获得了190亿美元。在上升500万活跃的月度用户，WhatsApp承诺所有消息都被加密，为用户提供了使用该服务的另一个有原因。但即使是一个像Whatsapp这样的平台也可以通过年轻人和旧的和每个人都容易地滥用。这就是为什么联系cookespyro@gmail.com很重要，以知道它用于良好目的。但是你思想的大问题是如何跟踪Whatsapp消息，并回答你的问题，我们向您展示了大量的CooksyRo WhatsApp解决方案，除了HoodsApp邮件跟踪，Cookespyro为您提供了一个斗斗，包括监控呼叫，包括监控呼叫管理传入的呼叫限制，跟踪发送和收到的短信，Web历史记录，例如浏览模式和传入和传出和传出电子邮件以及访问日历，联系人和管理已安装的应用。 Cookespyro提供了可供选择的最佳计划。每个都蓬勃发展了一些伟大的特色。以下是如何使用Cookekyro从Cooke仪表板上进行WhatsApp跟踪，您甚至可以在实时查看目标设备的位置，并根据您认为合适的情况设置Geofence。只要您没有透露Cookesyro联系他来帮助您，就可以允许您跟踪WhatsApp消息而无需他们知道，只要您没有知道CookeSpyro即可帮助您完成此任务。能够黑客WhatsApp，Discord，Twitter，Instagram，比特币钱包，Facebook，信用卡等。  
### 回答 8
如果您正在学习编程，您应该忘记C ++。它是学习编程的可怕方式，指针是主要原因之一。指针只是访问机制，应该由语言抽象，使程序员不必处理该细节 - 这正是语言和编译器的究竟。 C和C ++公开了详细信息，大多数程序员不需要处理，但主要用于系统编程不是正确的详细信息。  
C和C ++力程序员要考虑容器而不是内容。程序员应考虑他们正在处理哪些数据，其类型和适用的操作，而不是内存中的东西。  
<SPAN> IAN JOYNER·11月29日</ span>  
<span> 11月29 </ span>  
看到Mark Gritter的答案  
<SPAN> IAN JOYNER·7MO </ SPAN>  
<span> 7mo </ span>  
<SPAN> IAN JOYNER·11月20日</ span>  
<span> 11月20日</ span>  
<span> ian joyner·11月23日</ span>  
<span> 11月23日</ span>  
### 回答 9
在C / C ++中，为什么人们声明指向int * x而不是int * x？  
C / C ++并不意味着什么。 C和C ++是两种不同的（但相关的）语言。没有C / C ++语言。我会假设你的意思是c和c ++。  
编译器不关心你是写入int * x或int * x。令牌之间的白色空间是微不足道的（除非你需要至少一个空间来分隔两个令牌，那不是这里的情况）。  
编写INT * X的那些程序员这样做是因为它遵循语言语法。同样，如果您真的想要，您可以编写A + B * C，但编译器将忽略空格并将其视为等同于A +（B * C）。  
在C中，通常的样式是将*与变量名称相关联：int * x，主要是因为kernighan和ritchie使用了这种风格。 （Dennis Ritchie发明了C语言; Kernighan和Ritchie共同写出了语言的原版。）  
另一方面，在C ++中，最常见的样式是写入int * x。这是，据我所知，完全是因为Bjarne Stroustrup，C ++语言的创建者更喜欢这种风格，并在他的书中使用它。  
INT * X表单更紧密地跟随语言语法。宣言的基本意义  
<ol> int * x; </ OL>  
<li> int * x; </ Li>  
该int是类型，* x是那种类型的（使用声明遵循的原理，C的语法大多如下）。我们可以从此推断，x是int类型*。  
当您定义多个变量时，这会显示：  
<ol> int * x，y，z [10]; </ OL>  
<li> int * x，y，z [10]; </ Li>  
这里，* x，y和z [10]都是int类型的，因此x为类型int *，y是int类型的，z是int类型[10]。 （没有z [10]，这是我主要在上面写的原因的一部分。）  
在C ++中，许多程序员通过假装这一点来处理这一点  
<ol> int * x; </ OL>  
<li> int * x; </ Li>  
将X声明为类型int *的对象*（它确实只有间接地），并且避免在单行上声明多个变量（无论如何是一个好主意）。  
### 回答 10
看，年轻的大师 - 在现代c ++中，你几乎不要使用原始指针，好吗？你几乎甚至没有写新的或删除了，好吗？我们有分配者和Raii和make_shared和make_unique，它创造了一种指针，但真的很多。  
无论如何 - 我看到答案是教育和有趣的一种，但我看到许多人完全错过了这一点。是的，了解哪些指针以及如何工作 - 在没有它们的情况下，在没有它们的情况下，在C ++的国家是一个重要的状态，但足够相似）。  
但是 - 给我一块具有指针的C ++代码，我将相对容易地将该代码转换为同样的事情，而不是使用星号（*）符号。所以，谁告诉你C ++不能没有指针编程在技术上是错误的，但学习他们仍然是一个非常好的建议。  
编辑：鉴于坚持说明明显的人数 - 不，我并不是说指针不再有没有，因为当然他们是。围绕它们构建的语言，分配返回指针，传递指针是传递对象引用，函数指针，阵列指针等的原始方法。没有人声称他们已经不复存在，只是将原始指针少使用对于未本质上涉及低级编程的许多应用程序，这绝对迫使您使用指针。已经说过，了解指针是非常重要的，但是作为一个语义上过载的构造，他们正在让位于更先进和现代的C ++概念和习语。  
### 回答 11
（这对高耸的公寓特别有问题; C ++ a  
假设你想在家里收到一封信。您是否将整个房屋移动到发件人的位置，因此他们可以将信件放在邮箱中，然后向后移动它？  
除非你住在你的车里，否则可能不是。你给他们你的地址，他们将邮件发送到该地址。事实上，许多不同的人和企业可以通过这种方式向您的家发送邮件。此外，同样的人和企业可以向多个不同的收件人发送邮件，而无需处理突破其财产的家庭。  
（这将与高升高的公寓特别有问题; C ++类比是一个大阵列中的对象。）  
显然，在这种情况下与地址合作更有效。  
现在假设你想在家里的厨房和餐厅之间移动。你仰望你的街道地址，每次想要在房间之间移动时都会通过前门走回吗？每次抬起叉子怎么样都会咬住你的盘子咬一口食物？  
除非你试图达到Monty Python水平的荒谬，否则可能不是。  
指针增加了一定程度的间接，允许一件事的地址掌握本身。有时这是有道理的，其他时候它只是增加了不必要的间接层。  
指针本身不会更快或更慢地使您的程序。指针仅仅是一个工具。  
适当地使用指针可以导致各种算法的有效实现。在间接和数据膨胀方面，使用它们不恰当地添加意外的效率低下。  
### 回答 12
好吧！ ：） 让我们开始。我将尝试在C ++中为您提供指针的基础知识。如果您有任何疑问，您可以在互联网上更深入研究或向我询问。  
1）指针就像任何其他变量（指针就像整数，C字符串，双打，C ++字符串，浮点等）。  
2）你知道int变量存储整数值，对吗？您知道布尔变量存储真为或false，正确吗？正确的。指针存储地址。这很容易！  
2.5）让我们声明一个int变量：  
in x = 10;  
让我们声明一个布尔变量：  
bool y = true;  
让我们创建一个指针变量：  
int *  
好吧！ ：） 让我们开始。我将尝试在C ++中为您提供指针的基础知识。如果您有任何疑问，您可以在互联网上更深入研究或向我询问。  
1）指针就像任何其他变量（指针就像整数，C字符串，双打，C ++字符串，浮点等）。  
2）你知道int变量存储整数值，对吗？您知道布尔变量存储真为或false，正确吗？正确的。指针存储地址。这很容易！  
2.5）让我们声明一个int变量：  
in x = 10;  
让我们声明一个布尔变量：  
bool y = true;  
让我们创建一个指针变量：  
int * z =＆x  
（我将解释这个语法，但是现在保持在我的脑海中，这是一个指针变量，指向保存整数值的计算机的内存地址 - 此处的该整数值是值10.因此，指针变量z按住变量x的地址。在FANCIER单词中，指针变量Z指向X的地址）。  
3）您声明的此指针变量内的此地址是内存位置。换句话说，该存储器位置是存储可变内容的真实位置（它可以是整数，如3,87,20;它可以是C ++字符串，如蛋糕和冰淇淋;它可以是一个布尔，像'真实'或'false';等等）。基本上，我们谈到指针，如：指针my_pointer指向变量my_variable。这是什么意思？这意味着指向指针变量my_pointer指向（它包含到my_variable的地址）。  
如果my_variable是一个整数，那么，当您声明指针时，它也必须是整数指针。您不能指向整数变量的布尔指针。  
4）基本C ++指针语法。  
声明Boolean指针：  
BOOL * FIRST_POINTER;  
声明Boolean变量以用于演示目的：  
bool first_var = true;  
将Bool指针变量内的BOOL变量的地址放置：  
（使用Ampersand（＆））（您这样做）  
BOOL * FIRST_POINTER =＆FIRST_VAR;  
如何打印存储在此指针中的值？  
cout << * first_pointer << endl;  
请在您第一次读取时为您完全可以理解它。读了几次。对于人们感到困惑，这是完全正常的。  
我希望你现在理解！如果你有更多的疑惑，请问我:)  
