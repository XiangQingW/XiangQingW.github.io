---

title: C / C ++为您提供足够的绳索，脚踏出来是什么意思？不应该给你足够的绳索来挂起自己？
date: 2022-01-23T22:08:18+08:00

---




## C / C ++为您提供足够的绳索，脚踏出来是什么意思？不应该给你足够的绳索来挂起自己？  
### 回答 1
它是一个刻意的混合隐喻。目前，它也适用于C ++的C ++。在C ++中，您可以使用Bjarne Stroustrups观察：C让您在脚内轻松射击。 C ++让它变得更加困难，但是当你这样做时，你会把你的整个腿吹掉。  
一种通常在C和C ++中使用的技术是键入puning：¹将数据写入变量作为一种类型，并将其读回另一个类型。它既强大又容易出错。这至少是一个绳索的杂志，脚下射击自己。  
很长一段时间，C DIDNT需要用于功能的原型声明。它甚至不需要转发职能的声明。所以，你可以用你想要的任何参数写一个函数调用，只要另一方函数读取的参数足够接近，就可以工作。但如果你犯了一个错误，那么没有什么可以检查你（除非你跑棉绒等特殊工具）。  
事实上，您可以（故意或事故）调用变量。我不用函数指针变量调用函数。我的意思是跳转到一个变量的地址，因为它是一个函数。这导致了这一点......特别的IOCCC条目：  
<ol>短主[] = {277,04735，-4129,25,0,477,1019,0xBef，0,12800，-113,21119,0x52d7，-1006，-7151,0,0x4bc，020004,14880 ，10541,2056,04010,4548,3044，-6716,0x9,4407,6,5568,1，-30460,0，0x9,5570,512，-30419,0x7e82,0760,6,0,4,02400， 15,0,4,1280,4,0,4,0，0，0，0x8，0,4,0 ,,, 0,12,0,4,0，＃，0,020,0,4， 0,30,0,026,0,0，0x6176,120,25712，p，072163，R，29303,29801，E}; </ OL>  
<li>短main [] = {</ li>  
<Li> 277,04735，-4129,25,0,477,1019，0xBef，0,12800，</ Li>  
<li> -113,2111119,0x52d7，-1006，-7151,0,0x4bc，020004，</ li>  
<Li> 14880,10541,2056,04010,4548,3044，-6716,0x9，</ Li>  
<Li> 4407,6,5568,1，-30460,0,0x9,5570,512，-30419，</ Li>  
<Li> 0x7e82,0760,6,0,4,02400,15,0,4,1280,4,0，</ Li>  
<li> 4,0,0,0，0x8,0,4,0 ,, 0,12,0,4,0，＃，</ li>  
<Li> 0,020,0,4,0,30,0,026,0,0x6176,120,25712，</ li>  
<Li> P，072163，R，29303,29801，E </ Li>  
<li>}; </ Li>  
那是VAX机器代码，如果我记得对。 [编辑：VAX和PDP-11，组合。看评论。]而且，他们真的确实被声明为短暂的数组。谈论混合隐喻！  
我记得听到与LAX函数调用检查有关的各种编程建议，并达到旧的CS伟大意愿混合整数和指针。不要假设int足以掌握一个指针！这是对可移植性的建议。  
如今，这是沿着两次思考的线，三次，三次！ - 在整数类型中操纵一个指针。当你这样做时，使用这个特殊的UIntptr_t ......而且他们甚至没有讲述可移植性。这是来自未定义的行为讲座。  
一般来说，如果你混合你的类型，或mismanage你的指针，不要看你的阵列界限，或者开始真正着色，如我从80年代末期/ 90年代看到的很多C代码，你可以结束有各种各样的海森伯和脸上吹来的东西。  
许多人出现来自混合隐喻的编程等同物。  
顺便说一句，我不知道Usenet是否从书中拿起这句话，或者书从Usenet挑选出来，或者他们都从第三个来源挑选它。我会说我记得在当天的某些时候听到它，我认为它在Usenet上。  
¹百货惩罚在当天更普遍。在GCC 2.95周围，它们在-Fstrict-aliasing作为-O2及更高版本的默认情况下，它通过指针打破了类型的双关语。如今，您需要使用std :: memcpy或std :: bit_cast（c ++ 20）到C ++中的键入双关语。在C中，您需要使用一个工会或MEMCPY。  
### 回答 2
非常相同的功能，给出c和c ++这么大的力量a  
C / C ++为您提供足够的绳索，脚踏出来是什么意思？不应该给你足够的绳索来挂起自己？ （关联）  
正如Joe Zbiciak解释得这么好，这个想法是C和C ++允许您操纵到内存的指针，这意味着您可以在程序的数据区域中读取和写入任何位......有时候会更换。这使您（或者至少用于让您）将任何数据类型视为任何其他数据类型，并在阵列中访问负面索引时，为今天的人们畏缩的各种数据类型。  
给出C和C ++的非常相同的功能也是他们的力量，这也是使它们极其且经常巧妙地危险的那些。  
Bjarne Stroustrup，C ++的作者是着名的，C ++的作者使C脚踏实于脚下。 C ++让它变得更加困难，但是当你这样做时，你会把你的整腿吹掉。  
我的同事建议他应该说，C ++让它变得更加困难，但是当你这样做时，你会吹那些附属的每个子类。  
__________¹bjarne stroustrup已经说过很多聪明，有洞察力，只是平淡的愚蠢的东西，这将改善你的生活......或者只是让你微笑。  
### 回答 3
据说是说你试图挂起自己，但你最终射击自己。因为如果你做错了，你就可以生成真正奇怪的事情，就像用绳子一样奇怪，最终射击自己。  
想象一下，绳子与其他东西绑在别的东西上，并将枪瞄准你的脚，别的东西会导致射击。那个奇怪的奇怪。  
但是唯一一个真正认为这种方式的人就是那些真正不了解C / C ++的人，足以知道如何不做那种东西。并且也被使用指针。  
### 回答 4
当您在C ++中建立一个奇怪的对手，如Tom＆Jerry卡通中的复杂陷阱，你有一个错误的举动，并且在末端拉动击球枪的连锁反应。  
C让自己轻松射击自己;C ++让它变得更加困难，但是当你这样做时，你的整个腿就会吹掉。  
[Bjarne Stroustrup]  
### 回答 5
这是一个笑话。基本上C允许您做任何事情。但实际上得到了你想要的结果很难。  
### 回答 6
问：为什么C速度比C ++更快？A：不是。 C ++更快。  
非正式地，每个C程序都是C ++程序，并且Visual C ++，GCC和CLANG中的编译器后端是相同的，因此它很可能是真正等效的程序生成相同的代码，因此以相同的速度运行。  
这意味着每个C-oder-over-c ++基准使用不同的程序，通常将高调的C代码与天真C ++代码进行比较。当C ++也有阵列时，它们将C阵列与C ++向量进行比较。它们比较C堆栈上分配的C alloca（），以c ++新增，它在堆上分配。他们使用C ++分配行为的特殊知识来编写一个基准，其中C跑得更快，比如John Harrop在此线程中执行，当使用相同知识的C ++程序员可以通过限制动态的范围来加速其代码到等效级别。分配变量如下片段所示（注意每个分配周围的额外卷曲括号）。  
<ol> for（int i = 0; i <1000; i ++）{{vector <int> a（1000000）; x + = a [0]; } {vector <int> b（1000000）; x + = b [0]; } ... </ OL>  
<li> for（int i = 0; i <1000; i ++）</ li>  
<li> {</ li>  
<li> {vector <int> a（1000000）; x + = a [0]; </ li>  
<li> {vector <int> b（1000000）; x + = b [0]; </ li>  
<li> ... </ li>  
C restrict关键字是一个异常，在C ++中不可用，这可能会使一些C程序运行得更快。  
因此，剩下的是C ++功能不存在于C ++程序更快。包括内联函数和模板的功能，使中转化优化更加丰硕，更快的算法（std :: sortus与qsort（）），c ++长度+缓冲区字符串与c null终止字符串，c ++异常处理与铲斗之行时尚的返回错误代码相比，毫无疑问，许多人比我不能立即打电话。  
然后我们拥有C ++功能，使得更容易编写最佳代码，如虚拟功能与IF / else if chains或switch语句。使用函数指针，可以从C获取C ++的性能，但仅具有特殊知识。 （我承认，当您不需要它们时，也可以使用虚拟功能，并将C ++程序减慢。）  
回答这个问题的大多数人（包括我到目前为止）不提供证据支持他们的索赔。我钦佩约翰哈罗夫这样做，即使我争取了他的结果。  
### 回答 7
问题假定阿达很受欢迎。  
这根本并不清楚。  
Ada，当它开始时，在编程语言的演变中是一个很好的一步。但是，而不是试图进行小的渐进步骤，而是刚刚迈出了。例外和多线程是两个我回想一下，肯定添加到骆驼的负载中。  
由此产生的野兽不再是一种简单的语言。现在是一个困难的整个运行时环境（阅读：昂贵），以创建，维护和使用。  
国防部要求承包商使用它，但随后承包商因豁免而要求豁免  
问题假定阿达很受欢迎。  
这根本并不清楚。  
Ada，当它开始时，在编程语言的演变中是一个很好的一步。但是，而不是试图进行小的渐进步骤，而是刚刚迈出了。例外和多线程是两个我回想一下，肯定添加到骆驼的负载中。  
由此产生的野兽不再是一种简单的语言。现在是一个困难的整个运行时环境（阅读：昂贵），以创建，维护和使用。  
国防部要求承包商使用它，但随后承包商因费用而要求豁免。那些经常被授予，这么久很快，没有人使用它。  
然后C ++出来了，这似乎是一个很大的简化，尽管C ++是一个无节目的语言和运行时环境。  
在计算机科学中，我们不会站在巨人的肩膀上。我们站在彼此的脚趾上。或者更糟糕的是。我们经常觉得任何事情都是可能的，所以我们渴望太多，然后我们在不是一切都很完美时失望。真正的进展比较高得多。  
### 回答 8
我真的不明白这个问题的背景。这些人应该告诉我任何关于C / C ++的人（无论这意味着什么）吗？什么阻止他们告诉我这些东西？什么阻止我在互联网上搜索这些东西？无论如何，我认为OP希望了解一些关于语言的有趣事情，这些事情并没有广泛传播着新手。这是我的两美分：  
### 回答 9
Le的固定在一起。<ol> //我的代码：#include <iostream>使用命名空间std; int main（）{浮动基座，高度，区域;基地= 10.3高度= 13.56;面积= 1/2 *基地*高度; cout <<与基数的右三角形的区域为10.3“<< base <<和高度13.56”height <<是<<区域<< ENDL;系统（暂停）;返回0; } </ OL>  
<li> //我的代码：</ li>  
<li> #include <iostream> </ li>  
使用命名空间std; </ Li>  
<li> int main（）</ li>  
<li> {</ li>  
<li>浮子基地，高度，面积; </ Li>  
<Li> Base = 10.3 </ Li>  
<li>高度= 13.56; </ Li>  
<Li>面积= 1/2 *基地*高度; </ Li>  
<li> cout <<与基础10.3“的正确三角形区域”<< base <<和高度13.56“高度<<是<<区域<< ENDL; </ Li>  
<li>系统（暂停）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
第7行预计分号; .See下面的错误消息，它表示第8行预期;在高度之前.D在高度和基础之后的分号解决了问题。重量代码;  
使用命名空间std <ol> #include <iostream> int main（）{浮动基座，高度，区域;基地= 10.3; //您省略了一个半冒号.Height = </ OL>  
<li> #include <iostream> </ li>  
使用命名空间std; </ Li>  
<li> </ li>  
<li> int main（）</ li>  
<li> {</ li>  
<li>浮子基地，高度，面积; </ Li>  
<li>基地= 10.3; //你省略了一个半冒号。</ li>  
<li>高度= </ li>  
Le的固定在一起。<ol> //我的代码：#include <iostream>使用命名空间std; int main（）{浮动基座，高度，区域;基地= 10.3高度= 13.56;面积= 1/2 *基地*高度; cout <<与基数的右三角形的区域为10.3“<< base <<和高度13.56”height <<是<<区域<< ENDL;系统（暂停）;返回0; } </ OL>  
<li> //我的代码：</ li>  
<li> #include <iostream> </ li>  
使用命名空间std; </ Li>  
<li> int main（）</ li>  
<li> {</ li>  
<li>浮子基地，高度，面积; </ Li>  
<Li> Base = 10.3 </ Li>  
<li>高度= 13.56; </ Li>  
<Li>面积= 1/2 *基地*高度; </ Li>  
<li> cout <<与基础10.3“的正确三角形区域”<< base <<和高度13.56“高度<<是<<区域<< ENDL; </ Li>  
<li>系统（暂停）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
第7行预计分号; .See下面的错误消息，它表示第8行预期;在高度之前.D在高度和基础之后的分号解决了问题。重量代码;  
使用命名空间std <ol> #include <iostream> int main（）{浮动基座，高度，区域;基地= 10.3; //省略了一个半冒号.Height = 13.56;面积= 1/2 *基地*高度; cout <<与基础10.3的正确三角形区域<<基础<<和高度13.56 <<高度<<区域<< ENDL;系统（暂停）;返回0; } </ OL>  
<li> #include <iostream> </ li>  
使用命名空间std; </ Li>  
<li> </ li>  
<li> int main（）</ li>  
<li> {</ li>  
<li>浮子基地，高度，面积; </ Li>  
<li>基地= 10.3; //你省略了一个半冒号。</ li>  
<li>高度= 13.56; </ Li>  
<Li>面积= 1/2 *基地*高度; </ Li>  
<li> cout <<与基础10.3的右三角形的区域<< base <<和高度13.56 <<高度<<区域<< ENDL; </ Li>  
<li>系统（暂停）; </ Li>  
<li>返回0; </ Li>  
<li>} </ li>  
避免编码不良，例如使用系统（暂停）。它的坏！第一个：它的作用.Calling系统实际上是在Windows命令提示符中键入命令。对于您的应用程序来说是一个吨的设置和拆除这样的呼叫 - 并且开销只是荒谬。第二个从Visual Studio关闭程序时关闭，且新用户未能查看他的新程序的输出：如果将命名为暂停的程序被放入用户路径中，则如何？只需调用系统（暂停）只能保证执行命名为暂停的程序！解决方案：只需编写使用_getch的暂停（）函数，它在Conio.h中定义，但如果您在Windows上开发并且它具有相同的效果，则其更好。 ：为什么介绍这么多潜在的问题s的时候只需添加两行代码和一个包含并获得更灵活的机制？  
### 回答 10
您询问C ++与C的相对难度。我对难度的看法是它是歧义的症状。当你理解它时，没有什么是困难的。也许耗时。更多的时间做某事并不总是平等的困难。在理解C或C ++时，可以存在障碍，这可以使它们看起来更加困难。解决方案是学习和实践。  
概念  
C首先更容易学习，但在手头上任务，可能比C ++更难使用。问题不是语言。该问题通常涉及您必须申请某些类型的软件的概念。遵循一个例子。  
Tedd游戏玩家...... Jeff The Kernel编码器  
采取以下两人经验丰富，在使用C.杰夫在运行系统内核工作时完成了。 Tedd比杰夫更少，但建造了AAA视频游戏。他们交换了地方。尽管两者都有与语言的专业知识，但每个人都会以自己的方式挣扎。  
杰夫和特德，C vs. C ++  
如果TEDD，游戏DEV通常使用C ++？这种语言适用于他建立的游戏。 Jeff使用C for OS内核开发。在那种竞技场中证明的语言。再次交换Tedd和Jeff，但将所选语言留下来使用其他语言。  
Tedd游戏Dev从未在他的生命中使用过C.假设它都与C ++相同。然后他与系统发展概念，语言差异和发展方式斗争。他的意愿不是他的事情，即使他没有意识到他知道他的困难。他的挑战是其他地方。  
Jeff The Systems Dev现在正在尝试在C ++中建立游戏，只有他的背景在C.中以前从未有兴趣应用C ++。他正在努力争取抽象的想法，在精神上对他们努力工作，对编译器错误感到惊讶，不会出现在C.TEDD在同样的情况下没有这些问题。杰夫不是那么。  
准备，实践和持久性  
每种语言都不比另一个语言更困难。语言是所涉及的一小部分。专注于3 PS：准备，练习和持久性。心态，奖学金，最重要的是，语言Wielder的常规实践经验是原则问题。  
