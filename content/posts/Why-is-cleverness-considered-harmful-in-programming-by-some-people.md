---

title: 为什么聪明的聪明被认为是有害的一些人的编程？
date: 2022-01-23T22:08:17+08:00

---




## 为什么聪明的聪明被认为是有害的一些人的编程？  
### 回答 1
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。  
当你做一些聪明的事情时，你会评论它，以及为什么这样做。  
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。  
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。  
我们写的负载平衡器软件下降到超过7  
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。  
当你做一些聪明的事情时，你会评论它，以及为什么这样做。  
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。  
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。  
我们写的负载平衡器软件下降到每秒超过7,000多个连接。我切换回来，它返回到每秒39,000个连接下的前面的性能。  
阅读评论很重要。  
我的聪明赢得了我们的表现超过5.5倍。  
因此，如果您认为聪明地被认为有害，请尝试在修改它之前学习在其他人代码中阅读评论，并尝试评论您自己的代码。  
### 回答 2
它不是普遍的有害，但有时是有害的。  
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。  
第一年：  
第二年：  
第三年：  
第五年：  
第十年：  
再次，信用肖恩。  
可读性非常重要。  
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。  
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。  
有时，需要非常复杂和聪明的非常复杂的问题  
它不是普遍的有害，但有时是有害的。  
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。  
第一年：  
第二年：  
第三年：  
第五年：  
第十年：  
再次，信用肖恩。  
可读性非常重要。  
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。  
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。  
有时，需要极其复杂的问题，需要极其复杂和聪明的解决方案，有时有需要更大的架构图片，需要前进。在那些时期之外，以最简单的方式遵循最佳做法通常是正确的答案。  
一切都有例外（如果它是在使用情况下的第n个电源的情况下，有些1ns的改进可能值得疯狂复杂性），但通常，简单，可读，简单的代码将是大帮助。  
维护。  
一位曾经曾在她的研究中研究过软件开发生命周期的教授，一旦确定了80/20（或20/80）软件规则。在编写码的生命的20％，它的80％是维持的。  
代码通常不会生活在真空中。有时我们完全有一个特定作业的孤立的代码，并且经过完全测试，并且永远不需要触及。但是，禁止越复杂，维护越难。  
即使是那些碎片，如果触摸复杂的东西的代码被触摸，那么了解复杂性就会成为必要的，因为不引入更多的错误。如果可以使用简单和直截了当的东西，它可以节省大量的DEV，通常在其他地方花费更好。  
### 回答 3
Kernighan的法律：  
### 回答 4
调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。Brian Kernighan.  
足以说，如果你像你写代码一样聪明一样聪明，你的代码可能太复杂了。始终争取简单性。  
也就是说，优雅的简约很少出现在简单的思维中。你必须聪明地想出简单的代码，但你的代码不应该来交流...  
<span>代码</ span>  
### 回答 5
以下是两种优化定律：  
代码是为一个大型项目编写的六个月，对小项目少得多。它可能会保持五年或十年。它是由一个人写的。它可能由三人或十个人维护，具体取决于公司。  
计算机有大量的记忆力，节目花费99.9％的时间等待某事。几乎所有曾经写的代码没有任何空间或速度的限制。很少有需要小或快速的代码。即使他们这样做，也很罕见地知道我们何时编写它会影响程序所需的总空间或时间。  
根据定义，聪明的代码很难理解，也很难理解，也很困境，要么在六个月的时间内才能理解。每次有人遇到那段代码时，他们将在未来十年内遇到困难。  
具有巧妙代码的目标是在空间或速度下高效。如果程序所做的一千倍只等待用户单击鼠标，那么它很快就会快速毫无意义。如果它只会在带16GB的RAM上的计算机上保存几千字节，则毫无意义。  
我花了很长时间编码了一个非常有限的项目，非常有限的空间有限。我没有访问任何普通库。我编写了一个多次泡沫，但我从未编码任何其他类型的排序。我从来没有必要;唯一一个我能负担得起的唯一案例都是我可能有十几个元素和充足的时间。泡沫排序更简单，有效。  
有一个时间聪明，那就是你写了你的程序，它太大或太慢了。然后你经历它并找到所有低悬挂的水果。您发现通常足够调用的函数，以至于它们具有显着效果，或者找到占用大多数内存空间的数据结构。然后你优化那些。这为您提供最少量的努力，即未来十年。  
当您编写代码时，巧妙的代码是坏代码;这是突然突然且难以维护。每一块聪明的代码都必须能够通过明确和有说服力的证据来证明其存在。  
编辑：要回答几个异议评论，您不会在编写代码时忽略性能。您要记住，代码必须具有一定的性能。我已经在实时控制中度过了所有的生活，我从未有过严重的表现问题。如果您正在设计一个程序，并且存在多次搜索的数据结构，则您可以快速地进行代码。你没有把它放在数组中。要采取更荒谬的示例，您不会写入Python或JavaScript的应用程序。  
但巧妙的代码不仅仅是快速，小的代码;它是快速的，小代码没有人乍一看。 （它可能是大的，慢的代码没有人理解，但那些显然是糟糕的。）你不需要聪明的代码，以便最优化，当然不是你第一次编写程序时可能包含的那种优化。使用AVL  - 平衡树代替阵列不是巧妙的代码。使用c而不是python不是聪明的代码。  
当必须优化清除算法时，巧妙代码是合适的，并且没有明确的方法来做。然后，只有，只有，您可以选择使用不明确的算法。  
对于应用程序的功能完成，并且编程团队被撤销，为什么没有表现为要求规范？性能是一个特征;慢程未完成速度。  
### 回答 6
代码维持比写入更长的时间。其他程序员来了，他们可能不会像你一样聪明或聪明。重要的是他们理解代码，并且不会因其聪明而感到困惑。  
我已经足够长了，可以在z-80汇编代码中记住特定的技巧。一个非常常见的操作是加载寄存器，例如带0.汇编器操作码为：ld a，0  
但这需要2个字节的内存，并要求CPU从程序空间加载值0并将其移动到寄存器中。事实证明，您还可以执行本身的独占或操作，这也导致0：  
xor a，a  
这只需要1个字节，略微更快。现在，汇编程序员熟悉这个诀窍并知道它是什么。但是几年后，我偶然发现了这个C代码：  
计数器^ =计数器;  
^是C中的独占或运营商。所以这在C中基本上是相同的操作，加载值计数器0.程序员我正在使用那条线并询问我是否知道它是想做什么。我解释并编辑了符号= 0;  
我已经看到了许多情况，其中操作被分解为更小而更加简洁的代码，那里程序员必须真正思考，这确实是代码正在尝试的，然后检查它。如果原来的程序员必须思考它，那么下一个人就无法理解它。  
否则代码的清晰度比巧妙更重要，除非它是突然聪明的。  
### 回答 7
有时是必要的聪明，而且聪明的人更简单的聪明才智是天才的标志。每个人都记得e =mc²，即使我们几乎没有人（包括我）实际上没有理解它。 Tarjan的Union-Find算法是一个简单的东西的另一个例子，它有效地令人惊讶地做出了令人惊讶的事情，并且效率的推理是艰难的，但模式很简单。  
然而，很多聪明都不是那种形式。它没有简化的东西。它不会让他们容易地遵循其他人。并且，除非您纯粹为自己编码，否则其他人最终将维持您的代码。而且，如果您的聪明才难以理解（它几乎总是这样），有些人试图改变代码的人不会理解聪明，从而打破它。  
因此，巧妙的代码是脆弱的代码。你不想写脆弱的代码。有人会打破它。  
### 回答 8
对于这个问题，这个报价是完美的答案。  
调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。  
 - 汉语W. Kernighan.  
编程并不总是关于您熟悉任何特定语言的数量。它是计算机和其他人可以理解的方式。  
假设您有一段代码可以做一些以非常复杂的方式编写的一些更改，那么您将如何感受？ wtf !!!弄清楚实际代码需要很长时间  
对于这个问题，这个报价是完美的答案。  
调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。  
 - 汉语W. Kernighan.  
编程并不总是关于您熟悉任何特定语言的数量。它是计算机和其他人可以理解的方式。  
假设您有一段代码可以做一些以非常复杂的方式编写的一些更改，那么您将如何感受？ wtf !!!弄清楚实际代码以及如何实施的事情需要很长时间。  
但是，同样地，如果您已经给出了简单而简洁的代码来编辑，那么您可以轻松理解所有关于的代码以及相应的更改。  
简单的解决方案对于长期维护更好。聪明的解决方案很棒，但通常最简单的直接解决方案是最好的。  
### 回答 9
问：聪明的聪明被认为是有害的吗？  
答：聪明本身并不有害。  
但在源代码中揭示聪明而不是清晰度是编程的最高罪。  
### 回答 10
因为复杂和精彩不是最好在凌晨4点调试的最好的事情，之后是1小时的车程，在3:00接到电话后，修复崩溃的东西，现在需要修复。  
调试代码的人可能不会像写代码的那样聪明而聪明，即使是你。  
### 回答 11
编写代码时，人们应该努力生产最简单，最清晰，易于阅读符合所有要求的代码。  
如果您正在编写一个控制系统来定位ISS，那可能是非常诅咒的复杂性。如果您正在编写简单的CRUD休息服务，那应该非常简单而干净。  
人们在工程上与聪明 - 过度惩罚，周末随叫随到。  
我认为这更聪明地写下ISS控制系统，即新的CS GRAC可以维持它。  
### 回答 12
调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。  
-Kernighan的法律  
聪明并不总是一件坏事，但必须适度地完成。当您正在编写巧妙的代码时，您是根据您的能力的限制工作的定义，并且在您需要时会进一步延伸自己。通常情况下，巧妙的解决方案几乎是脆弱的行为变化，这可能只是直接代码中的语句可以额外的如果可以解开制造巧妙代码的关键假设之一，使得包含必要的行为更难改变。  
但适度不是永远不会。以下是一些指导方针：  
### 回答 13
聪明还可以。只要您可以清楚和可靠地记录它，就会找到一些聪明的聪明才智没有错。  
将多个项目缩小到一个命令中，这将需要一个非常专业的理解，以便能够解析或修复它，如果有任何错误，并且更糟糕的是没有提供其工作原因的任何文档，是最高的类别。  
代码需要清晰度 - 除非您希望成为该程序的使用寿命的任何内容的任何内容。  
胆量法 - 一个复杂的系统总是发现从工作的简单系统中发展。反向命题也似乎是真的：从头开始设计的复杂系统永远不会工作，无法工作。您必须重新开始，从工作简单系统开始。  
证实。验证，验证，验证。  
设计。制定计划，按照计划进行操作，只能确保完全调整。不要破解代码，除非您可以记录为什么需要以不寻常的方式执行某些事情。未能正确设计和文档代码具有导致未纵向产品的趋势。  
### 回答 14
它不是。有些人认为他们比他们更聪明，这是非常有害的。  
这些日子将善良与善良相同的人的数量是非常象征的问题。  
有很少的情况，要求您以一种方式编写代码，以便编程的人无法弄清楚很快，如果您编写代码，就像它一样，它不可思议的动机或无能。  
任何聪明的傻瓜都可以让事情变得更大，更复杂，更暴力。它需要一丝天才 - 朝着相反的方向移动很多勇气。〜例如舒马赫  
### 回答 15
这很容易。  
每个团队都有不同认知能力的人。反过来，你可能会发现认知能力较低的人是你。  
有一天，你可能会在半夜被称为，因为一些聪明的代码被打破了。也许依赖变化。也许添加了一个功能。你不知道。你现在正在看一些聪明的代码。你不知道它应该做什么，因为在改变的事情之前，它巧妙地正确地做了这件事。  
现在你必须弄清楚它巧妙地做了什么，你必须巧妙地使它在新环境中工作，假设改变了没有搞砸了聪明所基于的整个假设。  
向FDA的报告不会通过截止日期到达那里，或者工资单不会出去。  
我希望你感到聪明。  
### 回答 16
聪明的代码不是好的代码，如果有人必须拼图在一段代码上，因为它使用一些模糊的技巧来保存指令或两个，它不具有成本效益。  
现在，已经说过，很好的做法是使用适当的作业算法，如果您的团队中的一些不熟悉，这可能被视为聪明。我会说这是一个很好的代码，因为它以一种经典方式解决了问题，这往往可以通过可能或可能不具有稳健或可靠的临时方法可靠。  
### 回答 17
随着系统的复杂，你必须聪明。这不是我们指的聪明。  
这里的聪明才智是旨在复杂的代码，以证明他们有多聪明。这是一小竞争对手的自我吸收的智力主义。它不成熟。  
但如果你认为反智力主义是答案，你就像愚蠢一样。  
答案是将复杂性视为问题，并作为问题。复杂性很好地是编程，在界面，可用性方面的主要关注点，甚至在生活中。  
如果你是一个聪明的人，试图向世界证明你是多么聪明，你是德比特拉特  
随着系统的复杂，你必须聪明。这不是我们指的聪明。  
这里的聪明才智是旨在复杂的代码，以证明他们有多聪明。这是一小竞争对手的自我吸收的智力主义。它不成熟。  
但如果你认为反智力主义是答案，你就像愚蠢一样。  
答案是将复杂性视为问题，并作为问题。复杂性很好地是编程，在界面，可用性方面的主要关注点，甚至在生活中。  
如果您是一个Smartie，试图向世界证明您是多么聪明，您就是故意编写复杂的代码，使您的同事遭受遭受，软件难以理解。您的虚荣代码与您的自我乱丢，并随着您声称它是一个功能。它可能不是一个错误，但它是虫子的，而且你是错误的。这是有害的。  
相反，是聪明的。使复杂性消失。但简单性不仅适合你，特别是如果你没有难以理解你的梦幻般的混乱。  
简单是别人。这意味着简单，需要同理心。这就是你加倍努力的原因。这就是为什么最终结果是神奇的。  
你看到了这项工作，你看它是为你完成的。  
这让你微笑。  
但是，不需要从这个随机Quora答案中接受它。这个讲道的人并使他的生命工作创造了历史上最有价值的公司。  
### 回答 18
它不是 - 程序员必须聪明，以便完成工作。  
但正如其他人所说，有太聪明，有时程序员太聪明，那么那个代码难以调试和弥漫者来维护：这意味着它是脆弱的。  
脆弱的代码并不聪明，它是代码和整个应用程序的大规模风险。  
### 回答 19
编程中的巧妙通常意味着代码不太可读和/或更少维护而不是等效的非聪明方法。在维护阶段，在其寿命期间的软件成本80％或更多。所以，你做的任何事情都会增加那种成本是一件坏事。  
故意写作混淆的代码是聪明的缩影。使用的技术可以让一个人避开一个可能的东西，但代码永远不会在真正的wo中存活代码审查......  
### 回答 20
代码意味着愚蠢的机器和由聪明人维护。因此，必须经常被人类读取。代码设计中的清晰度是卓越方案的一部分，因为它很容易读取。因此，明确的代码是理想的，并且棘手，巧妙代码不是。  
### 回答 21
我认为编写代码时有多种熟悉的聪明才智。新秀和专家之间的水平是那些更常常进入智能性陷阱的水平。  
在第一个级别，您可以编写编写它应该做的代码的代码。它有时看起来笨拙，当一名高级向你展示如何解决这个问题时，你会感到有点愚蠢。  
当您继续您了解有关您的工具（AKA编程语言）的更多信息，并发现一些工作的花哨的东西。有时你觉得在你的生产代码中表明，大部分时间都没有通过这样做来回答复杂，而是开始让事情变得复杂。这是TJE水平，不必要的智能性出现。  
当你继续进一步时，你意识到编码有点像讲故事。首先，你告诉你的stoey（如何解决问题）给编译器，但当然你也告诉这个故事，每个其他程序员都必须使用你的代码。所以保持简单愚蠢（亲吻原则，虽然有些人在没有AND的情况下引用它）。别忘了，当你的头已经占用其他问题时，你可能必须在某个时候修复这个确切的代码。并相信我会感谢，如果你很容易阅读，你就会理解背后的故事，而不必深入推理。  
当然，总会有代码看起来如此聪明，你不容易理解它.. Carmacks反向尊严的根源在这里来到我的脑海中，但是这个代码看起来是因为潜在的问题，而不是因为Carmack是一个想要的聪明语炫耀（也许他有时候，但不是在这里）。我需要纠正自己的自我，它是John Carmack，而他似乎经常常见的算法已经老了  
良好的教训是查看源代码的生成的汇编代码。您会注意到，通常情况下明确的简明代码将为您提供与您的SideeEffects非常聪明的使用相同的汇编代码。所以没有必要炫耀，我们的编译器过于聪明的时间。并记住刚刚优化Sonething而不知道它将真正有必要变为过早的优化，这是根据Knuth在计算机科学中所有邪恶的根源之一。  
### 回答 22
真正聪明的代码要么很容易使用，要么是ge所需的东西  
聪明的聪明可以为一个问题产生工作解决方案，然后只是为了聪明而聪明。太经常，软件开发人员，特别是那些有足够经验的人危险，但不足以理理解危险;他们认为他们正在做前者，当他们实际上正在做后者时。  
此类解决方案的结果是，当他们可以工作时，它们是一个噩梦，当事情来解决问题时，更改操作，甚至添加新功能。  
真正聪明的代码要么是真的很容易使用，要么是完成工作所必需的。在后一种情况下，应该仔细记录它，以便下一个需要工作的人可以理解它足以能够适当地维护它。即使是你，那个代码首先写了代码，如果你在任何延长的时间内离开它，将来会有困难的理解。  
### 回答 23
在编程风格的元素中，第2版，Brian Kernighan写道  
每个人都知道，调试是首先写作课程的两倍。所以，如果你是聪明的那样，当你写它时，你将如何调试它？  
这不是禁止聪明的编程，但这对所有程序员来说是谨慎的。并记住你可能不想成为唯一可以调试代码的人。编程管理人员不喜欢编写任何其他人可以合作的代码的人。  
有时，聪明的代码可以为性能做出奇迹，或者在这是重要的时候保存大量代码。但大多数代码不需要那种聪明。并为聪明而写的聪明代码不会让你成为一个更有价值的程序员。事实上，就是相反的。  
您的写入中总有两种类型的受众。当然，第一个是代码的编译器或解释器。您的代码必须工作。它必须做你需要的事情。  
但第二个受众也很重要：将来必须与您的代码合作的人。人们不是编制者。他们需要能够理解您的代码正在做什么以及为什么。  
如果您的代码很难用于普通节目（在域中）来理解，那么您的代码不是好的代码。  
### 回答 24
通常必须修改或更新代码。  
我曾经在物理实验室工作过。我们在恐惧方面具有由计算机科学毕业生撰写的程序，因为他们做了聪明的事情（或者也许只是最先进的计算机行业标准），然后离开。  
物理毕业生更容易使用 - 至少当他们离开时我们可以理解并修复他们的代码。  
### 回答 25
因为一些人 - 特别是缺乏经验的人 - 思考鲁布戈德伯格机器是聪明的解决方案。  
聪明 - 真正的聪明 - 降低复杂性并提高理解。聪明的解决方案往往非常无聊来看待。它们确实如此应该做的事情，而且更多或更少。他们雇用尽可能少，而且没有少。当他们是直观的时候，它们伴随着清晰的文件来解释为什么使用这种方法。  
聪明的解决方案需要见解和清晰度。必须有足够的了解问题，以确切地知道需要做些什么。必须有足够的了解系统来制作必须进行的修改。必须有足够清晰的思想来解决这个问题，以便在没有提问的情况下可以阅读和理解。  
聪明的解决方案使编程看起来很容易 - 特别是在解决问题时很难。他们是一个人可以读和惊呼那样简单的解决方案，我不敢相信我没有想到它！  
因此，巧妙的解决方案通常会从系统中删除代码，并使系统更加复杂。它们可以提高代码的质量而不会降低产品的质量。  
Rube Goldberg程序员的人造巧妙性确切地恰恰相反。  
写作代码，如下一个人阅读它是一个具有均值条纹和较差的脉冲控制的实习生。陶醉于简单。  
### 回答 26
因为程序员的其余部分会告诉你我不了解你的代码。你的老板可能会告诉你改变它，所以它更加理解。  
无论代码有多好或与正常废话相比如何效率。  
即使你所做的一行代码并做不同的时间也需要20。他们不在乎。  
就个人而言，我认为它让他们感到愚蠢，没有老板或同事那样。但事实是，很多地方都与规则一起工作，让我们尽可能容易。而不是如果你不明白它会学到它。  
这是一种思考的第一种方法  
因为程序员的其余部分会告诉你我不了解你的代码。你的老板可能会告诉你改变它，所以它更加理解。  
无论代码有多好或与正常废话相比如何效率。  
即使你所做的一行代码并做不同的时间也需要20。他们不在乎。  
就个人而言，我认为它让他们感到愚蠢，没有老板或同事那样。但事实是，很多地方都与规则一起工作，让我们尽可能容易。而不是如果你不明白它会学到它。  
这是一种戏剧性，一种思维方式却在很多思考。  
这只是一个例外，主要是核心编程。在那里它必须真正快速，在那个他们几乎任何东西都原谅了你。  
此外，我不是在谈论难以故意理解的代码或使用不正确的语法，只是谈论使用语言或一些非常聪明的数学函数（而不是20个IFS）。  
### 回答 27
因为有些人叫做聪明，其他人称之为幼稚。看！看！我想出了一个不可思议的解决方案，但它比旧解决方案快10％！  
不，这是不可理解的和不可能的。我宁愿该计划飙升10％，并且可以通过任何称职的程序员了解。  
或者SIRI，当我说取消时，问我做了什么来冒犯你？到那个点，什么都没有。但是一个聪明的程序员认为这将是可爱的。我不希望在电脑中可爱。我希望它跟随我的订单。  
### 回答 28
只要聪明记录良好，巧妙是非常需要的。同一个人不会在该代码的寿命上维护代码。因此，人们将从其他人继承代码。在我工作的每个地方，我已经看到非常聪明的代码，有效地处理了99.99％的病例。当涂层患者跨越0.01％案例时，会发生问题。如果该代码记录得很好并且写得很好，良好的工程师可以进入并理解代码，并且通常会提出一个解决方案，该解决方案将解决0.01％的情况而不会导致新问题。但是，我已经看到了一位工程师的一些代码，这是一个非常聪明的，但是尽可能地将代码写成了密码，没有文档解释了聪明的算法。最终，经常，代码无法解密和修复。因此，智能代码通常被删除并被效率的代码替换，并解决问题而不会导致新问题。所需的另一个步骤是校正被良好的校正。文档必须与当前实现相匹配。否则，无法维护代码。  
### 回答 29
我认为我们都有不同的聪明定义。聪明，对我来说，在不需要的情况下，在那里使用一衬队，特别是当它不清楚代码的意图是什么时候。  
另一个例子是当标准函数工作时的正则表达式。正则表达式看起来很酷，直到您需要调试它。  
另一个例子是使用宏和其他技术为您编写代码。如果没有打破代码的大部分，您将捕获您无法更改的世界。  
有一点Quip如何讲述某人的体验级别：  
初学者的代码很简单，没有什么比幻  
我认为我们都有不同的聪明定义。聪明，对我来说，在不需要的情况下，在那里使用一衬队，特别是当它不清楚代码的意图是什么时候。  
另一个例子是当标准函数工作时的正则表达式。正则表达式看起来很酷，直到您需要调试它。  
另一个例子是使用宏和其他技术为您编写代码。如果没有打破代码的大部分，您将捕获您无法更改的世界。  
有一点Quip如何讲述某人的体验级别：  
初学者的代码很简单，没有任何花哨的东西，也许使用比需要更多的单词。  
新手程序员更具探索性，采用独特的功能和其他技术，揭示她渴望学习。  
中级程序员展示了她一起编织事物的能力。她也开始从谷歌找到不寻常的代码，愿意下拉图书馆，并将跳过箍来写小号。  
一个高级程序员写入简单，没有什么比较的代码，也许使用更多单词而不是需要。  
### 回答 30
它过于聪明，嗯，非常复杂，在制定问题的解决方案时。  
有时解决方案确实必须非常复杂，以解决问题。但是，这意味着照顾它，调试它并在需要时调整它是更加困难的。另外，尝试查看您在六个月后创建的复杂解决方案。不那么容易。  
我做了几次，真的希望我没有。  
过于聪明的人有时可以是代码高尔夫，尽可能在最短的代码中尽可能多地进行。非常适合竞争，但是任何人都会读到的隐秘。  
对我来说，我是  
它过于聪明，嗯，非常复杂，在制定问题的解决方案时。  
有时解决方案确实必须非常复杂，以解决问题。但是，这意味着照顾它，调试它并在需要时调整它是更加困难的。另外，尝试查看您在六个月后创建的复杂解决方案。不那么容易。  
我做了几次，真的希望我没有。  
过于聪明的人有时可以是代码高尔夫，尽可能在最短的代码中尽可能多地进行。非常适合竞争，但是任何人都会读到的隐秘。  
对我来说，我相信许多编码者为工作做到这一点，你希望最简单的足够解决方案涵盖所有重要观点。  
我的老板喜欢编写描述业务流程的长程序。渴望我。读取功能的我应该不到十行。  
对于简单的功能来说，这不是一个糟糕的指标，但它不是一个金色的锤子。  
我召回重构一个长期进程到一堆较小的功能。几年后，我不得不再次在该代码上工作。现在我的原始代码有效，我正在另一个部分工作。然而，我惊讶地发现自己在很大程度上，我发现自己保持了他所拥有的长程序格式。  
遵循更容易，因为我理解业务流程，发现该过程反映了它。  
我之前的邻近进程的重构不一定更容易处理和调试。如实，它需要更多的工作。  
在我自己的工作中，我确实有代码生成代码 - 它是我喜欢某些任务的东西。我最早的例子使用了反射和表达树和泛型来尝试并制作一种特定的数据库表比较工具。它确实令人惊讶地工作，对于有问题的相当基本的数据库，但很难理解。 id编码了大约一年，对此感到骄傲。  
当我想到它是什么时，它是复杂的。现在我可以用简单的SQL语句完成工作。我只是使用十几个表格的两个小型数据库，每个小型表每个，并且需要一个居民需要更改其主键，并且更改通过依赖表反映。  
现在ID只需根据需要添加真正的主键（NIC号码，SSC等）和更新。  
与真正要求的情况完全一样聪明，复杂，但瞄准尽可能简单，但没有更简单。  
有时你真的需要一些代码生成，条件表达树创建和所有的休息（提示，这很罕见！）。  
大多数时候你可以直接将实际代码写入情况，也许甚至可能是，震惊和恐怖，扔掉它 - 剪掉副本以便将来参考:)。  
我完成了奇妙的卷积定向代码，使代码可重用，因此我不必修复许多地方的错误。  
在少数情况下，这是完美的（单一数据库保存例程，如果它破坏了一次，它到处都是如此易于修复）。在其他情况下，没有收益的工作大规模复杂。我确实更好地重复了处理所需三种不同情况所需的温和变化。  
为了将解决方案降低到最简单的形式，这是简单的维护，预测和再现，是真正的聪明。  
### 回答 31
嗨Shailendra！  
为什么聪明的聪明被认为是有害的一些人的编程？  
诚实地？正确记录的代码会删除该类型的任何问题。  
我认为这是一个问题，因为这些人认为太多了，关于可能是多么努力。 =）在所有严重性中，有些人倾向于超越编程，生活，政治，以及其他一切。  
当您将其打破到更简单的步骤时，问题并不复杂。如果那些太难了，你将它们打败到仍然更简单的步骤，直到你到达你可以管理的东西。  
这是这样的  
嗨Shailendra！  
为什么聪明的聪明被认为是有害的一些人的编程？  
诚实地？正确记录的代码会删除该类型的任何问题。  
我认为这是一个问题，因为这些人认为太多了，关于可能是多么努力。 =）在所有严重性中，有些人倾向于超越编程，生活，政治，以及其他一切。  
当您将其打破到更简单的步骤时，问题并不复杂。如果那些太难了，你将它们打败到仍然更简单的步骤，直到你到达你可以管理的东西。  
这是在编程中的方式，这是这种生活方式。  
### 回答 32
什么是聪明的？你无法客观地定义聪明，可能这就是为什么有些人认为是聪明的原因是有害的人有害。在给定时间的每个项目都有一个宗旨，在初步阶段，规模和稳定性的时候，在它需要削减底线并生成金钱时，在越来越多的阶段，规模和稳定性。  
我可能是通过聪明的聪明语来获得你的意思，它是1.开发者快捷方式或者也许是2.更加表达的编程技巧。两者都略有不同，因为在捷径中，通常只是糟糕的导管录制到市场，稳定性和可扩展性[因为它的坏和未优化]和表现力的编程振动器可维护性[因为代码不会被写入的开发者读取，开发人员进出团队]。  
在我看来基本上聪明的是以一种与软件项目的目标对齐的方式编写代码。这增加了项目成功歧管的可能性。为什么要使您的努力并在一个具有较低概率的项目中写出您最优雅的代码。使它工作，使其缩放，然后使其优雅是我的想法。  
### 回答 33
如果该计划需要长时间工作，并且其他人被其他人被理解，而不是最初创造它的人......  
然后，有责任在创造该计划的人的情况下，谁将有责任保持其工作的责任做了一些难以理解的事情。  
### 回答 34
取决于你的意思'聪明'。巧妙地以一种愚蠢的方式做一些简单的任务，这不仅仅是你对一些模糊语言特征或Quirk的掌握，或者在当前情况下没有真正保证的一些技术显然将被弃用。  
写清洁，简单，轻松维护代码。通常，绝大多数时间，这意味着做到这一点普通的古老简单愚蠢的明显方式。  
当然，当你需要更多的东西时，那么你应该是聪明的！问题只是给予聪明的人真正平凡的工作要做，那就低于他们的技能水平，可能会导致这种过度聪明的问题。  
### 回答 35
由于计划交付并进入了持久的寿命，他们得到了不同的团队和最后一件事的支持是有害和有害的，他们所有人都需要使用十六进制面具的异国情调和细微的孪形曲线超级代表。把他们的才能满足程序员需要它变成了一个没有的块......现在不受支持的代码。保持简单明确，自由地洒在有用的评论中  
### 回答 36
如何  
巧妙的自行缘故，或者以误导的尝试优化代码是有害的，因为它降低了没有偏移增益的可读性。  
然而，所有聪明都没有有害。如果必须聪明地完成项目目标，或者如果有助于代码的结构，那么它可能会受益于项目而不是伤害它。  
这也取决于你在做什么。如果您正在编写Web服务器或其他简单的前端，性能很少是一个问题。当它是，选择适当的算法通常超过足以满足项目的需求。  
但是，如果您正在编写API，或构建库，数据库，编译器，设备驱动程序等，那么通常可以挤出的每一位性能都是可取的。如果您的图书馆比竞争对手显着慢，那么用户将倾向于更快的产品。与其他所有相同，例如正确性是可靠性。  
但是，不要指望开始通过高度经验丰富和有才华的开发人员轻松快速地阅读代码。他们仍然有很多学习。经验丰富的开发人员可能会写入x + x而不是2 * x或x << 2而不是4 * x而无需思考。而经验丰富的装配开发人员可能会编写（x << 2）+ x而不是5 * x，因为它转换为单个，快速，指令与乘法相比。有几十个特殊位操作，在需要时非常有用。但是，再次，在代码中很少需要那些，即开始开发人员或基本应用程序的开发人员可能需要。那些是聪明人有害的时候。  
通常，代码应该是一个简单的 - 但必要的复杂。经验丰富的发展（希望）知道差异。一个开始的开发人员没有。一个应用程序开发人员通常在简单方面错误，而一种想要展示他聪明的开发者在复杂性方面会错误。  
在某些情况下，过度表现可能是有害的。例如，在我的第一份工作中，我为IBM 360/30和稍后的IBM 370/30写了频道控制程序（设备驱动程序）。其中一个是打印机。打印机被评为每分钟1,100行。我的司机驾驶它，不停，每分钟1,100行。当服务工程师发现他很沮丧时 - 因为每分钟的1,100行的评级是最大，爆发速度。没有人认为有可能以这种速度不停地驱动它。幸运的是，这是一个坚实的产品，永不抱怨。  
另一个时间，我正在编写操作系统和早期微处理器的相关设备驱动程序。软盘控制器可以在每条轨道8 ms的轨道之间逐步逐步，而每一步为12 ms，而软盘驱动器每步以10 ms指定。但是，我可以通过在过渡时冲浪然后检查最终位置并在需要时发出固定步骤来踩到8毫秒。这使我们的产品更具竞争力。但是，一些软盘驱动器无法跟上。所以，我们公司刻录了驱动器。糟糕的驱动器会在一周左右烧坏。良好的驱动器会没有问题处理。这不是特定的，而是特定的品牌和型号。因此，如果该驱动程序已经在没有测试的情况下实施，则更高的性能将损坏客户的机器。  
### 回答 37
聪明的典型常被表现为混淆，故意或无意中。无论哪种方式，除非需要一些令人信服的安全目的，否则这在严重的软件项目中是不可接受的。对于可能需要在以后可能需要处理它的原件以外的程序员，软件需要可理解和可培养。  
查看此页面以查看最重要的代码的一个名称的30岁的代码示例，但永远不会在任何自尊的软件开发组织中出门或进入生产。是的，它确实完美地编译并运行。  
### 回答 38
我的经验是聪明的人在IT项目团队中令人沮丧，因为他们不想混淆其他程序员，他们将不得不维护代码。聪明的是非常规。它可能是，有些程序员读取和理解是难以读取的。这是思考。  
### 回答 39
本身的聪明并不认为是有害的。  
在说话或写作时，它有用大词。使用大词来使用大字 - 而且损害了实际理解的人 - 是一种聪明的人，即甚至在计算圈子之外的人皱眉，因为它是自我吸收的假装，忽略了其他人。  
但是那个完美的词，捕捉到你的意思，并且每个人都能理解并承认你设法的事情 - 这是你想要的那种聪明才智。  
人们去的那种哇！而不是wtf？  
### 回答 40
A2A。  
软件度量标准表明，在应用程序的使用寿命中，高达90％的代码开发成本在维护中。  
如果这是真的，那么我们在初始开发中所做的一切都必须在那里汇编维护任务。  
一个无证的'聪明'代码可能难以遵循 - 特别是如果他们不那么高度训练或（敢说）智能为原作者。  
我经常发现我在“聪明”的代码上，我写了1,3,5,10或20年前的代码只是因为我并不是新的问题并看到整个代码身体  
A2A。  
软件度量标准表明，在应用程序的使用寿命中，高达90％的代码开发成本在维护中。  
如果这是真的，那么我们在初始开发中所做的一切都必须在那里汇编维护任务。  
一个无证的'聪明'代码可能难以遵循 - 特别是如果他们不那么高度训练或（敢说）智能为原作者。  
我经常发现我在“聪明”的代码上，我写了1,3,5,10或20年前的代码，只是因为我不发布到这个问题并看到整个代码身体，就像我在开发时一样，但只有需要改变的分数。  
### 回答 41
代码巧妙与代码的可维护性之间存在成反比的关系。因此，除非存在一些极端的性能要求，除非在3或4个步骤中可以更好地为用户拼写到用户的情况下发生了什么，这可能在一步中可以巧妙地完成，在一起，您无法想到它究竟完成了什么。最好的代码是读数几乎像英语的代码，然后远离你得到的东西，难以解释......  
### 回答 42
因为在团队项目中，最重要的因素是可维护性（易于变化） - 有时甚至不仅仅是正确性。如果软件不在任何合格开发人员可以跳入并维护项目的状态，那么聪明的开发人员失败了。  
### 回答 43
编程是一种沟通行为。首先到计算机本身：您基本上给了计算机指示要做什么。但也向其他人提供：您正在描述如何为计算机提供指示。在任何软件开发中，除了快速休息以完成某些事情，您随时与其他人沟通，即使该人是您未来的自我，谁试图弄清楚一年前所做的事情。  
想象一下，别人写了芬内纳的醒目的程序相当。每个语句都有多种含义与计算机基于上下文和情绪执行它。这将是非常聪明的。所有要求他读者所要求的所有乔伊斯都是他们花了一辈子致力于他的作品。程序员预计将设置一个下巴。 （嗯，好的，除非他们是Haskell程序员:)）  
这并不是说没有你应该聪明的地方。像KNUTH-MORRIS-PRATT算法一样聪明的东西。作为将非确定性有限状态自动机转换为确定性版本的算法 - 人们在使用正则表达式时每天使用的东西。但是聪明的比特需要明确定义和记录，以便其他人可以理解它们或只是将其视为黑匣子。  
### 回答 44
我同意一些其他响应者，很容易得到聪明，只有模糊。良好的编程重点阐述了清晰度和简单性，我争辩说，可以将清晰度和简单性与良好的问题解决的人确实非常聪明。  
### 回答 45
聪明的是一个问题是一个清晰的问题。看看国际混淆C代码比赛获奖者。所有这些都是非常聪明的节目，但是对于大多数情况下，信噪比的信号偏差为噪声  
### 回答 46
聪明（或思考一个是聪明）可以引导开发人员编写难以理解的代码。那是一个罪恶。  
### 回答 47
我会同意其他答案，如果它也可以明确解释，而不是某种内幕开玩笑，那么聪明的答案很好。  
但是，我遇到了大量的经理人和愿意的经理，他们认为如果他们保持任何聪明的事情，他们就会聪明。  
他们得到了，我这么聪明的家伙看着他们的脸，然后他们开始摧毁任何可能成为一个好工具或移动信封的东西。脸上的外观是街头聪明。它基本上转换为，我没有你在谈论的内容，所以我会让你在每个人面前看起来很愚蠢，你永远不会得到那件事。我不会让你因为这是我是老板，这让你看起来太聪明了。  
所以，这就是当你在几个时几分钟内完成一些简单的节目时，人们在几个月的房间做出真正愚蠢的事情时，那就是当你的房间做出真正愚蠢的事情的时候。经理人拿到老板没有任何钱用来支付更多的钱 - 非常聪明的确！  
确实，某些程序变得不可读。但是，问题是如果可以治愈。在使用更加不懈的情况下，如异步重流，现在很常见，可能很难掌握。但是，Asynchronicity会在某种意义上拯救能源账单。然而，聪明的经理宁愿燃烧能量以避免异步。所以，聪明就在编写这些东西的程序员上放一个靴子。但是，如果你经过过去，有些人写顽皮的东西都会有各种美妙的间接广告，而有些人让它变得如此可读，你几乎没有得到棘手的事情。  
例如:(这不像我总是遇到的工作危机）C ++有模板，它是语言的一部分。用它来组织你的代码，非常酷。当你第一次进入模板的时候，它似乎很棘手，但并不是真的。所以，我有工作人员真的害怕使用模板。 （???）但我在这个地方做了。因此，我忽视了项​​目在手机上领先，谈论模板说出标题文件几乎是不可理解的。但是，幸运的是（实际上罕见），较高的询问应用程序代码看起来像什么。真的很简单 - 真的很容易阅读，易于维护。大奖是在使用模板时，因为它非常好地清理了所有商业代码。但是，直到我开展该谈话的解决方案，我以为我将被展示。 （它已经发生在这些东西上。而且，是的，这是高中辍学，他们去使用棘手的代码解雇。）  
所以，通常，评估某些东西太聪明了来自真正愚蠢的人。然而，可以（非常少数）的人做出完全不可理解的代码，没有任何好处，但窃笑本身就是厌恶的家伙。  
### 回答 48
因为由聪明的程序员写的聪明程序可能必须被一些无法理解的慢速欺骗调试。  
### 回答 49
它就像建造一座桥梁而不是遵循设计，而是引入一些聪明的想法。整个项目和所有正在进行数百任务的所有分包商都准备好并期望桥梁遵循建筑师的计划，虽然您对设计的变化是聪明的，但它抛出整个项目，因为现在没有人在同一页上。  
我曾经飞到德国来指导一个编程团队。其中一个程序员认为他很聪明，并在伟大的地方做了一些聪明的事情。然而，他们稍后造成了一百万行代码的问题，因为他没有参与这个项目的那部分，他不知道他的聪明的编程会导致线路的问题。  
### 回答 50
我工作了一段时间，伴随着一个非常聪明的舞台，称为迈克支持金融系统。他不得不写一份报告，每年运行一次，为制度中的每个政策发表声明，并在发表声明的日期后的所有正确的财务价值。  
现在这是一个简单的方法是在报告运行时获取或计算所需的所有值。  
这对迈克来说太​​简单而无聊。他决定提前动态地计算所需的所有值，并将其存储在表中。以这种方式报告运行时，它应该必须从该表中获取值。  
这非常聪明。但它意味着他的业务规则编码正在进行这些计算在系统上一直在射击。每年一年中的任何时候都会在政策上发生任何事情，他的规则会发现他报告计划是否需要的任何价值观。  
这是一个绝对的噩梦。在他的规则中为一个月或多个错误导致系统的每个单个部分都引起了失败。是的，即使是聪明的程序员也会产生错误。当你以一种方式开发你的编码在各种不可预测的情况下火灾时，你将比正常的错误变得更远。  
### 回答 51
因为向导程序员经常使用快捷方式来实现其目标，但这种快捷方式基本上是对坏（低安全性）编程的例子。  
### 回答 52
当你说聪明有害的时候，你是正确的，因为聪明的不是聪明的，聪明就像沉闷试图欺骗或偷窃并用它来造成伤害。  
这就是为什么聪明的程序员想到安全，安全是背骨，使聪明的程序员无法破解我们的代码或系统。  
谢谢  
### 回答 53
我不明白为什么聪明的人对自己的编程有害。  
就像沃伦自助餐曾经说过，如果你要雇用人，你想要他们聪明，努力工作和诚实。如果他们错过了这个属性中的一个或两个，你将会有问题（聪明但懒惰和/或不诚实只是麻烦，例如麻烦）  
另外，请记住，有些人在各行各业中考虑聪明才有害......  
### 回答 54
有很多方法可以聪明地制作难以阅读和难以维护的代码，但我的个人宠物Peeve是在表达式中遗漏括号。  
聪明的程序员认为我知道所有关于运营商优先级规则，所以生病了释放括号，然后只有像我这样的聪明人会理解这一点。  
采取一个简单的例子：  
x = a + b * c  
他是否意味着一个+（b * c），并且通过允许优先的规则来实现这一目标是聪明的？  
或者他的意思是（a + b）* c？也许他决定例如缩放所需的总和，并将* C添加为事后的事后。现在他是  
有很多方法可以聪明地制作难以阅读和难以维护的代码，但我的个人宠物Peeve是在表达式中遗漏括号。  
聪明的程序员认为我知道所有关于运营商优先级规则，所以生病了释放括号，然后只有像我这样的聪明人会理解这一点。  
采取一个简单的例子：  
x = a + b * c  
他是否意味着一个+（b * c），并且通过允许优先的规则来实现这一目标是聪明的？  
或者他的意思是（a + b）* c？也许他决定例如缩放所需的总和，并将* C添加为事后的事后。现在他试图找到这个错误。  
在逻辑表达式中，它甚至更糟糕：  
if（a && b || c &&！d && e == f | g）  
你如何阅读它并知道会发生什么？更糟糕的是，如果这些条款是职能，那么哪些叫做和在什么条件下？ （那是最终的'|'意味着||？）  
现在，有各种原因永远不会在第一位置编写代码，但试图聪明，省略括号只是复杂愚蠢。  
它的微不足道添加必要的括号来使您的意图清除，所以这样做。  
### 回答 55
在某些情况下，此声明绝对是真实的，而不是在某些情况下。让我告诉你怎么做。  
有害聪明：  
以上是一些有害聪明的例子，您使用循环/阵列/列表看起来聪明，但是有哈里米有自己的代码和编码技巧。  
有用的聪明才智：  
希望我已经回答了你的问题。  
Swayam。  
### 回答 56
在编程中的谚语：为了调试某人ELSES代码，您需要与它们一样聪明的两倍。因此，如果您尽可能聪明，您将永远不会调试*自己的*代码。  
虽然格言最初是为了鼓励彻底的文件，但也适用于聪明。首先写入清晰，简洁，易于理解代码，以可维护性最重要。如果需要，聪明（AKA优化）可以稍后来。  
### 回答 57
聪明和可读性都在争论中。在一个组织中，只有一个人了解某些软件如何工作时，这是糟糕的。  
### 回答 58
几年后，我已经看到人们无法阅读自己的聪明代码。您的代码应该是其他人最可读和可维护的。  
### 回答 59
每个人都知道，调试是首先写作课程的两倍。所以，如果你是聪明的那样，当你写它时，你将如何调试它？  
Brian Kernighan，编程风格的元素，第2版，第2章  
这就是为什么高级程序员在你的聪明代码中拍打你的头部（隐喻），这是因为有更实用的聪明风险。正如我所说，史蒂文·欧伦斯答案要努力调试两倍，就像写作代码一样？，当你编写代码时，你知道你打算什么，但是当你打算调试代码时，根据定义，代码不做你想要的东西。如果您正在调试其他人的代码，您可能不知道他们打算是什么。  
聪明本身不是一个目标，聪明就是你用来追求其他目标的工具。如果您将您的聪明才智指向清晰可理解的代码，这是一个有用的聪明才智。如果您将聪明才智引导为聪明的魅力，这是屁股的痛苦。  
经验丰富的软件开发人员经常被聪明咬伤 - 他们自己或其他人 - 对它的持态度持怀疑态度。  
聪明和优雅之间存在显着差异，或者可能更准确地说，大多数聪明都不优雅，但优雅的节目可能非常聪明，而且是由熟练和经验丰富的程序员崇拜的聪明才智。  
在编程中，优雅是程序员从数学借用或继承的术语。它与Occam的Razor的原始版本有些相关，实体不是不必要的，或者更简单的措辞，不要让事情复杂化，没有充分的理由。或者作为着名的爱因斯坦说（由Composer Roger Sessions引用或释放），一切都应该像它一样简单，但并不简单。  
在编程中，优雅意味着特定排序的巧妙，这会降低复杂性。弗雷德布鲁克斯，在他的经典书中，讨论了必要的复杂性和意外复杂之间的差异。优雅的代码在不引入意外复杂性的情况下实现必要的复杂性。  
这是一种在摘要中解释的困难概念;这是程序员经常争辩的事情。通常优雅的代码是在一种不一定是明显的方式的方式接近问题的代码，但荒谬并不意味着复杂。当您理解它时，您实现它会产生正确的（和通常复杂的）结果，通常通过更简单的元素的相互作用。  
UNIX操作系统的设计是这一原则最持久的例子之一，尽管这变得如此普遍，即这可能很难注意到它，这几天。 Git的内部是另一个例子，尽管Git的用户界面困难通常会掩盖其基础优雅。如果人们想要在与其他示例中的评论中颂扬，我将在此添加它们。  
引用自己，在另一个答案中：  
非程序员理解的最困难的事情之一是简单性更加困难，并且需要更多的工作。但它会退缩，因为代码设计中的优雅简单降低了在代码上工作的认知开销量。这导致更快，更有效的编程，更少的时间浪费在制作因不必要的复杂性引起的调试问题方面的变化或更糟糕的时间。  
Steven J Owenss回答John Byrd说好的程序员编写了良好的代码。伟大的程序员没有写代码。 Zen程序员删除代码？什么是禅宗编程？  
### 回答 60
良好软件的第一个规则：它必须是可读的。  
如果聪明的是可读性，这是一件好事。如果它困扰，那就太好了。有一个宽的中间地面，需要一些工作来了解事情的工作，但是当你得到的照片时，你会非常清楚地看到它。  
摘要：一如既往，它取决于。  
### 回答 61
这可以根据您的观察方式以多种方式解释。所以让我们在伪代码中采取一些例子。第一个例子是关于看错的事情并在错误的细节中ingrosse。有时人会优化某种东西难，只有意识到他们优化他们不需要做的事情开始才能开始。此时我可以将i-can-do-it hubris回来咬你.Consider这个作业：我需要你建立一个课程持有一堆票。每票都有优先级，我需要你给我一个在任何给定时间都有最高优先级的票。如果多个票价具有相同的最高优先级，则任何一个票证都很好。你可能会说，好的，我可以做到这一点。事实上有几种方法可以做到这一点.Let表示我们不是想成为聪明的人，但我们不知道我们的数据结构。所以我们认为我们将估计是一个很多插入和删除，我们不关心获取项目＃12或者。所以我们使用一组。（有一个数据stru更好的，我们会到达那样的。）这样的东西：  
<OL> TicketPrioritizer {Set <票证>票= New Set <>（）;公共机票提高剂AddTicket（票T）{票.ADD（T）;返回这个;公共机票提高剂addtickets（集合<票>门票）{票.Foreach（这个:: Addticket）;返回这个; Public TicketGetTiticket（）{return itstream（）.sort（比较器.Of（票式:: getPriority）.getFirst（）;}} </ OL>  
<li> TicketPrioritizer {</ li>  
<li> set <ticket>票= new set <>（）; </ Li>  
<li>票.add（t）; </ Li>  
<li>公共机票提高剂addtickets（集合<票>门票）{</ li>  
<li>门票.Foreach（这个:: addticket）; </ Li>  
<li>返回这个; </ Li>  
<li>} </ li>  
plical ticket getticket（）{</ li>  
<li>返回票票。（）</ li>  
<li> .sort（比较器.Of（票（票:: GetPriority）</ Li>  
<li> .getfirst（）; </ Li>  
<li>} </ li>  
当然，这不是很糟糕的。每件事都很容易理解。它有效。如果门票的数量相对较小，则它足够快。这远远不到你可以拥有的最糟糕的解决方案。有更好的方法它，并且有很多更糟糕的方式。当然，更好的方法是使用堆或优先级队列。（就我而言也是如此。）但如果这太慢而且你没有知道你可能会想到自己的更好：  
我们可以想象在排序时制作各种复杂的规则，使用什么排序算法（嘿，当只有一个项目不合适时，嘿，不是泡沫排序的东西？所以如果我们在插入上排序，并且只移动索引......）将这一目标合理地快速。它可能是。您将有一个调整大小的阵列，刚刚以合理的大尺寸开始，使其几乎总是在范围内，使用泡沫的插入排序，因为它快速，那么你回家，为你所做的良好工作感到骄傲，然后去睡觉。这是一个漫长的一天。在你的梦中，你看到这个小伪代码。<ol> royaltpioritizer {堆<票>门票= Heap.largestFirst（比较器.Of（票:: GetPriority））;公共空白addticket（票T）{票.DD（T）; public void addtickets（集合<票>门票）{this.tickets.addall（门票）; plical ticket getticket（）{返回票.pop（）; }} </ OL>  
<li> TicketPrioritizer {</ li>  
<li>堆<票>票= heap.largestfirst（比较器.Of（票:: GetPriority））; </ Li>  
<li> </ li>  
<li>公共voidadticket（票t）{</ li>  
<li>票.add（t）; </ Li>  
<li>公共voidadtickets（集合<票>门票）{</ li>  
<li>这个.tickets.addall（门票）; </ Li>  
plical ticket getticket（）{</ li>  
<li>返回票.pop（）; </ Li>  
<li>} </ li>  
并且嗯，它会比原始实现更快。它很可能比你的实现更大。很容易理解。如果你不知道堆是什么，你看起来，你理解一切。选择正确的抽象，使用正确的工具和编写代码做正确的事情使一切都变得更好。它很容易？不可平衡你愚蠢或愚蠢地造成这样的错误吗？No.But这是一个错误。我们一切都不时做到。  
### 回答 62
好吧，有聪明而聪明的（就像Richard Feynman的书“当然，你笑着Feynman先生：奇怪的角色冒险'意味着两个内涵意味着好奇），聪明就是意味着炫耀，或者聪明地思考事物一种新鲜和优雅的方式。  
在第一个感觉中真的不是“聪明” - 这是相当愚蠢的。  
### 回答 63
你好！  
没有世界级的开发人员认为聪明的有害本身：但基本上，每个世界一流的发展者都认为被误导的聪明才位有害。  
例如，考虑下面的两种评论：这是聪明的，这是误导的？  
<ol> // y = x /（1+（z / 100））// net = gross /（1+（速率/ 100））</ ol>  
<li> // y = x /（1+（z / 100））</ li>  
<li> // net = gross /（1+（速率/ 100））</ li>  
让我们更多地谈谈误导聪明，因为我觉得它非常重要：想象一下你有三种不同的收据，你需要确定是否只有一种类型或多于一个。 C＃和Java说，不要让你做这样的事情：  
<OL>功能发布</ ol>  
<li>函数发布</ li>  
你好！  
没有世界级的开发人员认为聪明的有害本身：但基本上，每个世界一流的发展者都认为被误导的聪明才位有害。  
例如，考虑下面的两种评论：这是聪明的，这是误导的？  
<ol> // y = x /（1+（z / 100））// net = gross /（1+（速率/ 100））</ ol>  
<li> // y = x /（1+（z / 100））</ li>  
<li> // net = gross /（1+（速率/ 100））</ li>  
让我们更多地谈谈误导聪明，因为我觉得它非常重要：想象一下你有三种不同的收据，你需要确定是否只有一种类型或多于一个。 C＃和Java说，不要让你做这样的事情：  
<ol>函数issinglereceipt：boolean;开始结果：=（salelineCount + ReturnlineCount + EnterpliClInecount）[salelineCount，returnlineCount，evertalArticLinecount];结尾; </ OL>  
<li>函数issinglereceipt：boolean; </ Li>  
<li>开始</ li>  
<li>结果：=（salelineCount + ReturneLineCount + EnterviticLineCount）在</ li>中  
<li> [salelinecount，returnlinecount，evertarticlelinecount]; </ Li>  
<li>结束; </ Li>  
因此，您必须找到另一种方式。注意，虽然上面的代码是聪明的，但在它正在做的事情以及潜在的假设是什么很清楚：即，假设是如果有单个收据，则只有一个行计数将是> 0其他两个为零。那么，我们如何做到这一点。说，C＃？  
一种误导的聪明方式是使用多个x？y：z语句，但是一个很酷的方式是linq样式代码：你创建一个列表并添加所有行计数，然后选择所有计数> 0然后计算。单个收据总是有1的计数，因此如果它的> 1，则您有多种收据类型。为什么这个聪明？首先，因为它可以很容易地延长，而不是从根本上改变它。理想情况下，您的列表可能是您传递给函数的参数，然后将其抽象更多。甚至更好，它可能是您从中填充本地列表的数组。可读性不会受损，它很好地工作。我本可以在上面的Pascal中做了类似的东西，但我认为该代码的表现非常有利于您使用列表等丢失的优势。  
两种方法的问题（Pascal和C＃One）是您无法轻易扩展到多个收据，如确定存在的收据类型（当然，您可以知道是否有多个收据而不是一个收据）。  
因此，良好的巧妙遵循以下公式：  
GC =（简洁代码+可读性+可维护性）  
正如您所知，良好的聪明才智是高度主观和上下文相关的。  
快乐编码！  
### 回答 64
我会说这取决于最终结果是什么聪明。  
有时聪明意味着实现某种黑客或解决方法，以至于您的普通程序员不会想到。也许是攻击或解决方法是必要的。或者也许它将在道路上打破申请和/或使其难以维持。  
给一个我今天看到的一个例子（在Java）......  
有用。但它正在聪明（引用故意）。虽然当我看到它时，我看到的这个词是聪明的对面。  
### 回答 65
有害聪明将是一个软件工程师，讨厌花费他已经学习不间断的空闲时间，因为成为一个程序员意味着与其他更简单的专业不同，而是将被削弱的策略一起使用，以保持他的工作就像设置一样因为失败和削减较低排名的程序员，扮演政治，做最少的最小值，并引领竞争对手。如果代码没有任何问题，那么一些纵向的高级工程师甚至连体才能解雇他们的代码。我的经历教我这是常态，努力工作担保没有，公司射击不幸的原因是足够糟糕的，但有毒的支持你会让你解雇的同事在软件世界中很常见。  
### 回答 66
一个人的聪明，是另一个人的诱导的意大利面条代码，另一个人只是普遍的恶意（当然，使用用棕榈螺栓写的正则表达式 - 有人会在20年内看到这一点，并认为这是聪明的。）。  
巧妙的代码可能会掩盖错误，肯定会在后面的后方调试和/或修改后方的正确皇家疼痛。  
### 回答 67
我发现这个问题令人困惑。它已被翻译成英文吗？对我来说聪明正在做一些我可能没有想到的事情，但是很有意义，因为它以任何数量的方式改善了代码。有害物质是以某种方式降低代码的质量。  
### 回答 68
通常聪明意味着过度设计。  
例如，程序员认为它是聪明的使用花哨的设计模式，当不是真的需要。或者在已存在开源库时从头开始代码。  
聪明的是应该避免的东西。当你真的需要的时候才聪明。这很少。  
### 回答 69
对于一些它表示危险的竞争。  
它也可能被滥用来解决这些想法。混淆是坏的。不要使用它。  
### 回答 70
聪明在编程中没有有害，它很有用，但有一个抓住。  
编程通常比预期剧烈。  
因此，这是一种最佳做法，适用于减少曝光表面的某种军事策略，并避免所有费用不必要的复杂性。  
复杂性将永远在那里，你最好关注绝对必要的。  
### 回答 71
聪明的是两件事的超集;复杂而优雅。  
令人惊讶的是简单的人，即优雅。  
优雅好，复杂糟糕。  
### 回答 72
您没有帮助任何优化的优化和短代码，只有您和上帝理解。我有12年的编程，我永远不会写一些像x =（a> b）？2：4;而不是inf（a> b）{x = 2;} else {x = 4;}。我也不会写一个箭头函数而不是foreach。  
### 回答 73
你将无法在编程中远离自己的聪明才智，也不能。如果有人认为它有害，因为他们不是那么聪明，你让他们嫉妒。追求自己的成功，不要担心别人的想法。聪明的思考有害？有人只是想让你回来。聪惜！  
### 回答 74
因为有不同的形式的聪明.True聪明的人应该隐藏你的聪明才智，而不是wtf就是这样。虽然有时候人们如此困扰着他们的模式，任何打破它们的东西都是混乱的.consider一个非常简单的代码片段：  
<OL>最终字符串resourcename; foo（string resourcename）{this.rousourceName = ResourceName} void getResource（）{PageReference Ref = PageReference .forResource（ResourceName）; blob content = ref.getcomtent（）;返回content.tostring（）; } </ OL>  
<li>最终字符串resourcename; </ Li>  
<li> foo（String ResourceName）{</ li>  
<li> this.rousourcename = Resourcename </ Li>  
<li>} </ li>  
<li> </ li>  
<li> void getresource（）{</ li>  
<Li> PageReference Ref = PageReference </ Li>  
<li> .forresource（resourcename）; </ Li>  
<li> blob content = ref.getcomtent（）; </ Li>  
<li>返回content.tostring（）; </ Li>  
<li>} </ li>  
这是相当基本的代码。没有多少空间在这里聪明，对，但是当你去写一个tes  
因为有不同的形式的聪明.True聪明的人应该隐藏你的聪明才智，而不是wtf就是这样。虽然有时候人们如此困扰着他们的模式，任何打破它们的东西都是混乱的.consider一个非常简单的代码片段：  
<OL>最终字符串resourcename; foo（string resourcename）{this.rousourceName = ResourceName} void getResource（）{PageReference Ref = PageReference .forResource（ResourceName）; blob content = ref.getcomtent（）;返回content.tostring（）; } </ OL>  
<li>最终字符串resourcename; </ Li>  
<li> foo（String ResourceName）{</ li>  
<li> this.rousourcename = Resourcename </ Li>  
<li>} </ li>  
<li> </ li>  
<li> void getresource（）{</ li>  
<Li> PageReference Ref = PageReference </ Li>  
<li> .forresource（resourcename）; </ Li>  
<li> blob content = ref.getcomtent（）; </ Li>  
<li>返回content.tostring（）; </ Li>  
<li>} </ li>  
这是相当基本的代码。没有多少空间在这里聪明，吧？但是当你去写一个测试方法时，第10行将通过一个例外，因为你不能从测试方法做出呼叫。如果你想要测试行。如果你想要测试线11你需要做严肃的体操。大多数新程序员都会说缺少一行代码覆盖是可以接受的，只是抓住异常。但是聪明的程序员将重写这一点：  
<OL>最终BLOB含量; foo（blob content）{this.Content =内容;字符串getresource（）{return content.tostring（）; } </ OL>  
<li>最终blob内容; </ Li>  
<li> foo（blob content）{</ li>  
<li>这个.Content =内容; </ Li>  
<li> </ li>  
<li>字符串getresource（）{</ li>  
<li>返回content.tostring（）; </ Li>  
<li>} </ li>  
首先，这根本没有似乎聪明。你通过一个来减少代码行。但是现在来电者需要做一些这样的事情：  
而不是简单：  
<ol> foo f = new foo（bar）; </ OL>  
<li> foo f = new foo（bar）; </ Li>  
普通程序员不会改变抱怨，但他们绝对不会像聪明一样看到它，因为不需要写下测试类。但是真正的聪明程序员要说，等待我可能需要打电话给这个地方，而且我只需要打电话给这个地方使所有测试类更复杂。所以他们写道：  
<OL>对象资源; foo（对象资源）{this.resource =资源;字符串getResource（）{if（资源instanceof pagereference）{course =（pagereference）resource.getContent（）; }如果（资源instanceof blob）{course =（blob）resource.tostring（）;返回string.valueof（资源）; } </ OL>  
<li>对象资源; </ Li>  
<li> foo（对象资源）{</ li>  
<li> this.resource =资源; </ Li>  
<li>} </ li>  
<li> </ li>  
<li>字符串getresource（）{</ li>  
<li> Resource =（PageReference）Resource.getContent（）; </ Li>  
<li> if（资源instanceof blob）{</ li>  
<li>资源=（blob）resource.tostring（）; </ Li>  
<li>返回string.valueof（资源）; </ Li>  
<li>} </ li>  
来电者现在可以使用：  
<li> foof = new foo（pagereference.forresource（'bar'））; </ Li>  
哪个不会抛出异常。您的测试CAL可以使用它的负面测试和正面测试：  
<ol> foo f = new foo（blob.valueof（测试字符串））; </ OL>  
<li> foo f = new foo（blob.valueof（测试字符串））; </ Li>  
我们有更多的代码，它不太清楚你应该为构造函数传递什么。所以这是对有害的聪明编程分类。其他程序员将刮伤他们的头脑，想知道为什么你认为这太复杂了。更糟糕的是，聪明的程序员可能会省略第11-13行，porting string.valueof将呼叫ToString，而不是意识到Saleforces实施的基本缺陷.ToString。  
### 回答 75
老实说，我已经看到了底层数学是错误的代码 - 期间 - 如一些专业知识的程序员都是数学领域有人想到像我一样拥有广泛的背景的人们创造了男性问题，然后它解决了  
我唯一可以的评论我可以真正做到，当首先将数学和物理转化为代码时，代码相对容易阅读，以了解代码如何与数学和物理相关。  
然后，如果需要，我优化 - 突然虽然计算得多，但与数学和物理学的连接变得更加模糊。  
老实说，我已经看到了底层数学的代码是错误的 - 期间 - 与一些具有很少专业知识的程序员是数学领域有人想到像我一样，像我这样的人，有一个广泛的背景知道它可以创造男性问题然后它解决了它事实是模糊的，因为如果原始程序员实施了算法 -   
还有许多聪明的方式添加到现有的面向对象的代码，这些代码快速更改功能 - 但是令人难以置信的难以跟踪 - 在过去时，我要求一项全职程序员通过代码跟踪并告诉我中间步骤发生了什么 - 它花了几个小时甚至几天。  
在使用较少线的意义上是聪明的代码可能是一个巨大的问题。  
### 回答 76
如何聪明地被认为是有害的？这完全是荒谬的！即使有些人真的相信，你的问题仍然会分开，因为你不应该对它感到任何关注。  
但是，只使用错误的表情给你一些边际，并且你实际上意味着不利（即被认为是一个缺点）。  
现在，程序员是市场上智商最高的专业人士。而这，不是因为他们的编程技能本身，而是因为他们正在努力寻找解决方案。这需要尽可能高的IQ。 IQ测试本身在寻找解决方案方面包含！  
所以，在你的地方，我不会对这种荒谬的考虑感到任何关注！  
### 回答 77
ID必须说2，Quicksort和Carmacks快速逆平方根算法：  
（我从谷歌上发现的第一个发表评论的实施中获取了这些实施，它不是我的代码，他们可能会被优化甚至包含错误.IDEALLY ID POST POST THE Java库，但这更难遵循）  
在某些情况下，有几个O（n log n）在某些情况下更好地工作，并且Mergeort是为了简单的简单性值得效益的任何微小损失，使得适应给定的问题.quicksort赢得了美容选美：  
如果这个gif没有动画，请去这里Quicksort  - 维基百科在动作中看到它。<ol>公共类Quicksort {私有int []数字;私人int号码;公共空白排序（int []值）{//检查空或空数组（值== null ||值.length == 0）{return;这个.numbers =值; number =值.Length; Quicksort（0，数字 -  1）;私有void Quicksort（Int Low，Int High）{int i = low，j =高; //从列表中间获取枢轴元件int pivot =数字[低+（高低）/ 2]; //划分为两个列表（i <= j）{//如果左侧列表中的当前值小于pivot //元素，则从左侧列表中获取下一个元素（数字[i] <pivot） {i ++; } //如果右列表中的当前值大于pivot //元素，则从右侧列表中获取下一个元素（数字[j]> pivot）{j--; } //如果我们在左列表中找到了大于//的左侧列表中的值，并且如果我们发现的右列表//小于枢轴元素的值，那么我们将交换//值。 //正如我们所做的那样，我们可以增加I和J（i <= j）{Exchange（i，j）; I ++; J--; }} //递归（低<j）quicksort（low，j）;如果（i <high）Quicksort（i，高）;私有void交换（int i，int j）{int temp = number [i];数字[i] =数字[J];数字[J] = TEMP; }} </ OL>  
<li>公共类Quicksort {</ li>  
<li>私有int []数字; </ Li>  
<li>私人int number; </ Li>  
<li> </ li>  
<li>公共空白排序（int []值）{</ li>  
<li> //检查空或空数组</ li>  
<li> if（值== null ||值.length == 0）{</ li>  
<li>回归; </ Li>  
<li>这个.numbers =值; </ Li>  
<li> number =值.Length; </ Li>  
<li> Quicksort（0，数字 -  1）; </ Li>  
<li>} </ li>  
<li> </ li>  
<li>私有空隙Quicksort（Int Low，Int High）{</ Li>  
<li> int i = low，j =高; </ Li>  
<li> //从列表中间获取枢轴元素</ li>  
<li> int pivot =数字[低+（高低）/ 2]; </ Li>  
<li> </ li>  
<li> //划分为两个列表</ li>  
<li> while（i <= j）{</ li>  
<li> //如果左侧列表中的当前值小于Pivot </ Li>  
然后，<li> //元素从左列表中获取下一个元素</ li>  
<li> while（数字[i] <pivot）{</ li>  
<li> i ++; </ Li>  
<li>} </ li>  
<li> //如果右侧列表中的当前值大于Pivot </ Li>  
然后，<li> //元素从右侧列表中获取下一个元素</ li>  
<li> while（数字[J]>枢轴）{</ li>  
<li> J--; </ Li>  
<li>} </ li>  
<li> </ li>  
<li> //，如果我们发现了大于</ li>的左侧列表中的值  
<li> //枢轴元素，如果我们发现了右侧列表中的值</ li>  
<li> //小于枢轴元素，然后我们交换</ li>  
<li> //值。  
### 回答 78
因此，OOP迫使您提出完全出现的问题，因为有人决定  
我真的很喜欢布鲁斯理查森把它的方式：  
没有人切片面包认为他们发送了一条消息告诉刀子切割面包或告诉面包被切片  
OOP是关于在您允许使用您的语言的方式上施加一些尴尬的约束。也许在某些情况下它有意义，但在大多数情况下它没有。如果OOP是关于将某些动作带到某些对象，那么如果有人想要执行设计师未预期的一些操作，则会出现问题。  
因此，OOP迫使您提出解决问题的问题，因为有人决定在项目中使用OOP的约束，那么这种方法属于哪个类？ （哦，我知道我应该创建一个控制器类）。  
我相信唯一一个实际尺度的方法正试图表达你的问题的方式，而不是事先施加一些任意和人工限制。解决可能避免的问题只是浪费时间。  
（另一方面，我认为学习许多不同风格的思维也很重要，包括OOP）  
### 回答 79
这取决于它是如何使用的。 Scanf（）可能是有害的或坏的，如果说，有人这样做的事情：  
<ol> char * string1 =（char *）malloc（8 * sizeof（char）+1）; scanf（％s，string1）; </ OL>  
<li> char * string1 =（char *）malloc（8 * sizeof（char）+1）; </ Li>  
<li> </ li>  
<li> scanf（％s，string1）; </ Li>  
以上是精细的*除了*如果STDIN输入字符串长于8个字符，则在哪种情况下，您将有缓冲区溢出。  
我建议一个使用getline（），然后使用sscanf（）来解析getline（）的字符缓冲区。看，例如。 ：  
<ol> char * buffer = null; size_t sz = 0; getLine（＆buffer，＆sz，stdin）; int a，b，c; SSCANF（缓冲液，％d％d％d，＆a，＆b，＆c）; ...免费（缓冲区）; </ OL>  
<li> char * buffer = null; </ Li>  
<li> size_t sz = 0; </ Li>  
<li> getline（＆buffer，sz，stdin）; </ Li>  
<li> int a，b，c; </ Li>  
<li> sscanf（缓冲液，％d％d％d，＆a，＆b，＆c）; </ Li>  
<li> ... </ li>  
<li> </ li>  
<li>免费（缓冲区）; </ Li>  
getline（）上面的参数*将自动  
这取决于它是如何使用的。 Scanf（）可能是有害的或坏的，如果说，有人这样做的事情：  
<ol> char * string1 =（char *）malloc（8 * sizeof（char）+1）; scanf（％s，string1）; </ OL>  
<li> char * string1 =（char *）malloc（8 * sizeof（char）+1）; </ Li>  
<li> </ li>  
<li> scanf（％s，string1）; </ Li>  
以上是精细的*除了*如果STDIN输入字符串长于8个字符，则在哪种情况下，您将有缓冲区溢出。  
我建议一个使用getline（），然后使用sscanf（）来解析getline（）的字符缓冲区。看，例如。 ：  
<ol> char * buffer = null; size_t sz = 0; getLine（＆buffer，＆sz，stdin）; int a，b，c; SSCANF（缓冲液，％d％d％d，＆a，＆b，＆c）; ...免费（缓冲区）; </ OL>  
<li> char * buffer = null; </ Li>  
<li> size_t sz = 0; </ Li>  
<li> getline（＆buffer，sz，stdin）; </ Li>  
<li> int a，b，c; </ Li>  
<li> sscanf（缓冲液，％d％d％d，＆a，＆b，＆c）; </ Li>  
<li> ... </ li>  
<li> </ li>  
<li>免费（缓冲区）; </ Li>  
getLine（）具有上述参数*将自动分配*足以容纳从文件指针读取的任何用户类型或任何读取的缓冲区。请注意，您必须最终释放（）生成的分配缓冲区。  
甚至更好的是getline（）是C标准库的正式一部分（**见下文），IIRC，它在stdio.h中定义。它最初是GNU GCC扩展，但作为POSix.1-2008规范的一部分标准化（参见：开放组基本规范第7，2018年版）。  
希望这可以帮助…  
**注意：正如本答案的评论所指出的那样，GetLine实际上是* ANSI或ISO C标准下的C标准库的一部分。但是，如果相关的C执行符合POSIX SPEC W.R.T，则它*是* C标准库的一部分。到处理C标准库函数和标题文件的POSIX规范的一部分，哪些GCC和其他编译器都已进行。  
编辑＃1：只是一个注释，但是，我建议检查getline（）的返回值，以查看是否已达到输入结束，例如。 ：  
<ol> if（getline（＆buther，sz，stdin）！= -1）{... </ ol>  
<li> if（getline（＆butfer，sz，stdin）！= -1）{</ li>  
此外，对于SSCANF，还建议检查返回值以查看用户是否输入所需的文本。在上面的例子中，人们可能会做：  
<OL> IF（SSCANF（缓冲器，％D％D％D，＆A，＆B，＆C）== 3）{... </ OL>  
<li> if（sscanf（缓冲区，％d％d％d，＆a，＆b，＆c）== 3）{</ li>  
<li> ... </ li>  
编辑＃1：感谢Armand Klein建议编辑纠正拼写错误:)  
编辑＃2：保罗评论了getline（）不是ANSI或ISO C标准的一部分。从技术上讲，这在Getline（）和getDelim（）不是ANSI或ISO C标准的一部分中都是正确的。但是，它们是POSIX标准的一部分，如果它是POSIX兼容的任何符合C系统，其中包括GCC和其他C编译器。至于微软的VC，̶虽然MSVC̶d̶o̶e̶s̶n̶'̶t̶，̶IIRC，̶实现所有POSIX标准̶w̶.̶r̶.̶t̶.̶C标准库，̶它，̶IIRC，̶实现大部分POSIX基地C标准库函数[1]注意，我可以是不正确的，我不使用MSVC̶：̶）̶  
有关POSIX支持的标题和标准库功能的列表，请查看以下：转到“开放组”基本规范文章7，2018 Edition和导航到页面左下方，然后单击13.标题。接下来，单击<stdio.h>，您将看到getline（）和getdelim（）在那里。  
我不同意便携式getline（）函数将被打破。所有需要修改的都将处理EOL分隔符和EOF / ef-exp-of INCUP情况。我会写一个例子，但Web上有很多示例，例如。这个：ivanrad / getline。  
### 回答 80
在旧的简单8比特处理器上，这种事情经常出现。我们将指令的周期计入一定时间的时间。当我在高中时，我被一个为人们提出了早期通信系统的人雇用了轮椅具有各种问题，如四十令吉，严重的讲话问题。这种系统之一是为特定的个人设计的，除非先前的设计工作 - 虽然是罕见的。我们有一个人无法谈话，但可以碰到他的人朝着他的轮椅后面抬头。那些只能制作五个独特的声音，这是一个咕噜声，哼着一些不同的频率，并且一条短暂的吹过他的鼻子，但根本没有运动，即使是他的头脑。我的头脑甚至是他的头脑对他们所有人都是因为他们是完全能够思考简单地沟通的聪明人。这是在1986年，所以我们认为理所当然的椅子和眼睛跟踪系统，围绕着。硬件背后的男人是al弗雷多·洛佩兹虽然我做了这个软件。系统的核心是一个C64运行MOS 6510.we创建了一个菜单系统，即使它们可以做一个单一重复运动，诸如头部凹凸，也可以进行导航。主菜单，一个凹凸会向下移动一条线并继续向下移动，直到在特定时间内没有凹凸。然后下一个凹凸将以相同的方式向右移动，直到菜单选择在制作中。然后缺席一个凹凸会选择那个选择。这可能是我脱水的东西，或者你可能是你的东西。这将导致另一个菜单选择问题的下半场。如果他们能够超过一个运动导航变得更加容易，因为一个运动可能会失败，另一个右手等待选项很快就是很快.Alfredo制造了一个有一个轮子的小装置可以探测轮子移动的方式，这将允许它们呼气或者通过设备吸入，给它们两个wa ys移动（现在称为吮吸吹风装置）。我们有可能使用三个手指的弦乐，给他们7种不同的按钮组合来制作选择。您可以在这里阅读更多关于它们的信息：可访问性艾滋病的类型是开创性的虽然我们做了很多很多声音识别系统。在这一个，各种声音可以选择整个菜单或选择，具体取决于他们可以重复制作的声音数量。这不是语音识别它只是捕获了一个波形，然后比较它学会了一个。如果他们可以制作五个声音，每个菜单都有五个条目，这是导航的好方法。这些设备依赖于事件的时间，事件序列，事件序列之间暂停。C64只有可以从几个不同的源（VIC-II，CIA等）触发的单个中断，但它们都没有太稳定。标准的IRQ常规确实维持了一个JIFFY时钟，但由于IRQ被关闭了原因，它也没有准确。实现适当时序的最简单方法是在每个例程中计算周期，并确切地知道一切需要的一切毫秒。若需要在C64的应用中，我们没有必要键盘，光标等所以我们可以完全接管硬件。我们不得不将时间同步到每个人的人，具体取决于他们可以碰到触发的速度有多快，做吸气，使声音等出现在一些非常独特的设备上，以允许一些基本的输入，其中许多人都是基于在一个运动中，事件之间的时间是输入最重要的部分。他想让这些人能够尽可能少地收取这些人以便让这些人因为这不是他的真正的工作，他被指控他们只花了什么。这给了他们自己的独特硬件特征。我在右手侧的C64上做了这么多的装配我，我写了每条指令所花费的循环所以我可以维持pr Oper Siming.i实际上是通过心脏6510上的每个循环计数，即使它越过页面边界。我多次重写代码，并且非常奇怪地，有时候，不仅在某个伯爵下方而且完全在某种程度上得到了常规。  
### 回答 81
在另一边，想象一下你的商店  
只读数据结构和存储。  
这是通过功能编程的启发，该功能的函数应该没有副作用。想象一下，您有用户像用户之间的相关关系。您可以将此关系与表存储（User1，User2）元组进行模拟，但是当一个用户联合另一个用户时，您需要删除一行，或更新它并将其销标更新并重新销标。这带来了更改索引的许多问题，而朋友（Usera）的结果不是修复的，它会随着时间而改变，因此您无法正确缓存。  
在另一边，想象一下，在事件表（User1，Action，User2，Time）中，您将获得合作和不友好的事件，然后您永远不需要删除或更新行，您的表仅是读/写的，这允许许多优化。而您的所有功能都成为时间的函数：朋友（Usera，何时）将始终将相同的列表返回到相同的函数参数，这是一个非常有趣的属性。你可以回到过去的任何时间。您可以每天缓存函数的结果，并使用较短而更热的friend_diff（usera，day），只返回当天的合作修改。  
另一个优点：这种模拟数据的方式使单元测试更容易。  
不无关：如果GIT版本控制工具这些天会收到如此多的关注，它是因为它也是仅仅是一个读/写的文件系统（几乎），因此比其他解决方案更可靠。  
### 回答 82
有时，只有在阅读它的人相比，代码只是聪明。  
在我的第一份工作，我们正在使用批量模式（JCL）的COBOL。程序基本上是数据库转换脚本，用于从IDMS迁移到DB2。我们每周都有一周的里程碑，每个星期五都有一个脚本。人们通常会在星期一开始跳跃于周末收到的规格。一半测试/越野码代码（〜1200行）将于周五深夜为QA提供。  
我不会在星期二中午开始编码，并将在周三晚上完成我的约400行脚本。然后在周五晚上送货前彻底测试。我在星期二中午到达了规格分析，我将分析不一致，死者区域（从未由于之前的支票等而永远发生的条件），并从客户业务分析师寻求澄清。这就是我在只有400行开始做的是1200行的方式。经过一段时间，我观察了一些重复的模式，为此创建了一个模块，除了附加的模块之外，我的后续代码只有200行长（一个用于常见的变量，另一个用于常见程序）。我还开始在周三中午完成我的工作，因为测试要求现在也减少了。  
我是我团队中最不经验丰富的程序员（这是我的第一份工作），也没有其他任何想法模块化代码。当我的PM要求每个人开始使用我的模块时，他们抱怨他们的要求是不同的。当显示出这样的情况下，他们实际上可以通过参数来定制模块的功能，他们称之为一些聪明的代码，他们不明白，并拒绝使用它，因为它会违反它们的流量。  
我同意。 :)  
### 回答 83
我将从有点不同的角度添加一些。  
### 回答 84
我实际上回来了，重新读到了尼克劳斯Wirth的原始信，CACM的编辑题为案件反对转到陈述。  
继承人我的想法：  
我一直在编程近40年。  
有没有转到的情况（或JMP或等效物）是不可避免的。你是<这里>你，你是由于一些国家相对条件需要停止你的做和在那里>，就像现在一样。繁荣。完毕。  
dijkstras争论仍然持有水：程序的执行环境越复杂，我们无法理解内部状态，并管理执行转换或  
我实际上回来了，重新读到了尼克劳斯Wirth的原始信，CACM的编辑题为案件反对转到陈述。  
继承人我的想法：  
我一直在编程近40年。  
有没有转到的情况（或JMP或等效物）是不可避免的。你是<这里>你，你是由于一些国家相对条件需要停止你的做和在那里>，就像现在一样。繁荣。完毕。  
dijkstras争论仍然持有水：程序的执行环境越复杂，我们就越少，我们就会推理内部状态，并在没有鲁木上他妈的事物的执行顺序管理过渡。案例在点：即时在执行过程调用的中间，突然有一个转到的转移，使我将我的程序射击到主要程序的另一部分。堆栈如何进行清理？或者有谁知道有一个需要进行清理的堆栈，或需要恢复的预呼叫寄存器状态？  
简短的答案，不可能。您将程序计数器从X转移到Y，并将其究竟要做你告诉它的事情。因为那是什么CPU所做的。  
继承人的上行：甚至写裸机代码（没有操作系统，或者控制系统，或者测试代码来验证新的CPU），我很少使用goto。 40年来，也许十几次，一旦我觉得我认为自己有能力。  
但是每一次，都是绝对要求。满足程序被设计为提供的性能和功能的唯一方法。  
这些天，具有先进的功能规划语言和状态重面向对象的框架，如果大多数练习程序员甚至知道到底甚至想到的是那么糟糕的是，它都会感到惊讶的是，为什么它被认为是坏事;它刚刚没有教过，而且没有学到。  
但是对于那些想要使用它的人来说，阅读论文。 （它只向编辑索赔是一封信，它真的是一篇论文）。并认为你要做什么是难以理解的。  
### 回答 85
我以类似的静脉解释这个问题，好像有人要问的是在现实生活中真正有用的微积分，那么我在我的日常工作中没有任何规律性。  
解释如此，我相信答案还没有，但可能需要一段时间。  
首先，为什么不呢？  
其次，为什么还没有。  
最后，为什么这可能需要一段时间  
也就是说，有些编程职业中的工作，其工作将导致编程后门访问强大而优雅的图书馆，SDK和平台，希望很快！  
### 回答 86
一个重要的原因是需要解决的许多问题是根本性的。如果可以在屏幕或两种代码中完成实际工作的整个实际工作，则理想的语言是保持核心代码可读的，并为其添加很少的样板。  
实际上，很多工作都归结为处理一些文本来生成更多文本（也许读/写/更新数据库某处）。使用PHP和Java作为示例，PHP中的那些事物更容易做出更容易 - 它知道您通常需要打印到STDOUT，因此打印会这样做。它知道您经常想将变量放入文本中，以便琐碎（打印嗨，$名称;）。它知道您经常需要HTTP变量（GET，POST，COOKIES），因此很容易到达。  
Java可以做所有这些事情，但它的写作可以解决更大的问题 - 所以它没有默认输出（你需要使用例如system.out.println），它没有字符串中变量的任何特殊语法（所以你使用string.format或stringBuilder），并掌握帖子/ get / cookie完全取决于您使用的库/框架。  
它们之间的复杂性/灵活性权衡：PHP使简单的东西变得简单，难以更加困难。 Java繁重的简单事物，但很难做到。如果您实际上需要能够重用或替换项目的部分，或者它足以难以阅读，而无需一些深思熟虑的结构 - 或者您需要Java标准库中存在的许多有用和复杂的内容作为第三方，然后Java是一种更好的选择。  
但是，如果您构建了谁来到圣诞派对登记表格，写作和部署PHP版本可能会花费更少的时间，而不是为Java版本设置Web框架，从而实际地写作它。  
