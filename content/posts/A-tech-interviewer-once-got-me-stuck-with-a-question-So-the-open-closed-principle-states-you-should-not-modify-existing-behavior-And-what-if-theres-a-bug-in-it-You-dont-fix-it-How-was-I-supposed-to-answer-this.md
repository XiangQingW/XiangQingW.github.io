---

title: 一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？
date: 2022-01-23T22:08:11+08:00

---




## 一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？  
### 回答 1
我不喜欢这个想法，除非物体中的一切都是公开的，或者仅受保护，而不是私人。  
如果是的话，因此您可以使用扩展来修复错误。当然，这具有利用相同对象的人的副作用，必须继续与错误一起生活。  
这意味着在实践中的原理意味着拧紧其他人，只要它适合我。  
否则，如果有真正的私有部分，原则要求您与错误一起生活。这是无法接受的。  
### 回答 2
这一原则是为了确保在其行为中可预测的共同特征，并且不会因个人要求而被操纵  
是的，这是一个伎俩问题。面试官可能正在检查您在坚实的“开放式”原则上的理解程度。  
“开放式”原则表示，实体应该开放到扩展，但关闭到修改。这意味着您可以使用代码中的功能/库方法，以扩展该功能已在做的内容。但您应该避免将/添加代码更改为共享库方法本身，以满足您的特定要求。  
这一原则是确保在其行为中可预测的共同特征，并且不会因其消费者的个人要求而被操纵。它有助于减少添加到共享方法的错误变化的广泛副作用。  
如果在常用函数中存在缺陷影响其消费者，则可以更改常见实体以解决问题。 “关闭”部分原则不是在行为不端时未修复功能本身。但是，在修改代码以解决问题之前，开发人员需要确保它实际上是常见功能的问题，而不仅仅是在特定扩展中使用它的错误使用。  
### 回答 3
不，这是荒谬的。  
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。  
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。  
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。  
这是否意味着，如果接线出现问题，那就是错误的  
不，这是荒谬的。  
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。  
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。  
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。  
这是否意味着，如果电机可以解决问题会出现问题，这将是错误的修复它？当然不是。这些是两个单独的问题 - 一个关于系统的适当设计理念，另一个关于有价值的特征的实际交付。  
所以它与所有的固体原则有关。您通常应该避免用许多职责写作方法。给定类的目的应该是连贯的，具体的尽可能具体。您的所有子类通常都应该替代他们的父类。等等。  
所以情况是开放式原理。如果我构建包含一堆计算器功能的库，我不应该假设使用我的图书馆的程序员将要挖掘我的代码并更改乘法函数的方式。它应该是一个黑匣子。他们可以有利于阅读我的源代码并知道它如何出于性能原因或某种东西的工作原理，但原则上，他们唯一需要知道的是他们可以呼叫繁殖（4,2），它将返回8。它们不应该或必要的是，他们改变这个功能。  
但作为这个库的维护者，如果乘法不正常工作，或者我弄清楚更有效的方法来实现它，当然我可以做到这一点。修复代码中的错误是接口设计完全分开的问题。  
我不知道面试官正在寻找什么，但这是我给予的答案。  
更普遍  
工程不是以下规则和检查清单的问题。这是关于批判性地思考你的设计决策。什么是权衡？有什么风险？坚实的原则，敏捷的做法，所有这些东西 - 他们是由资深工程师学到的准则，艰难的方式和与较大的社区共享，但这就是他们所在的 - 指导方针。它们并不总是适用于您的用例。如果在任何时候某些思想或标准练习似乎是愚蠢的工程，那么就不要在那种情况下使用它。只需确保您了解为什么您为规则发出异常。如果我在面试的人，那些证明他们都理解规则和何时制造一个例外，他们就会从我这里得到一个竖起大拇指。  
谢谢你的A2A VSVH1NH83Z。  
### 回答 4
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。  
首先让我们看看开放式原则是什么：  
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。  
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。  
我将会  
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。  
首先让我们看看开放式原则是什么：  
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。  
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。  
我还会注意到这一原则太自由地说，事情应该是开放的延期。不应遗传未明确设计的类别。  
关闭部分的开放式原理意味着在大型软件系统中，您通常不会在每次要为特定用例添加新功能时修改现有类（其他代码可能依赖）。  
所以，如果我们需要添加一个支持的函数，该函数只有我拥有的一些用例，我不应该将其添加到每个人的导入中的一般模块;相反，我应该将其写成我自己的模块，如果需要，将常规导入常规模块。同样对于一个类：我不应该混乱一类泛型类，每个人都使用了一些特定于我的用例的额外功能 - 在做出任何已经取决于类的所有代码都会进行风险。我应该创建一个用于我用例的新类，如果需要，在我的实现中利用现有类（通过构成或继承）。这样，没有人已经依赖改变，我的变化只会影响我。  
如果您确定此类用户的所有用户（大概是，错误修复只需确保满足某些已经承诺的合同，则可以完全修复一个错误即使开放式原理技术上告诉你，你仍然可以随意为现有类添加方法（假设您能够这样做）如果它真的适用于所有类的用户，您可以保证您的所有现有用户都是正确的默认实现。  
开放式原则是一个建议而不是一个艰难的规则。不要让它妨碍写好的代码。  
### 回答 5
现在假设第4页，我们看到第十几次上市的租户，但这里是l  
想到法律合同。  
可以是什么，但让我们说租赁协议。这是应关闭的东西，以修改（除非各方当然同意）。假设合同有少数目标：  
漂亮的标准东西。显然，5个子弹不是完整的合同，但与我忍受。  
现在假设第4页，我们看到第十次上市的租户，但它将其列为Alice和Bbo。我们可以由于印刷错误而改变该合同吗？当然我们想这样做。我不是律师，所以这可能需要每个人或一个重新签名或其他什么，但我们确实想要修改问题。  
修改不会影响合同或其消费者。  
这就是错误修复相似之处的地方。如果我们有一个课程关闭修改，其工作是提供一名员工，但我们有一个错误，即使是最近的公司假期的错误，那么雇员被雇用，这不是公司假期......是的，解决这个问题。  
因为我们没有修改这一课程的合同，以便与消费者保持维持，我们确保合同遵循合同。  
就像爱丽丝和鲍勃一样，我们并没有表明一些神秘的第三方BBO是专门对没有宠物的责任，但是鲍勃正在休息的困境中，我们确保该单位的一切都与鲍勃有关。  
您可以争辩说代码甚至没有完成。  
考虑测试驱动的发展一会儿，如红绿或平躺式编码。  
我们有一个将向扩展开放的课程，但关闭修改。我们编写了一个故障测试，我们编写代码以使其通过。我们继续编写更广泛，更接近边缘案例测试，并继续以这样的方式实现代码来传递所有测试用例，因此所有使用情况。  
好吧，如果我们错过了测试/用例，我们是否真的正确地完成了代码？纪念的合同从未完全写过，所以从一定的角度来看，我们正在完成工作，而不是修改代码。  
很多方法来看这一点，但是当那样的问题弹出时，肯定会看看校长是什么 - 确保代码的消费者不会意外爆炸，在那里，在这种情况下。当我们想要一个int时，不要返回颜色字符串，因为任何人称该方法都会破坏，那就是一般目标。  
### 回答 6
开孔原理意味着打开扩展，关闭以改变。如果您愿意，您仍然可以子类（派生）来改变行为。这是多态性的整个点。  
如果您的派生对象堕落（表现差），您可能会归咎于LISKOV替换原则（LSP）  
如果是一个错误，你当然修复它。除非修复它会导致更多问题。  
我的答案是：理想情况下，我的对象将没有错误，因为有足够的测试覆盖率来确保正确的行为。但是如果发现错误，ID希望尽快修复它，根据需要更新单元测试，因此问题不会重新出现。离开这个错误会创造技术债务并将可以击倒其他开发商的路。唯一的id留下一个错误是如果修复它会破坏其他东西，或者科技领域认为它不值得的时间。  
### 回答 7
开放的封闭原则是废话作为原则，如：  
没有人应该撒谎。  
从这里阅读：  
### 回答 8
这真的取决于错误是什么。有几类不同的错误：  
尤其可以由客户使用＃3和＃4，如果改变行为，它们可能是不满意的。 ＃1几乎肯定应该是固定的。 ＃2可以辩论，有人用吗？如果是这样，后果是什么？ ＃5肯定可以更改，除非功能的时间确实指定为代码的功能描述的一部分  
开放式原则的一般原则是您不会更改现有行为，但您可以为接口添加其他功能。这并不意味着，如果代码在某人使用该软件的情况下，如果某人不打算使用的方式，则不应修复实际的真实错误 - 那么这绝对不是突破现有功能（它从未首先工作过）。同样，优化可以并且应该完成，其中内部行为可能会改变，但只有所花费的时间将从外部视图改变。  
人们做（MIS）有时使用功能。在Linux中，如果您有一个指向内存的指针，并且以字节为单位，并且要检查该指针是否确实有效并且内存是可读的，则可以调用Write（-1，指针，大小） - 因为操作系统将首先检查它可以进行指针+ +大小的有效副本，然后检查文件描述符（-1）并返回文件描述符无效的错误。 errno将在文件描述符与内存复制失败之间存在不同。这显然不会在它的意图中使用该功能，但预计将继续这样工作。  
### 回答 9
错误不是现有行为的特征;因此，如果修改它以修复不正确的行为，则不会修改现有行为  
### 回答 10
那是假设OOP  - 我没有。我必须先看到代码。（只要您展示您了解问题的参数，应该满足一个良好的面试官。[大多数猎头者不是非常科技的，所以他可能想要他在他的书中拥有的答案 - 谁知道这可能是什么？这是我认为我会把我的事业带给一个真正了解的人的问题。（我已经进行了技术面试 - 我永远不会问一个这样的问题。）]）  
### 回答 11
您肯定会在此时按照预期的方式记录行为 - 这很重要，尤其是*在这种情况下，它不是预期的。  
将更改此行为以更具逻辑/理智的方式，将计划为未成年人或重大释放，以至于消费者可以在预期行为中处理其变更以协商其变更。  
### 回答 12
招牌  
我认为有两种方法可以接近这个问题。  
问题可以简单地询问态度的冲突：该实体已关闭修改，但我们需要修改它以修复错误。如果是这样的话，那么我们当然会修复错误，如果实用。开放式原则是关于没有改变实体的行为在没有改变实体的意义上。通过修复一个实施错误，我们并没有违反开放式原则，因为错误的合同破坏或有害行为，从错误的代码结果不是模块所做的那样的一部分。  
除非是！这种问题可以接近的第二种方式是在将意外行为的演变中纳入对象的使用。如果客户端代码取决于窃听行为，那么在某种意义上，用户已重新定义模块的合同并修复错误将更改该模块所做的内容。因此，开放式原则与错误修复相关。  
### 回答 13
这是一个务实的软件设计和（更重要的）维护问题。  
即使有完整的测试，应用任何有意义的大小和复杂性的应用是非常罕见的。  
这是需要有机测试的位置：在实践中，使用足够复杂的应用程序，您无法编写测试并执行它们以验证并记录100％输入 - >输出以定义正确的内容：测试套件设计需要优先考虑什么最重要的是知道有效和h ...  
### 回答 14
来自#cleancode视图，错误意味着，行为不对，因此在正确的地方修复它。  
修复错误或回归不是关于更改或添加新行为，请确保使用正确的代码放置正确的行为。很值得这种原因，如果错误是依赖的开源组件，则始终建议向组件所有者报告（即包括OpenSource供应商）。  
更改行为意味着，假设方法是否正在执行乘法，现在您也希望允许它添加（编码练习不好），然后它为现有乘法添加新行为。当乘法中存在错误时，修复该乘法方法是强制性的，因为不适用开放式原理。  
在这种情况下，关闭的是，方法名称，应该不会改变，因为有些人可能正在使用它（如果乘法方法是非最终的公共或接口方法），如果有任何喜欢'添加'也，他可以继承这个父类，并做任何他想做的事情，以便多态可以开始工作。  
因此，出于这个原因，开放/关闭的主要少数作者称为多态性开放/关闭原则。  
### 回答 15
如果错误不支持新要求（您的Blackjack G  
开放式原理是指将功能添加到已完成的类。  
完成的类是一个类的类，其中创建了类时的所有行为是由测试涵盖的，并且所有这些测试都通过它。  
如果此bug是在类的预期行为中（例如，未正确处理空中传递到函数）而不是暗中隐藏新功能时，则表示课程未完成，您可以精细添加更多测试到现有类，并修复了错误。  
如果错误不支持新的要求（您的Blackjack游戏不处理Uno卡），那么您应该按照OCP遵循并将新功能作为现有类的扩展实现。  
请注意，即使在第二种情况下，也可能不会避免更改原始类至少一点点。  
因此，开放的原则通常不是一项规则，即您不允许更改现有行为，而是通过期望通过编写新代码添加功能的期望来设计您的课程，只有现有代码所需的最小更改，  
### 回答 16
你首先说这是一个设计原则，而不是自然的法则。与所有设计原则一样，其应用是设计权衡和判断呼叫的问题。  
然后我会讨论开放/关闭的原则实际上是什么，并与利斯沃替代原则进行比较和对比，人们经常与开放/关闭原则混淆。  
### 回答 17
我怀疑这是关于货物邪教编程危险的问题。非常重要的是要理解，应该理解开放的封闭原理等原则，并不盲目地遵循。  
### 回答 18
如果bug是'  
问题需要更多的错误定义。有人报告了代码的问题吗？你在做另一个修改时发现了吗？你在做另一个修改时创建它吗？开放式原则状态，您不会返回并无缘无故地更改界面。相反，您扩展了功能。如果您发现您认为的错误，那么您将与团队的其余部分讨论。如果它是一个报告的错误，那么你可以以不打破其他代码的方式修复它。如果有单元测试，则会查看为什么单位测试不涵盖此条件。  
如果错误不会导致问题，最好记录并单独留下它。有些用户可能会对该行为进行计数。它还取决于谁使用此代码。如果它只是内部使用，那么虽然原则适用于此可能不是那么相关。如果有成千上万的人使用它，那么避免打破界面很聪明。  
根据这些答案的一个选项是创建一个没有BUG的第二个API调用，以便使用两个路径。随着时间的推移，可以将人们迁移到新的API，并最终将其中退出其中的错误。  
### 回答 19
纠正  
所有设计原则都不重要而不是正确性。程序的第一个属性是做正确的事情。优雅地做得很好，但不太重要。  
如果错误需要修复（而不是推迟或被接受为限制），那么您可以在世界上所有权利打破现有的设计来解决它。不是你应该或大部分时间，但是它是允许的。  
更重要的是要确保飞机不会崩溃，而不是允许飞机崩溃，但在代码中具有更美丽的设计。  
无论如何，大多数错误都不是设计  
涉及  
纠正  
所有设计原则都不重要而不是正确性。程序的第一个属性是做正确的事情。优雅地做得很好，但不太重要。  
如果错误需要修复（而不是推迟或被接受为限制），那么您可以在世界上所有权利打破现有的设计来解决它。不是你应该或大部分时间，但是它是允许的。  
更重要的是要确保飞机不会崩溃，而不是允许飞机崩溃，但在代码中具有更美丽的设计。  
无论如何，大多数错误都不是设计  
与开放式/关闭原则有关。  
也许您可以看到您的错误修复，如扩展或不同的功能来开发和与现有代码相结合。并保持设计原则很好。所以要做。  
也许您可以将错误视为给定的代码无法实现其当前合同。然后，如果修改代码以使其遵守，您实际上没有执行任何修改或扩展。您更正了代码，以便实现实际上符合合同。太棒了。你没有违反任何原则。  
也许当前的设计不再适合，并且需要重构。然后你做这个重构（见下一个点）  
重构整个东西完全有效  
设计的伟大原则适用于给定的时间点。目标是确保代码易于理解，维护和发展。所以人们可以检查代码，阅读它，了解它。  
代码的版本1遵守原则：伟大。 v2坚持原则：伟大。设计变化了吗？没关系。  
我们不在乎代码更改时发生了什么。最有可能在某些计算机上崩溃的一点，没有编译。没人关心。只要您能够生成体面的v2，您就像开发人员一样。  
如果v2更改设计，这就是我们称之为重构的东西。  
案件是案件  
大多数错误将被拒绝，因为软件实际上已经表现得很好。有些人需要小变化，其他可能需要完整的重写（希望不经常）。你将在两者之间拥有一切。  
通常可以解决几种解决方案。即使有些人比其他人更加明显，它实际上存在无限数量。  
它是您工作的一部分，作为开发人员选择一个体面的人来修复错误并使其工作。  
### 回答 20
如果您了解原则或者只是记住定义，这是一个诀窍的问题。  
开放式原则并不意味着我们不会改变代码。  
它意味着对象之外的代码永远不会修改对象的内部行为，但可以扩展它。在JavaScript中，任何代码都可以更改对象属性，即使是原型。这不好。在运行时的任何点处，可以通过任何任意代码更改对象行为。因此，为什么创建符号类型，以隐藏对象属性。  
ID答案，这不是开放式原理的意思。你修复了错误。  
### 回答 21
好吧，我们的意思是什么？修复我们的意思是什么？一些错误可能需要修复，如安全漏洞。否则，假设现有功能正在运行，那么您可能会理想地想要提供某种扩展或备用功能来解决新功能。通过生成包装器来说，您可以通过几种方式执行此操作（即您可以在不同的类中添加新功能，然后通过组合创建一个结合旧的和新的Foreface。您可以简单地提供一个新的并行API，任何需要新功能使用而不是旧API，或者除此之外（仅适用于新的东西）等。  
如今，很多这类东西最终有关Web服务。在那里有更大的灵活性，因为新的和旧的东西可以在不同的端点中共存。所以，/v2.0/ url路径可以做任何它想要的，而旧的/v1.0 /仍然存在于需要它的人那里。也许你最终会弃用它，无论如何。  
### 回答 22
最常见的候选人问我是白板代码是否必须是错误的。这个问题往往是伴随着这个建议，这只是刚刚真实。inded，它往往没有。避免返回。重要的是错误的代码在现实世界中？你可能发现它有点难以回答这个问题.bugs永远不会好。所有其他都是平等的，你更喜欢错误的错误代码。但是一只错误一般都会让你解雇。如果它确实有一个错误，那么我们都没有乔布斯。在采访中，理想显然没有Bugs.bugs永远不可能;显然，你的面试官更喜欢看到更少的错误。这并不意味着你会因为有一个错误而被拒绝。你修复它。错误指示  
您的代码是您的代码示例，您的采访者从中推断有关您的编码技能的信息。正常性并不重要，它本身并不重要。如此：  
<ol> linkedlist <string> list = new linkedlist <string>（）; list.insert（你好）; </ OL>  
<li> linkedlist <string> list = new linkedlist <string>（）; </ Li>  
<li> list.insert（你好）; </ Li>  
这段代码有一个大错误，它将100％break编译。在第2行，你应该写的添加，不是插入。如果您发布了此代码，您的产品将100％死（直到当然，您修复它）。但是，采访者不会疯狂，他们不会拒绝你。他们甚至可能不会注意到。这只是一个代码样本，你的面试官将获得信息。我派生在这里的信息是你可能不会使用内置链接列表课程。我关心吗？甚至没有一点点。关于这样的代码？<ol> int getmax（int [] array）{int max = array [0]; for（int i = 0; i <= array.length; i ++）{if（array [i] <max）{max = array [i]; }} return max; } </ OL>  
<li> int getmax（int []数组）{</ li>  
<li> int max = array [0]; </ Li>  
<li> for（int i = 0; i <= array.length; i ++）{</ li>  
<li> if（array [i] <max）{</ li>  
<li> max = array [i]; </ Li>  
<li>返回max; </ Li>  
<li>} </ li>  
我们这里有一些问题。在这样一个简单的代码中有四个错误担心我。我会得出结论，你可能是写下错误的代码。事实上，Bug＃3会让我想知道你写码的频率;它很奇怪地搞砸了一个非常基本的循环模式，如此.Now，这是怎么样的？这是我在面试中看到的真正代码。<ol> int getmax（int []数组）{int max = array [0 ]; for（int i = 0; i <array.length  -  1; i ++）{if（array [i]> array [i + 1]）{max = array [i]; }} return max; } </ OL>  
<li> int getmax（int []数组）{</ li>  
<li> int max = array [0]; </ Li>  
<li> for（int i = 0; i <array.length  -  1; i ++）{</ li>  
<li> if（array [i]> array [i + 1]）{</ li>  
<li> max = array [i]; </ Li>  
<li>返回max; </ Li>  
<li>} </ li>  
这不是粗心的。你写的代码甚至没有意义算法。很关心。如果你很容易发现并修复这些错误，那么对这些错误的关注会有所缓解，但他们仍然会引起一些问题。这让我兴起到第二部分。您可以识别并修复您的错误  
许多候选人恐慌当他们找到一个错误时。他们通过一个特定的测试用例注意到一个错误，然后他们使一个快速修正。它可以解析它为该测试用例，但也许没有修复真实问题。如图所示，请考虑此代码在字符串B中找到字符串S的所有实例：  
<ol> int countsubstrings（string s，string b）{int count = 0; for（int i = 0; i <b.length（） -  s.length（）; i ++）{string bsubstring = b.substring（i，i + s.length（））; if（bsubstring.equals）{count ++; }}返回计数; } </ OL>  
<li> int countsubstrings（string s，string b）{</ li>  
<li> int count = 0; </ Li>  
<li> for（int i = 0; i <b.length（） -  s.length（）; i ++）{</ li>  
<li>字符串bsubstring = b.substring（i，i + s.length（））; </ Li>  
<li> if（bsubstring.equals）{</ li>  
<li> count ++; </ Li>  
<li>回报数; </ Li>  
<li>} </ li>  
乍一看，代码基本上看起来是正确的，但它不是。（你有没有注意到这个错误？）许多候选人在一个测试用例中抛出像S = XYZ和B = XYZ时的测试案例。当他们注意到的时候对于循环根本永远不会被执行。  
### 回答 23
现在，在某些情况下，它可能没关系。考试  
如果您询问常见问题的面试问题，您的一些候选人会知道答案。他们中的一些人将能够表现得像他们在现场的答案上提出答案而不是以前那么回忆。你应该根本不希望你能始终能够讲述差异。  
（一些面试官声称他们总是可以讲述差异。这本质上是不可信的，因为如果候选人成功地欺骗了他们认为他们没有记住解决方案，他们就不知道他们已经被欺骗了。）  
现在，在某些情况下，它可能没关系。例如，在我是候选人的一个面试中，我被要求写一个函数，给定指向二进制搜索树中的节点的指针，返回到树的按顺序遍历中的下一个节点的指针。如果您向候选人询问这种问题 - 测试他们是否对CS基础知识了解 - 您不应该关心他们是否实际阅读教科书中的伪码并记住，或者他们是否在现场弄清楚它。重要的是他们知道它（这意味着他们可以了解通过订购的关联阵列迭代的性能特征，以及这样的事情。）  
如果您正在努力评估解决问题的能力，您只需要努力提出候选人以前不太可能听到的问题。这真的是它归结为。一种常见的技术是：一旦候选人解决​​了问题，请向他们询问变体，看看它们是否具有类似的理由对这些变化的能力。但是，当然，如果您使用与许多其他面试官相同的常见变化，那么候选人也有一个重要的机会，也有可能听到了变化。因此，这并不能保证 - 您需要至少试图不遵循人群。  
在谷歌，采访者通过选择从不受欢迎的问题池中选择的面试问题来处理这个问题，这些问题并不知道与谷歌相关联。候选人听到任何特定问题的可能性都被要求低，因为即使他们已经记住了数百个问题，他们在任何特定面试中得到的人也不可能是其中之一。即使候选人已经听到了一些问题，他们听到了他们在完整面试的大部分问题中都听到了大部分问题的可能性非常低。如果面试问题变得过于流行或出现在谷歌提出的问题列表中，他们将从问题池中删除。  
### 回答 24
对于那些知道的，这个硬件错误是计算中的伟大经典之一。  
多年前，克雷先生设计了超级计算机。一个是克拉-1。  
英国的一些研究人员在它上运行了代码。答案快速回来了。真的很快，如12％的速度更快，然后从早些时候在较旧的Cray-1上运行！  
他们仔细检查了结果。答案是正确的！所以，赫克发生了什么！ CRAY硬件工程人员被召集来分析内部发生的事情。 ............  
答案？一旦开始向量操作，FPS模块就在不受预测的方式中互连  
对于那些知道的，这个硬件错误是计算中的伟大经典之一。  
多年前，克雷先生设计了超级计算机。一个是克拉-1。  
英国的一些研究人员在它上运行了代码。答案快速回来了。真的很快，如12％的速度更快，然后从早些时候在较旧的Cray-1上运行！  
他们仔细检查了结果。答案是正确的！所以，赫克发生了什么！ CRAY硬件工程人员被召集来分析内部发生的事情。 ............  
答案？一旦向向矢量操作开始，FPS模块就在不可预测的方式和链接将每个元素的链接到第二载体模块的输入中的链接链接到第二个向量模块的输入中的互连！  
在Chippewa Falls的工厂进行了一些后续后，该公司举行了会议。结果？新广告称赞链接作为补充功能！链接设计成那条内容的所有后续克拉超级计算机。  
于是：如果你不想解决它？促进它。  
PS。当克拉先生被问到新功能的设计时，他回答了，我从未想过这一点！  
//参考：这是一个Y-MP手册，具有关于第2-31页的链接操作的详细描述（TL; DR，除非您是计算机螺母）：  
### 回答 25
为了充分欣赏我的答案，我希望你能够改变你的技术面试的心态。停止思考面试作为测试。  
技术面试不是学术测试。这是一次采访。这是一个比考试更容易的个人和主观评价。  
确实是您正在测试的。确实，您将被分配出访谈的租赁/雇用评估。但是你需要了解一个非常关键的差异。  
测试的答案只有两个结果 - 正确和不正确。采访中的答案给面试官更多信息。  
在工程世界中，问题并没有整齐地分解为15分钟内可以回答的简短答案格式。事实上，在15年内，存在无法解决的问题，更不用说15分钟。因此，面试官喜欢了解如何对巨额范围的问题的反应 - 远远超出了一个小时的面试插槽。  
他们不需要你提出答案。他们需要了解你的思想过程！最重要的是，他们希望看到你不只是放弃！  
所以这是我在下次找到自己的建议。继续要求澄清问题。不要停止。将问题缩小到较小且较小的部分。展示面试官你的进程。从你可以想到的每种可能的角度都来到问题。  
在微软，有一句话。雇用适合，不是为了技能。例如 - 我们不在乎您在网络上记载了这本书 - 所有知识都可能变得不关会很快。我们所关心的是，您对技术充满热，结果是一个明确的驱动器，您可以与其他人一起使用。与那些属性，无论您正在努力的技术如何，您都会在这里取得成功。  
### 回答 26
凉，谢谢你的A2A。  
首先，永远不要放弃。其次，意识到这发生了很多 - 无论是在访谈还是在工作中。在现实生活中，总有问题和问题在现实生活中解决，如果你不愿意处理你不舒服或不熟悉的人头顶）。  
现在有了这种方式，我希望你首先专注于工作解决方案。从点A到点B（输入到输出） - 尝试思考代码将成为您的代码。首先不必是最佳的，任何解决方案都比解决方案更好。想到面试问题作为一家公司每天亏损数百万美元因为这个问题 - 我们现在可以解决它吗？设想。一旦您有一个基本案例解决方案，依靠您的基础来优化。它是一个搜索，数组遍历吗？ - >我们可以使用二进制搜索吗？它是2D / 3D阵列，需要多个结果吗？ - >我们可以使用HashMap缓存吗？问题看起来像一个图表吗？ - > DFS / BFS让我多远？ - >这是一个特殊的变异吗？ - >如果是这样，如果你不记得头顶的拓扑排序，请不要恐慌，你如何实施它？ - >这并不难，只需添加堆栈，但您必须在面试期间弄清楚。等等。  
酷，现在你有一个工作解决方案。现在你必须编码它。在这里倾听我：您需要练习在头部实施理论特征。最好通过10个问题彻底工作，而不是在你的头脑中脱脂/解决问题。我在候选人中看到的一个共同主题是：他们挣扎，到达解决方案，然后他们努力编码它。我正在雇用一个软件工程师，基于他们的编码能力 - 顶级科技公司倾向于依靠安全方面倾向于拒绝一个体面的候选人，我们不是100％肯定的，因为他们将在未来重新申请 - 所以请练习它。请随时阅读我的​​其他帖子的确切细节如何练习 -  Jonathan Chous答案应该对哪些主题的答案应该为Facebook前端工程师实习？  
最后，快速插头：如果解决问题，你不知道令你兴奋你，你觉得你在技术上准备好 - 优步总是招聘 - 所以给我发一条直接留言:)  
### 回答 27
说我不知道​​。如果您了解该问题的一部分，您可以要求面试官填写细节并提出有限的答案或猜测（并说出其猜测），但对您的知识的极限绝对诚实。  
不要试图过去你的问题。当候选人随时随地尝试一下，它立即出门失败，因为我认为我不知道是对诚实的考验，这在开发人员至关重要。  
坦率地说，我会询问受访者问题，直到我击中了他们的无知的极限。一旦在那里，如果他们直接承认他们不知道答案，我认为这是一个积极的。如果他们试图跳过这个问题，或者 - 甚至更糟糕 - 试着强调捍卫错误的答案，他们出门了。  
### 回答 28
我不在乎这么多，因为至少99％的编程是我以前见过这个问题，现在让我申请我知道这个解决方案。  
因此，在编码面试中，我通常会问一个问题，答案是具有一些微妙点的常见算法。为了我最喜欢的是，我预计所有候选人几乎所有的候选人都至少在学院中途的时间内为课堂作业写了一种形式的这种算法。  
但是，如果你以前见过这个问题，那么你几乎肯定也看到至少有一个稍微不同的答案的六个变体。你可以采取一个略微错误的答案并使它适应它，这就是很多人似乎做的 - 然后我们通过解决复杂性来看看是否适应它，或者改变微妙的细节以一种方式显示你的理解它的漂亮。或者您可以在第一个位置理解微妙的细节，以便首先获得答案的正确变体，但在我看来，这是一个真正的积极，而不是假的。  
另一件事是，算法中有很多地方以逐个错误。这是白板编程;统计数据位于我的一边，你将成为一个。所以评估的另一部分是，我将要求您通过算法如何与一些样本数据一起使用（或者在没有我的情况下，您可以询问！），而且我将观看您所做的事当您遇到错误时。你可以轻松解决吗？你对出了什么问题感到困惑吗？你甚至注意到，或者你只是告诉我你的代码是什么？  
您可能会在特定类型的算法中有很多经验，我询问了这一点，因为你真的擅长获得所有细节，但这就是我们有多次面试的原因。如果有人能够用四个不同的人提出不同的问题，我们再次到真正的积极点，而不是假的。  
### 回答 29
按此顺序：  
通常，时间被视为一个限制，因此您应该使用可以以最快的方式提供帮助的资源。一位同事会花费他和我一段时间，所以我将首先使用谷歌。如果同事和谷歌不提供任何解决方案，那么stackoverflow是下一步，我将等待最多两天（偶尔少）答案，同时首先关注其他事情。如果是这样，那么给出任何答案，那么我会尝试找到解决问题的解决方案，或者也许可以找到不需要错误代码的解决方案。 （也许禁用包含错误的代码的功能。）  
如果这一切都没有帮助，我只需要走得更远。意思，更多的谷歌曲和更多与同事谈论，并向老板/客户解释正在处理我们无法解决的东西。  
最后一个选择我必须在我的整个职业生涯中做一次，我的老板只是告诉我继续寻找这个问题。没有重要，只要它可以解决，它需要多长时间。  
这个问题实际上非常复杂，因为我们建立了一个Outlook-addin，但某些病毒扫描仪因未指定原因而被认为是恶意软件。但我们的系统是100％的病毒，所以它无法感染甚至恶意。在我意识到附加物以错误的方式使用特定的Windows API需要几个星期。 Windows API允许代码安装特殊钩子，如键盘挂钩，以捕获特定事件（按键），以便在例如时，您可以采取特殊行动。压制了一个特定的热键。此API呼叫需要特定过程的句柄。我们刚刚使用0（零）作为手柄ID，因此它成为一个系统宽的钩子。有些病毒扫描仪可以调试可执行文件，在代码中发现这些挂钩的API，并检测他们正在尝试创建一个系统宽的钩子。这种行为将被标记为恶意。  
一旦问题所知，它很容易修复。但是，很难找到。使用调试器是无用的，因为在它可以做任何事情之前都被封锁了。祝你好运试图找到错误，如果你不能使用调试器！在找到原因之前，我不得不经历大量的无证代码。 （加上可能的原因很多googling！）  
### 回答 30
你可以想到回复：QuiceSir / Madam，我诚实地觉得你要问的问题也是我所爱的回答。但是，我今天还没有做好准备好。如果你能给我另一个机会，我将在我的能力中准备并回答你的技术问题。请考虑此请求。单向enext时间，确保您在参加面试前做好准备，从不浪费别人。最好的祝愿。  
### 回答 31
如果问题是概念性的  
您已将编程访谈标记为您问题中的主题。所以，如果问题是一个编程问题，即使你知道答案，你应该表现得像你不知道答案，并保持你的工作解决方案。在采访中突出显示，您知道概念（就像为什么不使用全局变量）。  
如果你不知道答案，就会让你对面试官的斗争。如果你被困在某些时候，他们可能会帮助你。  
如果问题是理论上的（7层OSI是什么），那么你应该坦率地说不知道这个概念。  
如果问题是概念/分析，如数据结构最好用于存储数字的蒸汽，以便在任何时候我们能够在恒定的时间内获得10个最大数字。对于这样的问题，即使您不知道确切的答案，您也可以尝试您知道的所有可能的数据结构，并在时间复杂性方面比较它们并得出结论。  
一切顺利。  
