---

title: 在C / C ++中，为什么人们声明指向int * x而不是int * x？
date: 2022-01-23T22:08:05+08:00

---




## 在C / C ++中，为什么人们声明指向int * x而不是int * x？  
### 回答 1
在C / C ++中，为什么人们声明指向int * x而不是int * x？  
C / C ++并不意味着什么。 C和C ++是两种不同的（但相关的）语言。没有C / C ++语言。我会假设你的意思是c和c ++。  
编译器不关心你是写入int * x或int * x。令牌之间的白色空间是微不足道的（除非你需要至少一个空间来分隔两个令牌，那不是这里的情况）。  
编写INT * X的那些程序员这样做是因为它遵循语言语法。同样，如果您真的想要，您可以编写A + B * C，但编译器将忽略空格并将其视为等同于A +（B * C）。  
在C中，通常的样式是将*与变量名称相关联：int * x，主要是因为kernighan和ritchie使用了这种风格。 （Dennis Ritchie发明了C语言; Kernighan和Ritchie共同写出了语言的原版。）  
另一方面，在C ++中，最常见的样式是写入int * x。这是，据我所知，完全是因为Bjarne Stroustrup，C ++语言的创建者更喜欢这种风格，并在他的书中使用它。  
INT * X表单更紧密地跟随语言语法。宣言的基本意义  
<ol> int * x; </ OL>  
<li> int * x; </ Li>  
该int是类型，* x是那种类型的（使用声明遵循的原理，C的语法大多如下）。我们可以从此推断，x是int类型*。  
当您定义多个变量时，这会显示：  
<ol> int * x，y，z [10]; </ OL>  
<li> int * x，y，z [10]; </ Li>  
这里，* x，y和z [10]都是int类型的，因此x为类型int *，y是int类型的，z是int类型[10]。 （没有z [10]，这是我主要在上面写的原因的一部分。）  
在C ++中，许多程序员通过假装这一点来处理这一点  
<ol> int * x; </ OL>  
<li> int * x; </ Li>  
将X声明为类型int *的对象*（它确实只有间接地），并且避免在单行上声明多个变量（无论如何是一个好主意）。  
### 回答 2
这是因为*绑定到变量，而不是类型，您可以逗号单独定义  
<ol> int * a，b;</ OL>  
<li> int * a，b;</ Li>  
让我认为a和b都是int的指针。但他们不是。到Int的一个点，B是int。  
通过添加该空间，理想地重新排列，它变得清晰：  
<ol> int b，* a;</ OL>  
<li> int b，* a;</ Li>  
我个人喜欢每行一个避免这种情况。  
### 回答 3
在C和C ++中，您可以在一个声明中声明多个变量。声明包含类型部分，以及初始声明程序列表。类型部分仅包含int或foo for类的int或foo键入关键字。宣言  
int * x，y;  
声明一个名为x的指针到int，并且一个名为y的int。指针符号*关联到init-somplator（x和y是init-申报器）而不是类型。如果您说int * x，它会更与c和c ++的实际语法相匹配;而不是如果你说int * x ;.  
但我说int * x;在我的个人练习中。  
### 回答 4
它是一样的，你甚至可以在没有空间的情况下写下int * x  
原因是我假设*如果同时声明多个变量，则属于变量  
int a，* b，** c;是正确的  
int * a，b，c;看起来你会宣布3个指针，但这不起作用  
### 回答 5
这条规则来自文本有限的时间 - 越短越好，（来自打卡？我  
无论如何，除了这里，我们碰到了C的少数缺陷之一是写入int * x，p的很常见错误;并认为p是指针。它不是，它是一个整数。成千上万的人小时被浪费（并且将是）只是为了纠正这个愚蠢的错误。  
int *遵循的一切都应该是指向int的指针。这是逻辑的。但情况并非如此......，避免int *并制作int *给出一点希望不经验不经验的程序员不会犯错误。 （但他会......）。  
这条规则来自文本有限的时间 - 越越好，（来自打卡？我是kiddin ......）。所以，而不是  
int * x，y345; int p，u，uu;  
一个人可以写  
int * x，p，u，uu，* y345;  
它节省了一行代码和分号，不是很酷！？  
### 回答 6
这两个声明都是正确的。  
不同之处在于在同一语句中声明多个变量时：  
<ol> int * x，y，z;</ OL>  
<li> int * x，y，z;</ Li>  
真的声明x是指向int的指针，但y和z是int。这令人困惑。这就是为什么最好在变量名称附近编写'*'：  
<ol> int * x，y，* z;</ OL>  
<li> int * x，y，* z;</ Li>  
这将x和z声明为指向int，但y为int。  
问候。  
### 回答 7
出于同样的原因，你写的  
<ol> int a [4]; </ OL>  
<li> int a [4]; </ Li>  
并不是  
<ol> int [4] a; </ OL>  
<li> int [4] a; </ Li>  
我敢于在此声称的任何人都说，让C或C ++编译器接受后者是一种风格。这不是风格问题。一旦你接受int [4] a和int a [4]之间的区别不是一个风格的问题，你就准备好接受int * a和int * a之间的区别不是（纯粹的，谢谢杰克）a风格的问题。  
理解C的哲学是一个问题。是的，我同意，int [4] A和Int * A对他们有一个很好的逻辑。键入左侧，右侧变量，漂亮。但这不是c的leitmotiv  
出于同样的原因，你写的  
<ol> int a [4]; </ OL>  
<li> int a [4]; </ Li>  
并不是  
<ol> int [4] a; </ OL>  
<li> int [4] a; </ Li>  
我敢于在此声称的任何人都说，让C或C ++编译器接受后者是一种风格。这不是风格问题。一旦你接受int [4] a和int a [4]之间的区别不是一个风格的问题，你就准备好接受int * a和int * a之间的区别不是（纯粹的，谢谢杰克）a风格的问题。  
理解C的哲学是一个问题。是的，我同意，int [4] A和Int * A对他们有一个很好的逻辑。键入左侧，右侧变量，漂亮。但这不是C的乳房。  
C的相关leitmotiv是声明遵循使用。  
<ol> int * a; </ OL>  
<li> int * a; </ Li>  
这意味着* a是一个int。  
以下声明是什么意思？  
<ol> int（*（a [4]））（）; </ OL>  
<li> int（*（a [4]））（）; </ Li>  
这意味着表达式（*（a [3]））（）是int。  
这有两个优点：  
我知道很多人，C的莱特玛蒂夫宣言似乎似乎疯了。但是那些提出它的人在象牙塔中不是白痴。  
编辑：另一个小思想实验。想象一下，C设计师们把星号放在表达式的右侧，如下所示：  
e *  - 其中e是type指针到t的表达式 - 具有类型t  - 左值是e（右值当然由左值识别的对象的值的正确值）。  
声明是什么样的？  
那是对的，它是  
<ol> int a *; </ OL>  
<li> int a *; </ Li>  
我们不会有这次讨论。  
一旦了解这一点，您也可以理解  
<ol> int * a，b; //呵呵？为什么B没有类型int *？ </ OL>  
<li> int * a，b; //呵呵？为什么B没有类型int *？ </ Li>  
实际上并不令人惊讶，因为c语法实际上是如此解析为  
<ol> int * a，b; // * a有类型int，b有类型int </ ol>  
<li> int * a，b; // * a有类型int，b有类型int </ li>  
### 回答 8
在C / C ++中，为什么人们声明指向int * x而不是int * x？  
人们并不总是将星号放在标识符上。例如，我总是用这种类型配对它，因为我认为它的美学部分的类型信息。  
但是，人们经常将星号与标识符配对星号的原因可以在单行代码中总结：  
<ol> int * a，b，* c; </ OL>  
<li> int * a，b，* c; </ Li>  
它可能不清楚，但在C时在C单个语句中处理多个声明时，每个标识符可以独立地指向指针。在上面的代码中，两个'a'和'c'被声明为指向整数的指针，其中'b'是d  
在C / C ++中，为什么人们声明指向int * x而不是int * x？  
人们并不总是将星号放在标识符上。例如，我总是用这种类型配对它，因为我认为它的美学部分的类型信息。  
但是，人们经常将星号与标识符配对星号的原因可以在单行代码中总结：  
<ol> int * a，b，* c; </ OL>  
<li> int * a，b，* c; </ Li>  
它可能不清楚，但在C时在C单个语句中处理多个声明时，每个标识符可以独立地指向指针。在上面的代码中，“a”和'c'都声明为指向整数的指针，其中'b'被声明为实际整数。由于这种细微的语法比特，整个C文化采用了将星号放在所有声明中的标识符上的习惯。  
因此，C ++采用此惯例，并进一步将其扩展到用于注意参考的Ampersand。  
### 回答 9
在C / C ++中，为什么人们声明指向int * x而不是int * x？  
你有没有想过为什么int *（* f）（char *）是一个指向函数拍摄char指针并返回整数指针的指针？  
C声明的语法反映了如何获得简单类型的值。当您写入INT * P时，它字面上意味着P是应用程序，当应用*（取消引用）操作员时，将为您提供一个拒绝。相反，上述F意味着F是某种方式，当应用*运算符时，然后用CHAR指针施加功能应用程序操作员，最后应用*操作符，结果是int。关于此方法的伟大件是变量声明语法与变量使用语法相同，因此您可以更少学习。  
当您编写INT * p，*（* f）（char *）时，这是两个变量的声明，只有上述类型。因此，实际上它是最终的简单类型（int），当您在同一语句中声明多个变量时，它是常见的，而不是变量的类型。  
在最简单的情况下，使用int * p，x，x是一个int，而不是指向int的指针。如果你写它像Int * p，x一样，它看起来像你创建p和x作为int指针，但这不是编译器看到的。为避免这种混乱，C会议将在简单类型之后立即放置空间，尊重C语言中的含义。  
但是在C ++中，设计师建议它实际上是可以的，甚至更优选写作int * p。好处：它强调声明语句的主要播放器是变量和类型，而不是最终简单类型以及如何获得它。但我们仍然需要避免上面的混淆，这是通过另一个惯例完成的：切勿在同一语句中声明两个复杂的变量。因此，您问题的前提是错误的：偏好大多为C程序员，而C ++程序员则不清楚。  
