---

title: 为什么现在很少用作编程语言？
date: 2022-01-23T22:08:16+08:00

---




## 为什么现在很少用作编程语言？  
### 回答 1
（1）您认为这个程序是什么？<ol> $ _ = q（s％（。*）％$ _ = qq（\ $ _ = q（$ 1），打印％e），s％ （。*）％$ _ = qq（\ $ _ = q（$ 1），$ 1），打印％E </ OL>  
<li> $ _ = q（s％（。*）％$ _ = qq（\ $ _ = q（$ 1），$ 1），print％e），s％（。*）％$ _ = qq（\ $ _ = q（$ 1），$ 1），打印％e </ li>  
（2）这个呢？<ol> srand; for（0..5）{$ r [$ _] = chr 65 + rand 8} sub d {print $ / x6; for（0..35）{打印$ _ <27＆$ _> 13？ - ：$ _％14> 12？\ n：$ _ <6？$ _ [0]？$ r [$ _]：o：$ _％14 == 6？ |（拆分//，$ b [int $ _ / 14]）[$ _％14] || $}打印$ /输入m / [a-ha-h] {6} / \ n} sub c {返回if / [^ ah] / ||长度（） -  6; @ c = split //，$ {$ f = \（$ b [24  -  ++ $ w] = uc。$）}; $ w> 21 &&返回1; for（-6..35）{（$ p [$ h] = 1）＆（$ q [$ h] = 1）＆（$$ f。= *）＆$ n ++如果$ _ <0 && $ c [$ h = $ _ + 6] eq $ r [$ h]; ！$ p [$ b] &&！$ q [$ d] &&（$ p [$ b] = 1）＆（$ q [$ d] = 1）＆（$$ f。= +）如果$ c [ $ d = $ _％6] eq $ r [$ b = $ _ / 6] && $ _>  -  1}（d $]）＆d </ ol>  
<li> srand; for（0..5）{$ r [$ _] = chr 65 + rand 8} sub d {print $ / x6; for（0..335）</ li>  
<li> {打印$ _ <27＆$ _> 13？ - ：$ _％14> 12？\ n：$ _ <6？$ _ [0]？$ r [$ _]：</ li>  
<li> o：$ _％14 == 6？| :(拆分//，$ b [int $ _ / 14]）[$ _％14] || $}打印$ /输入</ li>  
<li> m / [a-ha-h] {6} / \ n} sub c {return if / [^ a-h] / ||长度（） -  6; @ c = splass //，</ li>  
<li> $ {$ f = \（$ b [24  -  ++ $ w] = uc。$）}; $ w> 21 &&返回1; for（-6..35）{（$ p [$ h] = 1）</ li>  
<li>＆（$ q [$ h] = 1）＆（$$ f。= *）＆$ n ++如果$ _ <0 && $ c [$ h = $ _ + 6] eq $ r [$ h ]; </ Li>  
<li>！$ p [$ b] &&！$ q [$ d] &&（$ p [$ b] = 1）＆（$ q [$ d] = 1）＆（$$ f。= +）< / li>  
<li>如果$ c [$ d = $ _％6] eq $ r [$ b = $ _ / 6] && $ _>  -  1}（d $]）＆d </ li>  
（1）您认为这个程序是什么？<ol> $ _ = q（s％（。*）％$ _ = qq（\ $ _ = q（$ 1），打印％e），s％ （。*）％$ _ = qq（\ $ _ = q（$ 1），$ 1），打印％E </ OL>  
<li> $ _ = q（s％（。*）％$ _ = qq（\ $ _ = q（$ 1），$ 1），print％e），s％（。*）％$ _ = qq（\ $ _ = q（$ 1），$ 1），打印％e </ li>  
（2）这个呢？<ol> srand; for（0..5）{$ r [$ _] = chr 65 + rand 8} sub d {print $ / x6; for（0..35）{打印$ _ <27＆$ _> 13？ - ：$ _％14> 12？\ n：$ _ <6？$ _ [0]？$ r [$ _]：o：$ _％14 == 6？ |（拆分//，$ b [int $ _ / 14]）[$ _％14] || $}打印$ /输入m / [a-ha-h] {6} / \ n} sub c {返回if / [^ ah] / ||长度（） -  6; @ c = split //，$ {$ f = \（$ b [24  -  ++ $ w] = uc。$）}; $ w> 21 &&返回1; for（-6..35）{（$ p [$ h] = 1）＆（$ q [$ h] = 1）＆（$$ f。= *）＆$ n ++如果$ _ <0 && $ c [$ h = $ _ + 6] eq $ r [$ h]; ！$ p [$ b] &&！$ q [$ d] &&（$ p [$ b] = 1）＆（$ q [$ d] = 1）＆（$$ f。= +）如果$ c [ $ d = $ _％6] eq $ r [$ b = $ _ / 6] && $ _>  -  1}（d $]）和diedone $ /如果$ n> 5; $ n = @ p = @ q =（）} while（！c）{d | chop（$ _ = uc <>）} d $ /;打印$ / looser！$ / </ ol>  
<li> srand; for（0..5）{$ r [$ _] = chr 65 + rand 8} sub d {print $ / x6; for（0..335）</ li>  
<li> {打印$ _ <27＆$ _> 13？ - ：$ _％14> 12？\ n：$ _ <6？$ _ [0]？$ r [$ _]：</ li>  
<li> o：$ _％14 == 6？| :(拆分//，$ b [int $ _ / 14]）[$ _％14] || $}打印$ /输入</ li>  
<li> m / [a-ha-h] {6} / \ n} sub c {return if / [^ a-h] / ||长度（） -  6; @ c = splass //，</ li>  
<li> $ {$ f = \（$ b [24  -  ++ $ w] = uc。$）}; $ w> 21 &&返回1; for（-6..35）{（$ p [$ h] = 1）</ li>  
<li>＆（$ q [$ h] = 1）＆（$$ f。= *）＆$ n ++如果$ _ <0 && $ c [$ h = $ _ + 6] eq $ r [$ h ]; </ Li>  
<li>！$ p [$ b] &&！$ q [$ d] &&（$ p [$ b] = 1）＆（$ q [$ d] = 1）＆（$$ f。= +）< / li>  
<li>如果$ c [$ d = $ _％6] eq $ r [$ b = $ _ / 6] && $ _>  -  1}（d $]）和diedone $ /如果$ n> 5; </ Li>  
<li> $ n = @ p = @ q =（）} while（！c）{d | chop（$ _ = uc <>）} d $ /;打印$ / looser！$ / </ li>  
难以读，嗯？顺便说一下，如果你是好奇（1）打印本身，并且（2）是MinesWeeper的ASCII版本。[1]  
<a> [1] </a>  
现在，这些程序是故意读取的，但是普遍难以阅读，无论如何都是难以阅读的.Perl是由拉里墙设计为UNIX脚本语言，以使报告更轻松，更快。您可以看到它使用的语言的根源var以像bash，csh等一样地拍摄变量汽车的价值。在那个结束时，他添加了内置地图（声明了我的％映射）和列表（声明了我的@list）.and，这很棒。诸如Python和JavaScript已纳入此功能.But Wall进一步。并在整个Buil-In Variables中纳入了整个范围.Check EM Out：[2]  
<a> [2] </a>  
<ol> $ _ #default输入@_ #parameter array $ #list分隔符$$ #process id的当前进程$ 0 #program name $（#real group of program $的程序$）＃defcective group of program $ <#real用户ID $> #yefcective用户ID $; #subscript用于多维arry的分隔符$ a $ b #arguments for perling％environment变量$] #verson of perl译员$ ^ f #maximum文件描述符###更多</ OL>  
<li> $ _ #default输入</ li>  
<li> @_ #parameter array </ li>  
<li> $ #list分隔符</ li>  
<li> $$ #promess目前进程的ID </ li>  
<li> $ 0 #program name </ li>  
<li> $（#leal of program的of program </ li>  
<li> $）＃of程序的Defective群组ID </ li>  
<li> $ <#real用户id </ li>  
<li> $> #yefcective用户标识</ li>  
<li> $; #subscript多维arry的分离器</ li>  
<li> $ b #arguments for比较器，用于排序</ li>  
<li>％env #environment变量</ li>  
<li> $] #verson的perl口译员</ li>  
<li> $ ^ f #maximum system文件描述符</ li>  
<li> ###更多</ li>  
Perl提供的功能也是如此.They不如透明度一样，作为内置的变量，但仍然是非常强大的，但它们不会使其非常可读。Perl也没有提供强大的打字，封装或其他功能Perl程序更具可读性和可维护.Thus perl是一个忘记的语言。它是一种伟大的语言，用于编写一个快速脚本来处理一些数据，但它不是适合生活的软件。我知道不得不保持其他人。它是有趣的.Perl 6和7已经据说封装和其他功能以使代码更加可维护。  
### 回答 2
Perl是一种革命性的编程语言;它将低级系统操作与高级对象和库相结合。它具有最好的正则表达式。所有这些都在20世纪90年代中期。那么为什么今天很少使用？  
IMO，Perl为其他具有更好智能语言的脚本语言铺平了道路，同时丢失了这些语言的市场份额：  
对于开源语言，网络效果发挥着大作用：社区驱动对语言的改进，反过来又推动进一步采用。参赛者的社区帮助他们获得人气，而Perl则被分成至少两个叉子。  
我使用Perl超过十年作为我的辅助编程语言，以及C，C ++和以后的Java。 2010年左右，我转向Python进行这种类型的工作，后来也是我的主要编程语言。我很感激我的工具包中有perl。  
Heres一个日期，对比较Perl，而不是没有感情的编程语言的异想天开的调查，对鲸肠来说：  
### 回答 3
它被使用了很多，但今天在Python中完成了很多脚本  
与难以写入和难以读取的共同主张相反，当你知道它时，它实际上是一个很好的语言  
### 回答 4
许多人会引用php / ruby / python，但这不是真的。Perl被用来不仅仅是web。  
我自己不超过2005年的Perl的原因是：  
当你有这样的野兽时，为什么有人想用它？因为它与语法的一个组成部分具有正则表达式？无论如何，严重属于模块（图书馆）。正是不像你需要的是正则表达式，因为许多人似乎相信。  
### 回答 5
它很少没有使用过。实际上，几乎所有包括Apache的服务器都使用它，几个浏览器使用它和许多计算机语言使用它用于Web连接，TCP隧道和对等体。  
### 回答 6
我已经使用了近25年的Perl。但是，5年前，我必须终于搬到Python。初级动机是Python对各种各样的良好选择的良好选择，与Perl不同，其中许多CPAN模块不再更新。而对于我的职业 - 网络自动化 - 现在有更多即用的模块和工具，而不是Perl。  
让我们面对它：Perl不应该成为一个真正的编程语言。曾经！它被设想为类固醇的Unix壳。一种友好的解释员的脚本语言（就像sh或以后的bash），以帮助sysadmins避免重新编码他们的sh | awk | SED | NC | FMT |尾巴|当他们在他们创造的不管理的意大利面管中丢失时，掌握到C程序。那些C程序甚至更糟糕，因为许多Sysadmins精确选择了他们的职业，以避免编程，因为它们是较差的编码器，更糟糕的开发人员。  
Python是一个不同的故事。它从一个真正的编程语言演变 -  ABC，这是20世纪80年代阿姆斯特丹大学的项目。旨在取代该时代的机器上的基本情况。从第1天开始，它应该是完全对象的（Perl对象稍后）。而目标用户组有点不同 -  Python旨在主要用于科学家和工程师。后来它被采用作为Perl替代脚本。再次 - 因为它也基于解释器逻辑（虽然在内部进行某种编译......）。  
在其侧面Perl作为懒人蛮力编码器的理想解决方案，而不是关心数据类型，正确的声明，结构和记录。它为您提供了您可以尽可能多地进行的梦幻般的数据类型混合。例如：  
开始时$ a = 1：1 ...... ; $ a = $ a + 2;打印$ a \ n;  
结果给出了3。简单地，剥离了“：”标志的任何事情，第一个字符被视为整数。但那么这个：  
开始时$ a = 1.1 ...... ; $ a = $ a + 2;打印$ a \ n;  
是的，它给出3.1，因为1.1被视为浮子。但是这个：  
$ a = genesis 1.1  - 开始...... ; $ a = $ a + 2;打印$ a \ n;  
返回2，当然，因为int（genesis）== 0.所以是的，有时是一个字符串的字符串，有时是一个整数，有时是一个浮点子，有时是boolean ...谁关心......你不需要关心短/长/签名/无符号。 Hooraaaay ......  
然后我们来到更复杂的结构 - 如阵列或哈希表。你会得到什么：  
打印$ my_new_hash {$ my_new_key_not_declared_yet}  
是的，一个空字符串。但Perl不会警告你（除非你想被警告 - 即，通过在你的代码中使用strict）。再次 - 懒惰的女仆爱！只是强调 -  Python不会让您在哈希中使用未知键...或引用未定义的阵列（列表）元素 - 程序将尖叫声音并停止。 OTOH，Perl只是返回那里的空值，你有时可以使用0，有时候，有时候，有时是假......）。  
好吧，截止到某一点 - 这个数据类型Mumbo-jumbo听起来很棒！但是，随着您的脚本生长为真正的S / W包，每个都有50个.pl文件，每个文件都有1000行，巨型蟑螂开始从您的代码宇宙的最黑暗的角落爬网，并在您最不期望的地方咬住您的地方它。  
当然，在Perl用户群体中有适当的编码器，谁结构代码很好，负责适当的支撑使用/缩进，用严格作为任何文件的第一行......但仍然是，如果你使用CPAN模块，那么有人搞乱了这样的数据类型？在这些情况下，你的手被捆绑了。  
最后，我们来到了最常见的Perl用例 -  SYS / NET管理任务的自动化。 20年前，如果工程师执行了一款糟糕的Perl片刻，那么如果路由器崩溃，那么许多人都不关心许多人都会受到关心的。但是现在，当相同的（大规模IP / MPLS）网络负责我们的手机电话，证券交易所，银行，而且是电网，供水，物联网，控制医疗设备等的重要事项 - 我们无法承受依靠严格的书面代码来自动化这些解决方案。不知何故Python，它的灵敏度是一种自然的替代品，并踢出了所需的退休金。  
### 回答 7
为什么Perl现在很少用作编程语言？：mu。Perl不很少使用。它已经使用了几十年的每年都是如此。它目前根本不是一个fad。这与很少使用的东西都没有。我一直使用它，所以做很多人，因为我们始终拥有的所有原因（如，它在处理文件时擅长，搜索文本中的模式，处理Unicode等）。  
一般来说，在询问表单的问题时为什么x？，一个应该确保命题x实际上是真的！在这个问题的情况下，它不是。  
### 回答 8
正如许多其他人指出，Perl很难读。在这方面，它就像APL一样，许多人被称为只写语言。这不太真实：它只是需要时间来学习习语（特别是在向往和矩阵上使用各种运算符）。  
但真正的杀手是编程中的努力分配。大多数具有良好的新Comp SCI学位的人认为编程是关于编写程序。 （这就是我在我得到的第一份工作时所想的，我甚至没有学位。）但是如果你看一下软件项目的努力分发，你会看到不到总员工的一半花在设计和编码上。最大的总努力是：  
以一种类似程序的语言，如C，Java，PHP，Python或Go，通常很容易弄清楚改变的地方。类，函数和变量名称通常会给你一个非常好的提示。 （这比升级更真实，而不是错误修复 - 如果它显而易见，它不会通过代码审查来完成。）  
但在Perl中，经常长，复杂的运算符序列（也是APL的真实），而不是整齐地分成类别，方法等的东西（是的，Perl支持OOP。Perl程序的百分比实际上包括祝福操作？）  
因此，如果您要编写一个超过一次使用的程序 - 特别是如果它将被原始作者以外的人维护 -  C的语言比Perl更好。  
我将在这里承认某种程度的偏见。在43年的编程中，我在汇编语言，Fortran，Pascal，Meta，Jovial，Algol 60，C，C ++，Java，PHP和YACC / Lex中写了课程。和一个（计算它，一个）perl程序。  
后来我被递给了一个perl计划来扩展。我看着它，然后在C ++中写下了扩展名。如果我有一段时间，我会在C ++中重写整件事。  
后来在朋友上发给我一个perl脚本，它将重命名文件，以便按照（文本）目录中指定的顺序排序。我试过运行它，它不起作用。而不是尝试调试它，我只是按字母顺序排列文件，并让他修复输出。 （其他用户都不关心订单。）  
后来我发现了一种用Windows GUI和有用的网站做同样的事情。  
所以，是的，我不是那个人询问perl。  
### 回答 9
是吗？ $ Dayjob的产品主要写在Perl中（虽然我的特定产品是C ++）。我定期写入Perl脚本以自动化一些测试。它绝对不是蟒蛇所在的热点，但是仍在使用中。  
我将自由承认我不喜欢这种语言，写作总是让我痒，所以我有时候避免它。我经常说，如果我不得不在一份工作中选择要求我写COBOL的工作和必然需要的工作，我会在心跳中取得COBOL工作。我不认为我的态度是独一无二的，这可能是为什么不再谈到这么多。  
但是，虽然范例（和语言）来，但是，遗留代码是永恒的。那里有一个非琐碎的Perl代码，这是一个有用的东西依赖的东西，因此一些可怜的混蛋将不得不保持它，直到太阳吞下地球。  
### 回答 10
Perl几乎是所有标点符号，因此谷歌几乎不可能。  
当您使用多种语言时，需要注意您使用的语言需要时间。您可能需要谷歌的东西要记住Java语法如何与C语法不同，但这很简单，有点示例代码会让您在那里。  
切换到Perl，您必须从头开始提醒自己的详细信息，无法谷歌标点符号。转回并回来，然后再次回到方形。出于这个原因，今天的大多数Perl开发人员都是Perl专家，他们会看到他们的眼睛并留在那里。  
### 回答 11
我是一个受到相当大的经历的Perl开发人员（喜欢使用Perl），与其他3个答案不同，您的问题目前拥有。与他们不同，我会告诉你为什么你应该使用Python，而不是基于针对Perl的偏见，或者基于缺乏经验导致的误解，而是基于两种语言的事实。  
正如正确确定的，两种语言都解决了大致相同的问题，即软件的编程，其源仅在运行时编译。此外，它们中的两个都提供了大致相同的特征，该特征在具有预制的第三方代码的大图书馆中，键入的键入严格的基于C，内置存储器管理以及核心中的各种功能。  
谈到它们之间的差异，有三个主要的东西：  
因此，总之，没有明确的答案可以标记这些语言的任何一种，客观地都是上方的。然而，即使您已经完全了解Perl，对于为什么要学习和使用Python，绝对有各种各样的原因，具体取决于您想要做什么以及您想要的动态编程语言。  
### 回答 12
在这一点上学习Perl仍然完全良好。我对Python和Perl的比较了一段时间，我认为我认为仍然是准确的。  
只需确保您*不要*使用Learning Perl，而是读取OVID的开始Perl和Chromatic的现代Perl。  
<span> christian walde </ span>  
<span> passionate perl architect </ span>  
我是一个受到相当大的经历的Perl开发人员（喜欢使用Perl），与其他3个答案不同，您的问题目前拥有。与他们不同，我会告诉你为什么你应该使用Python，而不是基于针对Perl的偏见，或者基于缺乏经验导致的误解，而是基于两种语言的事实。  
正如正确确定的，两种语言都解决了大致相同的问题，即软件的编程，其源仅在运行时编译。此外，它们中的两个都提供了大致相同的特征，该特征在具有预制的第三方代码的大图书馆中，键入的键入严格的基于C，内置存储器管理以及核心中的各种功能。  
谈到它们之间的差异，有三个主要的东西：  
因此，总之，没有明确的答案可以标记这些语言的任何一种，客观地都是上方的。然而，即使您已经完全了解Perl，对于为什么要学习和使用Python，绝对有各种各样的原因，具体取决于您想要做什么以及您想要的动态编程语言。  
### 回答 13
是的，Perl非常匹配。我唯一看到这样的问题的人就是仍然认为perl的人是令人困惑的是，他们在大约十年前停止了他们停止使用CGI编程的编程语言。没有东西会离事实很远。  
Perl在过去十年中完全改变了。现在，Perl社区现在谈到现代Perl，以区分当前十年前的经常做法。从CPAN的额外模块安装了很多这一变化（DBIX :: Class是强大的orm，Moose在Perl中的oo使用，PSGI和Plack是催化剂和舞者等强大的Web框架的伟大工具，但是核心语言也有巨大的变化。如果您使用Perl 5.8或更早版本，那么您应该真正查看升级到5.12或5.14。并读取安装的Perldelta手册页，以查看它的变化有多大。  
一个大问题是，明确的perl书籍，编程perl hadnt已更新大约十年。好吧，第四版本月发布。这将展示Perl的大规模改进。  
然而，主要问题似乎是人们很快就会忽略普遍存在，而无需调查它的变化。 Perl社区需要更好地在回声室中获取消息。他们知道，在过去的几年里，事情已经急剧提高。  
Perl正如Python和Ruby一样快速地进展每一位。不要从手中驳回。仔细看看它发生了什么。  
### 回答 14
如果Perl匹配你喜欢在代码中表达自己的方式，那么  
相关性取决于背景。仍然使用Perl，如果它在目前（或计划）工作的地方使用它，它会使它相关。当它仍然是核心网络技术和UNIX / Linux的选择的自动化语言时，Perls流行度大幅下降。因此，它已经失去了其他语言（Python，PHP，Ruby，甚至去）在它用于支配的区域。现在，很少见，看看新的项目选择了Perl。因此，Perl与您相关的可能性已缩减。  
一切都说，如果Perl匹配你喜欢用代码表达自己的方式，它与您有关。  
### 回答 15
如果您有一项任务，您将在Linux命令行与bash上做大量工作，我认为您将找到Perl对工具箱的一个非常有价值的补充。除了让您轻松地通过包装和暴露在易于使用的功能中进行系统的呼叫，它还让您可以让您可以使用充满SED，AWK，CUT，Head和Head和Head和Head和Head和Head及尾部命令。通过从Bash脚本运行大量这些微小的程序来不必使用这些类型的事情，而您可以在单个线程的Perl脚本中完成所有这些类型的程序。加上Perl预先安装，但最畅销的Linux和UNIX版本。  
Perl也非常有用，可用于执行快速和脏文本处理任务。例如，从报告或数据文件中从文本块中提取几个参数的内容。只需几行代码，您可以设置一个状态机以识别感兴趣部分的位置，然后在其上归零，以正常表达式更改或提取信息。  
一旦你开始挂起的语言，你开始发现自己不断建立便利的小工具，让你的生活更轻松。快速且脏的HTML解析器/ URL Extrollor。快速和肮脏的JSON分级器，等等。语法明智，它实际上是一个很可怕的很多像C和shell脚本的混合。 Perls表现力和实现快速和肮脏的系统级和过滤解决方案的能力是Perl语言编程的一些最深刻的令人满意的方面。  
### 回答 16
P.  
是的，它几乎用于一切。它不用于编写OS内核或设备驱动程序的一件事。  
我最近（自2012年以来）使用Perl 5对于网站，服务器监控，业务报告，生成图形和自动图像处理，文档生成和管理，身份验证和授权，数据处理（包括繁重的Math与Blas等）等等等等。 等等。  
我在过去6年中工作的最小应用程序只有200 MB的Perl代码，并且由于Perl 4是当前版本的开发，被移植到Perl 5 CGI，然后将Apache Mod_Perl，然后是plack / psgi。  
Perl 5是一种多范式语言（这是支持势在必行的，功能，OOP，方面，面向合同，成分数等）。  
1994年成立的Perl 4确实是AWK / SED / BASH的替代品，并且经常被称为Perl，对除了小脚本的任何东西并不好。  
Perl 5（世卫组织于1994年10月17日发布，并通过版本5.6制定的扭结）可能仍然是世界上最先进的编程语言和库集合，这不一定是它可以咬训练的程序员仅使用面向对象的编程或仅限程序编程，并且肯定会使Heck与功能性编程纯粹主义者一起困扰，但是那些无法以任何语言做任何IO，因此他们对任何非学者都不重要。  
### 回答 17
Perl不是由众多经验或知识的人写的  
我一直在三十多年来一直在写Perl，我在15年前在教室里首先教授了Perl。学习......对于一些人来说，这是一种艰难的语言。  
大多数语言，甚至oo语言（由比喻的发展原则）有一个相当强烈的，正式，数学的基础。编译器取决于代码是可预测的，但开发人员也是如此。只有一些可能的单词可以开始Java文件，例如，类似于包，导入，类，公共和接口（可能会忘记一两个，不在乎）。  
Perl不是由有很多经验或了解基础编程语言设计的数学形式主义的经验或知识的人写的。它是由一个在语言学学位的人撰写的，专注于自然语言，而不是理论，以及立即问题：解析和分析大型文本文件。他有多种语言的经验，就像我们所有人一样，他喜欢A和一些B（或者是一些帕斯卡和一些审查）。他做了每个开发人员最终做的，故意或其他方式：他建立了一种特定于域的语言，以满足他的需求，包括不一定在一起的功能。  
如果您在CS程序中学习编程，就像我的学生所做的那样，Perl违反了您对语言的许多约定和假设。如果没有别的，Perl牺牲了......一种语言完整性的简单性和可预测性。如果您有循环，只要条件为真，那么重复，您当然应该直到循环，重复直到条件为假。随着时间的推移，新功能已添加到Perl，因为Perl不是纯粹主义者的好选择。这增加了混淆级别。  
我有一段简单的时间学习Perl，因为它强调了我个人强有力的西装，语言表达，在追随数学形式主义。我没有学习（很多）cs作为本科生。虽然Perl在许多目的中不再是一种好语言，但它仍然是它所作志的伟大选择（这就是它在标签上所说的：文本提取和分析）。此外，它可以作为没有强调数学形式主义作为语言设计的指导原则的例子;这是为了让程序员的舒适，而不是因为它必须完成。它类似于使用8的力量;除了我们都同意，否则没有引人注目的技术原因。我希望，正如我们需要更多的程序员，Perl可以指导我们更具包容语言。我们确认我们有好工具，但我们几十年来做到这一点，这些工具不太可能在几个世纪以来衡量时的时间考验。  
编辑：今天发生了一个例子。我早期的严肃编程工作是在Perl中完成的。当我搬入更复杂的语言时，我感到震惊地了解您无法动态构建和评估代码。是的，有反思/内省，但能够快速地动态构建代码，并且对我来说是一种无意识的，我经常使用它。对于某些类型的系统/问题来说，这不是一个好主意，但我的观点是Perl的心态是不同的。不好或更糟，只是不同。更好。  
### 回答 18
为什么Perl如此讨厌，而不是常用？  
我认为Perl有很多批评者有几个原因  
我为什么要了解它？  
尽管如此，您可以通过以下Damian Comways的Perl最佳实践在Perl中编写可维护代码。该实用程序暂时可用于帮助培训自己以编写更好的Perl代码。  
perl是多范式。在执行中，它比Python快。它在CPAN中有一个卓越的生态系统，您可以在那里找到一个模块，以帮助您解决几乎每个可想象的问题。对于命令行实用程序，文件系统管理，数据库管理，数据提取 - 转换加载任务，批处理，连接不同的系统和快速且脏脚本，这通常是作业的最佳工具。  
我经常使用erl与Excel有关。您可以在Excel中做得很多，它提供了一个很棒的互动UI。但复杂的公式可能是一个痛苦，可以在VBA中写入代码可以繁琐。通常，我发现只需将单元格复制到剪贴板即可更快，切换到命令shell，在数据上运行一个perl脚本，将结果发送到剪贴板，切换回Excel，然后粘贴原位或粘贴结果一个新的位置。  
perl也很深。它有助于支持必要的编程，OOP和功能规划。有关后者的更多信息，请参阅“预订高阶Perl”。  
perl是强大的。 perl很快。 Perl是工具包中有一个有效的工具。这些都是学习它的好理由。  
### 回答 19
实际上，这后，后者导致了Perl的糟糕声誉，因为  
这里有几个很好的答案有关功能。我想突出两件事：  
1，简短配方。一切都可以非常简单地制定。因此，Perl的开发明显比你的其他语言更快。有几个构造，它缩短了你的打字和（是！）即使是你的思维方式也是如此。  
2，自由。您有大量的方式如何描述解决方案。每个人都可以开发一个哇，个人对他/她最适合他/她，使得发展更快。  
实际上，后者导致了Perl的糟糕声誉，因为你有自由，你也可能与它有无政府状态，如果你没有自己控制。所以很多开发人员误用了perl，它成为一个只写的编程语言。虽然，如果您创建风格，Perl是几个开发领域中最有效的语言之一（特别是基于文本：Web，报告，分析，脚本，自动化......）。  
