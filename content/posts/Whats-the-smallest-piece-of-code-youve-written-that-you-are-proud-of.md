---

title: 你写过的最小代码是什么，你为此感到骄傲？
date: 2022-01-23T22:08:16+08:00

---




## 你写过的最小代码是什么，你为此感到骄傲？  
### 回答 1
但是那个  
我们有一个GNARLY PROG，即〜600行正则表达式。它需要a.product描述，如您在目录中查找，并使用产品ID，尺寸，大小，重量，颜色等内容进行结构，最后是事项。纯粹来自文本。  
目录以不同的方式描述相同的完整事物，这就是我们需要的原因。这是预先消费级别的AI。  
这段代码恰好靠近我所看到的Grimoire，我是写它的病假混蛋。如果你勇敢地尝试阅读它，它试图吃你的思想。但它他妈的有效，已经完成了十多年。  
但这不是我为此感到自豪的东西。它的客户支持人士表示，它没有拿起特定的产品代码。  
hmmmmmmmmmmmmm。三个小时的凝视。一个逗号完全正确的地方（和Deep Regex看起来完全相同的线噪音），现在已经做了，并且没有打破任何东西。  
那天我是上帝。 Loki可能只是一个上帝。  
### 回答 2
Memcpy是一个非常困难的功能。它必须处理各种奇怪的对齐和长度案例，仍然有效。即使X86具有字符串复制指令，它也具有相当高的启动开销，而不是大多数芯片上最快的解决方案。图书馆memcpy非常好，但它是华努约。它是超过1000行代码，主要是在汇编程序中。  
我正在阅读各种AVX-512的指令，并决定尝试编写Memcpy。它围绕了25行代码，处理所有对齐和长度案例，但每个内存参考拷贝64个字节。当然，您需要一个非常现代的x86来运行它，因此它几乎没有替代图书馆例程。  
### 回答 3
我是分枝  
我在509个字节中写了Pac-Man。如果您有兴趣，它在这里：  
它是它自己的引导加载程序（并提供自己的操作系统，如果这是您想要调用的是最简单的显示驱动程序和键盘处理程序），如果您将其存储在USB棒的主启动记录中并从中启动计算机将自动开始运行游戏，无需操作系统。  
注意：如果将其刻录到USB上，则棒将不再将其识别为Windows中的存储设备，因此此操作如此以您自己的风险，并且不要使用USB粘贴具有有价值的数据。  
我为键盘处理程序感到特别自豪。它使用一些术语比特操控来将键盘扫描转换为Opcode（井，技术上，操作码的ModR / M字节）要更新位置的指令，然后在移动功能中覆盖该字节。所有要保存字节，如果是的话，它会采取两种程序。  
### 回答 4
这是程序（由于依赖于我的记忆可能不正确;一世  
1965年，我为LINC（实验室仪器计算机）创建了三指令机 - 语言程序，是第一个迷你电脑之一。该程序在类似于瀑布的屏幕上显示了不断变速的模式。它实际上是一个抛物线，在多次折叠并且由于丢弃携带位引入的伪随机性而变化而变化。  
在求职面试期间，我会在求职期间进入这三条指示，并帮助我获得了几个工作编程了LINC，1969年至1970年的PDP-12。  
以下是程序（由于依赖我的内存可能不正确;我不再有LINC或PDP-12测试）：  
Location Contents0：添加0 [将位置0内容添加到累加器1：DIS 10 [增量位置10并显示点2：JMP 0 [循环回到位置0  
### 回答 5
我们在NASA的IBM大型机上有一种情况：当我们的用户连接到OS / 360虚拟机的终端时，他们无法自行断开连接;他们不得不打电话给支持小组，他们不得不打电话给系统运营商实际断开终端的连接。  
这浪费了很多时间。经过大量的研究后，我能够创建一个非常小的操作系统修补程序（约有20条指令），将必要的命令丢弃到一段系统存储中的临时未使用的字段中，并执行调用管理程序以执行它的特殊指令。问题解决了。  
### 回答 6
我做了一段时间吧，砍掉了我朋友的机器人。这不是很困难，或复杂，但在他的机器人（从对话中学习）之后不会说除了废话之外  
### 回答 7
虽然（1）叉（）;  
...更多和你如何使用它。我们在学校分享了访问UNIX机器，毕业生们搞砸了我的朋友+同学。他们主要机器上的一些简单的叉子炸弹将它们拉直一下。它也让我对管理员有严重的麻烦。  
### 回答 8
我在一个微小的应用程序中写了一篇文章，该脚本将在各种文件夹中呈现数据库脚本作为可以选择性地选择和运行的操作项下拉列表。  
下一个效果是更好的自动化工作流程。复杂系统中的常见任务可以由昂贵的开发人员脚本，而可操作的工作可以通过更便宜的职员来完成。对于一个组织，净福利在运营机会成本中超过250千万美元/年，总体票证解决时间的重大减少。  
### 回答 9
有趣的是，我的是一个代答旧的赛段，已经回答的stackoverflow问题询问，询问来自JavaScript中的API的递归收集分页数据。接受的答案是一个相当简单的任务的21行代码。有兴趣看到代码如何通过现代语法减少，即使格式化时，我也会使其降至七个。  
并且具有更好的可读性和错误处理。  
这是原始解决方案（对其作者没有冒犯）：  
<ol> function getallposts（）{返回新承诺（（解析，拒绝）=> {let postsarr = [];函数reursiveapicall（apiurl）</ ol>  
<li>函数getAllposts（）{</ li>  
<li>返回新的承诺（（解析，拒绝）=> {</ li>  
<le>让postsarr = []; </ Li>  
<li>功能reursiveapicall（apiurl）</ li>  
有趣的是，我的是一个代答旧的赛段，已经回答的stackoverflow问题询问，询问来自JavaScript中的API的递归收集分页数据。接受的答案是一个相当简单的任务的21行代码。有兴趣看到代码如何通过现代语法减少，即使格式化时，我也会使其降至七个。  
并且具有更好的可读性和错误处理。  
这是原始解决方案（对其作者没有冒犯）：  
<ol> function getallposts（）{返回新承诺（（解析，拒绝）=> {let postsarr = [];函数reursiveapicall（apiurl）{fb.api（apiurl，（响应）=> {if（response && resplate。数据）{//向Posts array（合并数组）添加响应（合并数组），检查是否通过paring postsarr = postsarr.concat（response.data）检查有更多数据;如果（response.paging && response.paging.next）{recursiveapicall（resculsiveapicall .paging.next）;} else {解析（postsarr）;}} eyles {recket（）;}} recossiveapicall（/ me / posts？fields = message＆limit = 100）;}）; } </ OL>  
<li>函数getAllposts（）{</ li>  
<li>返回新的承诺（（解析，拒绝）=> {</ li>  
<le>让postsarr = []; </ Li>  
<li>功能reursiveapicall（apiurl）{</ li>  
<li> fb.api（apiurl，（响应）=> {</ li>  
<li> if（response && response.data）{</ li>  
<li> //向Posts数组添加响应（合并阵列），检查是否通过Paging </ Li>有更多的数据  
<li> postsarr = postsarr.concat（response.data）; </ Li>  
<li> if（response.paging.paging && response.paging.next）{</ li>  
<li> recursiveapicall（response.paging.next）; </ Li>  
<li>解决（Postsarr）; </ Li>  
<li>} else {</ li>  
<li>拒绝（）; </ Li>  
<li> recosiveapicall（/ me / posts？字段=消息和限制= 100）; </ Li>  
<li>}）; </ Li>  
<li>} </ li>  
这是我写的版本：  
<ol> contor getAllposts =（apiurl = / me / posts？字段=消息和限制= 100）=>新承诺（（解析，拒绝）=> fb.api（apiurl，异步（{错误，分页，data} = {} ）=> {if（错误||！数据）拒绝（错误||没有facebook的响应。）;解析（data.concat（分页？.ncon？await getposts（paging.next）：[]）;}） ）; </ OL>  
<li> const getAllposts =（apiurl = / me / posts？字段=消息和限制= 100）=> </ li>  
<li>新承诺（（解析，拒绝）=> </ li>  
<li> fb.api（apiurl，异步（{error，paging，data} = {}）=> {</ li>  
<li>如果（错误||！数据）拒绝（错误||没有Facebook的响应。）; </ Li>  
<li>解析（data.concat（paging？.next？await getposts（paging.next）：[]））; </ Li>  
<li>}）</ li>  
<li>）; </ Li>  
我不了解你，但第二个对我来说更容易理解。也许是因为我虽然我写了......  
这是它所做的，逐行：  
第1行：定义GetAllPosts函数  
第2行：返回一个新的承诺对象  
第3行：进行API请求，并响应，  
第4行：检查是否存在错误，如果有错误，否则会抛出它，  
第5行：用包含数据的数组解析承诺  
第6行：结束API请求。  
第7行：最终承诺。  
这是一个很简单的代码，但由于某种原因，我对此感到非常满意，因为我设法如此渺茫，它显示了我对承诺，递归和错误处理的了解。  
### 回答 10
我锻炼了  
我介绍了如何用整数添加和表查找替换复杂的乘法，并同时消除页面Thrash问题。 （更精确地围绕每个元素的20个这样的乘法转换）。  
当快速傅里叶变换算法相当新的时，这就是回来的。通过转换所有行，然后转换所有列来执行双D FFT。如果没有足够的RAM，后期阶段是非常棘手的。天真的方法页面颠簸了。 （当时完全配置的VAX 11/780都有4MB。MB，而不是GB。）  
我制定了一个人可以交织行和列变换的阶段。这导致在没有页面TRASH的SANE模式下访问虚拟内存。更好的是，可以通过添加整数行和列位置并在1D中查找一个复数，替换在其行位置的复杂因子中的复数替换元素的复合因子倍数，然后替换在其列位置的复数。系数表。  
然后我编码了它。混合的RADIX FFT不是易于编码的东西，而且在那个时候，我的物理学家比程序员更多。  
为什么我出名？因为只有几年短几年，RAM相对于随机索引表格得多，浮点算术得多。所以，我的优化首先变得毫无意义，然后是现代硬件的Mal-Optimization的情况。叹。  
### 回答 11
我承认这是代码高尔夫（在最少的角色中绕过），但我喜欢C函数我想出了两个数字的最高常见因子。这是一段时间后，但它已经这样做了这样的事情（没有发展环境来检查它）。它需要预先ANSI标准，其中如果没有另外指定，则假设类型的int。  
f（a，b）  
{  
返回！B？A：F（B，A％B）  
}  
### 回答 12
一个讽刺的公式，但问题让我想起了这一点。以为它可能值得笑。我的前妻和我的共同父母，所以我们仍然需要沟通。我收到了多页的电子邮件，基本上是抱怨的借口。她会继续前进，直到我回复，但我只是不需要争论。所以我回复了：  
作为一名科学老师，也许这种格式更好......似乎你试图在ya  -  rc = yx时解决x  
y =你  
r = ryan.  
A =愤怒  
C =小心  
A> C.  
X =怨恨  
我在这里删除了她的名字，但idnt从她那里听到几个月的任何东西......  
### 回答 13
扣。  
历史上最复杂的软件是由我们不知道的名字的团队编写的。  
这是一个电脑蠕虫。可能是2005年至2010年期间的威尔。  
因为蠕虫是如此复杂和复杂，所以我只能给出它的最肤浅的轮廓。  
这种蠕虫在USB驱动器上首先存在。有人可以发现USB驱动器躺在邮件中，或者在邮件中得到它，并想知道它是什么。当USB驱动器插入到Windows PC中时，有...  
### 回答 14
我认为纯粹的危险简洁，很难击败叉子炸弹。  
叉炸弹  
一个自我复制的代码，只需几乎所有的编程语言都可以非常简单地写入，并且由于指数增加的性质，大部分机器将在任何时候磨损到停止。  
在这里，它是基本的C.所有程序都是在又一次地删除所有资源之前又一次地创建另一个程序 - 通常通过简单地填充操作系统的过程表。  
<ol> #include <unistd.h> int main（void）{whis（1）fork（）; } </ OL>  
<li> #include <unistd.h> </ li>  
<li> </ li>  
<li> int main（void）</ li>  
<li> {</ li>  
<li> while（1）fork（）; </ Li>  
<li>} </ li>  
如Wikipedia的例子所指出的，仔细地使用ulimits  
我认为纯粹的危险简洁，很难击败叉子炸弹。  
叉炸弹  
一个自我复制的代码，只需几乎所有的编程语言都可以非常简单地写入，并且由于指数增加的性质，大部分机器将在任何时候磨损到停止。  
在这里，它是基本的C.所有程序都是在又一次地删除所有资源之前又一次地创建另一个程序 - 通常通过简单地填充操作系统的过程表。  
<ol> #include <unistd.h> int main（void）{whis（1）fork（）; } </ OL>  
<li> #include <unistd.h> </ li>  
<li> </ li>  
<li> int main（void）</ li>  
<li> {</ li>  
<li> while（1）fork（）; </ Li>  
<li>} </ li>  
如Wikipedia的示例所指出的，仔细使用非root用户的ulimits * nix机器可以帮助防止这一点。  
编辑：  
哦，是的，在尝试运行这些示例之前保存所有工作......您可能会惊讶他们锁定您的速度。 （没有真的，我第一次尝试并令人遗憾的是，我没有打扰。）  
编辑2：  
正如用户所指出的那样回答有史以来最危险的代码是什么？当然有许多危险的定义，他将一个例子直接指出生命和肢体。  
大多数无意识别的危险代码的另一个例子是谦卑的Off-of-One错误，这可能是现代软件中安全漏洞的最常见原因之一。这就是程序员支付不充分关注他们所分配的内存程度的地方，或者不要正确地保护其限制，有人能够（意外或故意）注入字节，在他们不应该的地方，不可预测的错误导致或崩溃，或潜在的主机充分利用。  
### 回答 15
好吧，还有更多的代码以扩展方法的形式，但它确实很简单。这代码是为了获得的战士  
这不会对你有任何意义，但我一直在尝试C＃和Linq与枚举结合起来，所以我可以写这个美丽的代码线：  
<ol> var结果= dicetype.d3.roll（）。rollx（3）.maxcount（10）.takeuntil（（）=> dragon.isdead（））。doall（i => dragon.damage（i））。 runningcountandtotal（i => i，（总，count，i）=> console.writeline（$ {count：##}：我们击中{i}伤害的总数{总}，平均{总计* 1.0 / count：每次命中造成0.0.0＃}。））。托尔斯特（）; </ OL>  
<li> var结果= dicetype.d3.roll（）。rollx（3）.maxcount（10）.takeuntil（（）=> dragon.isdead（））。doall（i => dragon.damage（i））。 runningcountandtotal（i => i，（总，count，i）=> console.writeline（$ {count：##}：我们击中{i}伤害的总数{总}，平均{总计* 1.0 / count：每次命中造成0.0.0＃}。））。托尔斯特（）; </ Li>  
嗯，还有更多的代码，即扩展方法的形式，但它确实很简单。这个代码是为了一个人来获得10次罢工杀死龙的战士。然后判断龙是否活着或死亡。输出可以看像这样：  
<OL> 1：我们每次击中龙7个伤害，平均每次点击伤害。每次击中龙5伤害5次伤害，平均每次伤害5.33次伤害：我们击中了7次伤害，共23例，平均每次伤害5.75次伤害.5：我们击中了6点伤害总共29个平均每次伤害5.6：我们每次击中龙7次伤害，平均每次伤害6.0次伤害。我们共滚了36次伤害，并获得了36次伤害，得到：7， 4,5,7,6,7击中龙是死...（-1）</ OL>  
<li> 1：我们击中了7次伤害的龙，每次击中平均伤害7.0次。</ li>  
<Li> 2：我们击中了4个伤害的龙，每次击中平均5.5次伤害。</ li>  
<li> 3：我们击中了5种伤害的龙，平均每次击中5.33点伤害。</ li>  
<Li> 4：我们每次击中龙7次伤害，平均每次击中5.75次伤害。</ li>  
<li> 5：我们每次击中龙6次伤害，平均每次打击5.8次伤害。</ li>  
<Li> 6：我们每次击中龙7次伤害，平均每次击中6.0伤害。</ Li>  
<Li>我们共滚了6次36次伤害，得到：7,4,5,7,6,7击中</ li>  
龙已经死了......（-1）</ li>  
或者喜欢这个：  
<OL> 1：我们每次击中3个伤害3次伤害，平均每次点击3.0次伤害。每次击中龙7次伤害，平均每次伤害5.33次伤害：我们每次击中龙5次伤害，平均每次伤害5.25次伤害.5：我们击中了6点伤害总共27个平均每次伤害5.4：我们每次击中龙5次伤害，平均每次伤害5.33次伤害：我们击中了35人的35次伤害35次伤害平均每次伤害5.0：我们每次击中50次伤害50次伤害，平均每次伤害5.0次伤害：我们每次击中龙77次伤害，平均每次击中5.22次伤害.10：我们每次击中龙52次伤害，平均每次点击5.2次伤害。我们共滚动了10次伤害，得到：3,6,7,5,6,5,3， 5,7,5击中龙还有83嗨T点</ OL>  
<li> 1：我们击中了3个伤害的龙，每次击中平均伤害3.0次。</ li>  
<Li> 2：我们击中了6种伤害的龙，每次击中平均伤害4.5次。</ Li>  
<li> 3：我们每次击中龙7次伤害，平均每次击中5.33次伤害。</ li>  
<li> 4：我们击中了5次伤害的龙，平均每次击中5.25次。</ li>  
<Li> 5：我们击中了6种伤害的龙，平均每次击中5.4次伤害。</ li>  
<Li> 6：我们每次击中龙5次伤害，平均每次击中5.33次。  
### 回答 16
* A2A.  
最喜欢的代码？容易，我制作的乌贼螺旋。 Unnikrishnan Menon为此获得信誉。他是那个向我展示了一个关于Quora问题的人，我们都开始阅读它。这是2017年夏天，我在学院工作全职。我需要多件事来照顾，但在我参与那个实验编码项目后，我开始忽视了我完成工作后的一切。哎呀我甚至打扰了一个与我合作的年轻兄弟和同事。到7月底，我能够提出两个代码的工作原型。一个是乌贼螺旋，下一个是一个看起来像17武装章鱼的螺旋，或者我们看到当我们照亮鞭炮或烟火棍子时，我们看到的模式，并在圆周运动中旋转手。  
乌贼螺旋  
三角螺旋  
最好的部分是，自6-7年以来，我没有像这样对此有趣和严重的东西。所以我甚至不能使用那些让我的生活更容易的语法。不能使用C ++，不得不使用Fortran。想象一下我的兴奋，在三个星期之后，一个没有错误的一大块代码，我在家里疯了，我的大学，无论我走到任何地方。我忘了我已经长大了，这种行为不适合我。我无法完全专注于我的工作。我总是等待一天结束，所以我可以尽可能快地回到家，并使用更多的代码。  
这是2014年，当我遇到Nova系列视频分形：狩猎隐藏的尺寸。首先我很着迷，然后我沉迷于模式。也许是因为我总是喜欢几何形状。我首次知道，欧几里德几何形状无法全面描述的东西。在2017年夏天，我生命中的第一次，我开始享受编码模式。它已成为我的常规日常生活。  
它不是说我还没有作出后漂亮的图案，但有一种说法是，有些事情，你套回到正轨，你不需要从过去的回头看，后悔你的过错。这是编码了那块后究竟发生了什么事给我。  
几何总是乐趣我，去了解分形只是增加了我的瘾。现在，无论我做什么，我尝试在我的环境看起来有所不同。我尝试...代码..to梦想。  
### 回答 17
好吧，它不是一个程序，而是我工作的产品的特征。该功能称为多维访问方法（或MDAM）。它是一种方法可以在关系数据库中的多列上有效地利用B树索引。我用三个其他人工作。我们两个人在优化器方面工作，我们两个人（我在这个小组中）做了运行时期。我们一起获得了专利。  
代码是我职业生涯中曾经工作过的最复杂和优雅的代码。运行时间代码大约是7000行代码，写在三个月内。我和我的伴侣以极端的编程风格写下了这段代码：虽然我们每个人单独写过功能和程序，但我们每个人都会在编译它之前审查其他的工作。我们在我们去的时候一起制作了设计，在我们学到的更多内，可以自由丢弃以前的工作。这也是我职业生涯中曾经工作过的最可靠的代码。一部分串联DBMS，不间断SQL，它在几家大公司的关键任务应用中生产。代码的错误很少 - 截至几年前少于10  - 并且仍在生产中。  
### 回答 18
回到1980年代，我正在担任技术支持分析师。我正在工作的公司正在使用IBM大型机，使用IBM的VM（虚拟机）作为主机系统和大量IBM的VSE（批处理环境）虚拟机作为客户系统。  
管理员启动了VM基本交互式客户操作系统替换VSE的程序，称为CMS。  
更换应该是简单的，因为CMS，就像它一样简单，具有所有必要的支持。  
除了 …  
在VSE上运行的一些程序同时生成各种报告，以来  
回到1980年代，我正在担任技术支持分析师。我正在工作的公司正在使用IBM大型机，使用IBM的VM（虚拟机）作为主机系统和大量IBM的VSE（批处理环境）虚拟机作为客户系统。  
管理员启动了VM基本交互式客户操作系统替换VSE的程序，称为CMS。  
更换应该是简单的，因为CMS，就像它一样简单，具有所有必要的支持。  
除了 …  
在VSE上运行的一些程序同时生成各种报告，因为它有支持单个虚拟打印机（地址00E）。  
我们问IBM如何克服这种限制和答案，毫不奇怪，这是不可能的。  
但 …  
返回它们IBM仍在假设中仍在运行，即钱仅在硬件中，并且该软件仅仅是一个支持硬件销售的工具。看到IBM x Microsoft的故事要了解这一点。  
所以 …  
IBM，将软件视为其硬件的阑尾，天真地提供了VM和CMS的源代码!!!!  
然后 …  
当IBM回答不可能克服CMS的一个虚拟打印机限制时，我立即对自己说：地狱是不可能的！我有源代码！我知道汇编/ 370，它写的汇编语言！我有我需要的一切！我是世界之王！我是在DiCaprio永生那种表达之前的世界之王!!!!  
因此，我扫描了所有CMS源代码，寻找00E串的CMS虚拟打印机地址。而且，为了我的惊喜，只有一个地方使用它！我研究了代码并提出了一个简单的解决方案：我改变了它不仅接受标准00e虚拟打印机地址，还改变了另外15个虚拟设备地址作为打印机设备，从01e到0fe等等。那样，我提出了最大数量的16个可能的虚拟打印机设备地址，绰绰有余！  
它像魅力一样工作......解决方案简单，高效，甚至优雅，对应用程序完全透明。  
因此，通过此解决方案，所有VSE许可证都可以替换为CMS虚拟机，为本公司节省了很多钱。  
我知道，这个解决方案仍在使用中，超过32年。  
笔记  
这让我感到自豪能够有一个解决方案，我在几年前30多年来就可以，可能是在我不再使用的时候仍然在使用！  
所以，而不是像世界之王一样，我应该感觉像法老！ ;）  
### 回答 19
谷歌上有许多解决方案，告诉您如何做，但没有人会在您想从最后C的Google表中拉动数据时会告诉您一个清晰和直接的解决方案  
大家好，  
由于我们正在谈论到目前为止写的美好代码，并且实际使我们自豪，我想分享我所拥有的代码。  
因此，我写了一种代码，其中我跳过两方面的身份验证过程以与您的Google帐户连接。它只是需要我在.p12格式（加密格式）中发送的用户ID和密码，然后连接后它将读取Google Sheet的数据。  
谷歌上有许多解决方案，告诉您如何做，但是当您希望从最后一列NULL的Google Shoto中拉动数据时，没有人会告诉您一个清晰直接的解决方案。  
存在许多解决方案，它告诉您关于放下额外列或使用一些高级概念等等。  
我只是用一个常见的逻辑解决了这个问题，我猜是我能想到的更简单。任何其他必须具有比我更好的解决方案，我并不否认这一点。  
然后，在获取那些数据并放入表中也创建了问题的同时，在跳过空列的情况下，如果上列为null，则在行引起的in un null未找到错误时，在行的最后一个列中将逗号放在CSV文件中。我刚刚写了2-3条带有一些支票的行，这也解决了这一点。  
这让我感到骄傲，因为这次我做了一些解决方案甚至没有在谷歌上的东西。然后我意识到我们自己可以找到更好的解决方案，但实际上我们只在两三个故障后迈向谷歌，这不好  
对于A2A.  
谢谢pranav singhania.  
### 回答 20
我已经完成的最艰难的编程 - 就必须在微弱的抽象中保持很多细节，一次性进程在精神上进程 - 正在用参数类型为特定于域语言编写类型的推理系统。它给了我对inria的那些家伙很尊重！  
唉，DSL从未使用过......  
### 回答 21
如果您想辨别复杂性的工作量，Sloc或Logical Sloc是一所古老的学校，并没有说太多了。此外，现在已经自动生成了大量代码，有时需要手动仪表。课程数量，用例或用户故事在过去10-15年内更常见。但你不能比较那些......  
例如，编写业务逻辑代码（例如COBOL）需要不同的努力来自接线UI交互代码与基础架构（例如CORBA）代码。此外，根据组件的类型（例如，符合标准的软件预成型功能，测试可能非常硬或非常容易，在所有级别中具有比具有Add-hoc功能的自定义软件的所有级别更有洞察力和复杂性）。  
如果您想了解某人交付的工作机构的复杂性，您必须评估挑战：不仅仅是代码，而是制度类型，资金，截止日期，老板，客户，窥视，客户......经常提供系统尽管所有这些都对抗你和戒指BS的沟渠需要英勇的努力。  
想想在几个月内需要50个或更多开发人员时，你如何做到这一点，在几个月内采访数百人，并觉得只有15次在你指导他们一年后做某事......  
有时你必须重新思考一个巨大的分布式系统的体系结构，因为我必须更改关键组件的编程语言，因为我无法雇用足够的开发人员，以体面的语言技能在更优选的语言中。  
