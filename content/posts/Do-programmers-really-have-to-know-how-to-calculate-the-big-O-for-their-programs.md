---

title: 程序员真的必须知道如何为他们的程序计算大o吗？
date: 2022-01-23T22:08:10+08:00

---




## 程序员真的必须知道如何为他们的程序计算大o吗？  
### 回答 1
Matt Laine的答案是完全正确的 - 软件工程师应该能够评估他们的计划的表现并相应行动，或者否则可能会发生坏事。  
例如，我的一个同事曾一旦写过一种通过反复删除第一元素来处理C＃列表的算法。他没有意识到这是一个O（n）的操作，这使得总时间复杂度o（n ^ 2）。  
不幸的是，它没有足够的效果来抓住测试，但它确实对生产中的一些重要客户产生了问题......  
### 回答 2
发生了什么是队列有点备份。这不是一个问题，除了检查队列中的成员资格是o（n）的问题，我们达到了队列足够长的地方，以便检查我们是否已经有SIMILA  
您无需了解有关校样和类似的信息的详细信息。你只需要一个想法，事情将会失控。  
这是一个例子：在生产系统中，等待处理的工作短队员。在向队列添加条目之前，完成了检查以确保该项目尚未在队列中。相当简单，对吧？  
发生了什么是队列有点备份。除了检查队列中的成员资格是o（n），我们达到了一个问题，我们达到了足够长的时间，检查我们是否已经在队列中有类似的条目需要时间超过时间。系统也无法从队列中删除条目。换句话说，队列只能运行，只要它少于X条目即可，它在大部分时间和测试期间都会进行。  
这是您必须了解的时间和空间复杂程度。我唯一一次听说实际上和正式使用Bigg o符号的时间是在20世纪80年代中期回到了大学时，​​他们试图将计算机科学成为实际科学。  
### 回答 3
不，不准确地说。但暴露于概念是好的。  
如果他们做任何最终有一些规模的事情，他们应该有一些相似的操作规模。如果描述这一点，符号是一种形式化的方式。如果它开始处理一些可敬的数据并学习如何避免问题，他们应该识别出荒谬的时间。例如：  
### 回答 4
能够为整个节目产生准确的大o计算复杂性很少必要，但是在使用非琐碎的数据大小并且相当容易时，在算法中具有直觉既非常有价值。让我们来看看它。  
假设我们在随机顺序中有5个随机数列表。  
[23,14,76,12,99]  
想象一下，我们编写一个软件功能来回答问题计算特定数量X中出现的次数，通过循环整个列表并将每个数字与x进行比较，递增计数器。该计划需要考虑的5个数字中有多少？答案是5，列表的长度。  
现在，如果我们制作任意大小列表，请说n个数字，这些数字中有多少个数字需要查看？答案是n，列表的长度。这称为程序的计算复杂性。  
我们将此写为O（n），每次执行函数时都意味着它会扫描n个数字，其中n是列表大小。这被称为Big-O表示法，因为我们在写它时使用一个大o。用英语，我们读到了这一点。  
考虑计算复杂性有两种主要原因。  
（1）在我们上面的简单示例中，如果我们的全部目标是回答关于一套数量的次数有多少次的问题，我们将要问这个问题真正大量的次数，我们可以做太多比O（n）好。  
理想的哈希表是O（1），因为我们采取了一个关键，基本上直接查找值。因此，如果我们将数据存储更改为哈希表，其中每个键是数字，每个值都是它发生了多少时间，然后我们可以使用这种新的数据结构来回答我们在O（1）时间内的问题（说明作为1次）。 o（1）当n = 5时并不多得多，但是当n = 10亿时，这是速度的10亿倍。  
（2）如果算法是O（n ^ 2）或更差，则在具有大n的数据集上运行它非常慢。可能无法在合理的时间内完成o（n ^ n）的算法。这个概念在很大程度上是加密学基于的。制作一个加密的Cypher，即使在最大的超级计算机上也需要100年的时间，并且可能足够安全，以保护数据长度比它更有用。  
----  
真的只有一个人需要了解一个，然后我们已经完成了。  
BIG-O计算复杂性不是整个故事。故事的另一部分是每个工作单位所采取的时间。在上面的情况下，我们正在谈论使用平等运算符进行比较列表中的数量。计算机真的非常快，因此比较个别数字真的非常快，大约是微秒的顺序。  
但是，如果我们的算法中的每个工作单元正在做一些更慢的东西（例如寻求旋转磁盘，写入闪存，或通过网络谈话），则每个工作单元都需要毫秒。同样，我们可以谈论某种硬件传感，相机或采集任务的算法可能需要几秒钟甚至几分钟。  
这里的重要课程是，当您的工作单元更长（例如，秒）和您的n大，那么算法的大o复杂性就会变得更加重要。  
就是这样。如果您了解所有这些，那么您知道计算复杂性的基础知识，您所缺少的所有内容都是常见算法计算复杂性的一系列经验和了解。  
### 回答 5
是的，因为你必须要识别你是否曾经做过某种东西，因为几乎没有任何程序要求将容忍，除非不可能做得更好。有时甚至下限都太慢了。  
这并不意味着你实际上必须在写它的规划意义上除了你的头脑中的任何地方。您有程序，您可以在代表性工作负载上运行它，您不需要*计算限制时计算*运行时间，当您可以在确切的情况下测量它们。在事实上，它几乎总是更好地测量运行时间而不是计算它，因为您的计算几乎与首先写入程序一样复杂。  
当您拥有最严重的要求时，实时实时，您不会做任何计算。您必须以特定方式编写代码，具体的工具将确保您获得所需的性能。 （好的，你不必，但它真的非常好主意，如果你不这样做，那么它就会更加艰难）大多数东西是最糟糕的，但是，像服务器和操作系统和视频游戏一样软。只要你几乎一直生产出来的输出很快，那就好了，它足够好。很难实时是你有什么东西可以完全x毫秒来计算答案，做的事情或火车会崩溃，人们会死的，因为你可能猜到，确切的运行时间是重要的，而不是极限的近似值（AKA大o）  
### 回答 6
因此，为什么在处理器/计算机上运行您的程序/应用程序是必要的  
韩国表演初创公司，强调了对分析算法的需要。现场基本上是，打破了2个程序的领带，而它们基本上锁定在精度上的虚拟死热量。虽然该程序具有略高的精度，但在针对劣质计算机的同时略有较高的速度，但主角被声明了获胜者，以便能够提供一个系统，同时在Threadbare系统上运行时保持其一致性。  
那么，为什么在几十年前在计算中有进步时，在处理器/计算机/手机上有必要在处理器/计算机/手机上运行？  
CPU已经使电脑有高效。虽然单核处理器已经处于Moore Law的限制，但Muti核心和MUTI线程处理器已经更快地计算并使得可以在各种应用中无缝多任务。  
GPU使得可以拥有图形和FPS（每秒帧）。 GPU已经让您在笔记本电脑上观看4K电影，并在众多游戏中找到人类反应的理论限制（抽搐射手，平台，打架游戏）。虽然GPU被销售为一个爱好者的努力，但他们通过高艺术，采矿和云计算为全世界的经济促销。  
张量加工单位已彻底改变了人工智能实施的方式。 TPU使您可以在手机上具有自然语言处理的服务器缩放处理，并为每个用户提供了使用翻译功能和文本的能力，以便在您的声音方便的方便。 TPU使得可以运行计算机愿景来在您的特斯拉斯上运行，并使其可以检测其他汽车，具有无可挑剔的准确性  
虽然计算的进步一直是必不可少的，并且影响了超级计算机的创建，量子计算机，虚拟和增强现实，但系统仍然设计与普通客户的普遍客户。像口袋妖怪的游戏，彻底改变了手持游戏，并带有数百万人进入一个经常被降级的生态系统（电话游戏），经常被降级到运行图形无能为力的生活SIM卡。虽然游戏仍然只有加强现实的初步实施，但它仍然努力处理全球所有客户。  
抛出钱和资源问题从来都不是世界上最大的媒体特许经营的关注。虽然niantiac（由任天堂，口袋妖怪公司和谷歌支持）能够解决这个问题，但并非每个开发商都休闲在该规模上进行实验，而且大o表示法有助于开发设计的时间和空间所施加的理论限制要求解决问题。  
### 回答 7
这是缺点，  
虽然您可能不会积极地雇用它，但在您看到它们时，理解和识别问题是非常重要的。  
在我工作的另一个日子，我们正在设置一些代码来收集数据库查询性能的数据。基本上，我们制作了一个表，每次在DB中执行查询时，我们也将此表与查询的查询名称，开始时间和结束时间更新。这样做，我们已经能够收集有关我们最好的和最糟糕的表演查询的大量数据，并希望能够改善功能的加载时间。  
当然，这一切的缺点是我们现在每次与它做任何事情时都会击中数据库。就是这样，让我问你：  
一个人应该为此表添加索引吗？  
索引很棒，对吗？他们让您更快地访问数据。由于此原因，我遇到了默认索引所有列的开发人员。但是，就像软件工程中的一切一样，索引是一个权衡。插入DB时，还需要更新这些索引。  
没有索引，插入该表是O（1）。但是对于索引，每个插入都变为O（logn）乘以索引的数量。由于我们将以字面上的每个查询表现，那么对数复杂度可能会非常糟糕。  
如果我和其他开发人员对编程中的渐近复杂性没有了解渐近复杂性，我们可能已经实施了这一点，并观察了应用程序中的重大表现。然后我可以让我想象与产品团队的对话。跟踪性能太贵 - 它损害了用户体验。这不值得。我们提出了我们寻求解决更糟糕的问题，最终失去了我们试图找到改进我们的系统的数据，因为我们不明白索引如何影响我们的大O.  
这是一个罕见的事情，我需要弄清楚任何给定算法的渐近复杂性我写的 - 这种方式的性能问题只是我现在正常工作的规模只是罕见 - 但它是要注意的情况非常重要我刚刚描述的那样。此外，您将迟早在您需要开始思考性能的位置，并且当发生这种情况时，您需要能够在您看到它时识别坏大O。  
简而言之，你能否在不理解这个的情况下构建一个应用程序？绝对地。你能成为一个强大的软件工程师吗？不。  
希望能帮助。  
### 回答 8
大多数开发人员都不知道大o是什么，更不用说如何大约计算它。此外，最不知道哪种算法是对的。  
### 回答 9
他们至少需要了解它。  
有几年前，我正在使用分析DNA序列的程序组。一个程序必须以序列读取在多行上的ASCII文本。别人用外观写入输入例程，将缓冲区读入缓冲区，并将strcat（）读到先前读入的零件上。听起来很好且简单。  
它是o（n ** 2）。  
在某个时候，我们正在使用高达10MB的序列（即10兆塔，而且还存储在ASCII文本中，所以10兆字节。）输入例程是程序最慢的部分。  
希望所有人都理解为什么strcat（）循环是o（n ** 2）。  
如果没有，那  
他们至少需要了解它。  
有几年前，我正在使用分析DNA序列的程序组。一个程序必须以序列读取在多行上的ASCII文本。别人用外观写入输入例程，将缓冲区读入缓冲区，并将strcat（）读到先前读入的零件上。听起来很好且简单。  
它是o（n ** 2）。  
在某个时候，我们正在使用高达10MB的序列（即10兆塔，而且还存储在ASCII文本中，所以10兆字节。）输入例程是程序最慢的部分。  
希望所有人都理解为什么strcat（）循环是o（n ** 2）。  
如果没有，那就是你需要计算它的原因。  
### 回答 10
短暂的答案是肯定的。学习如何计算大O是了解算法性能可能取决于数据集大小的第一步。严格说话，您无需为您的算法计算大O来了解这一点。  
另一方面，大o是科学研究的基础。如果您想在科学期刊中发布一些巧妙的算法，则需要大O.如果您为拓扑建模或类似的任务编写矢量代码（即MATLAB），则需要大O.  
### 回答 11
而我从未计算过  
程序员真的必须知道如何为他们的程序计算大o吗？  
我从来没有计算过职业生活中的复杂性。但我很高兴我在大学学到了它，因为它给了我对一直出现的问题的基本理解。  
它归结为我概念化为程序控制流程的“形状”。即使你从未准确计算过东西，这通常是非常重要的。它有助于您了解您应该或不应该循环或重复的地方，并构建您对如何构建代码的思考。  
虽然我从未计算过复杂性，但我已经测量了它。与教科书的示例不同，其中原始操作为您为您定义，在现实世界中，它不一定是明显的，您需要小心。线性比二次级更好比指数更好，但是当您有交互系统时，可能使用本地指数算法更好地关闭，以避免涉及I / O和远程呼叫的某些操作的线性增长！但是，一次或两次IVE在合成数据集和经验测量的生长因子上设置基准，以帮助弄清楚问题的位置。一旦我最终将一个函数优化到如此难以理解的东西，即我在功能中使用的线条少于注释，解释为什么没有人应该将其重写为更明确和可维护的版本......这是在一个系统ID中没有对数学建模的希望但是，我可以并确实在不同的输入大小和绘图n与运行时间上运行它，以及分析，看看代码的哪些部分与总时间成比例。在任何时候，我实际上使用数学超出了我需要在电子表格中制​​作图形的数学，但学习计算复发关系是建立了我原油方法工作的直觉的原因。  
### 回答 12
所以只是血腥学习它  
如果没有知道如何做到这一点，你可以成为一个程序员。  
然而，一个好程序员可以解释他们的程序的性能如何与输入的大小扩展，大问题是被发明的数学术语表达。在不了解它的语言的情况下，很难对算法的可扩展性特性进行任何准确的陈述！  
此外，人们假装这是这个噩梦的概念，这将杀死他们必须学习。实际上，它实际上并不复杂，至少基础是不是。  
所以只是血腥的学习！无论你是否真的都要少了痴迷时间就花了更少的时间。  
### 回答 13
我想这取决于你的意思。对我来说，通常足以知道算法小于指数。有时我需要知道n ^ 2和n ^ 3之间的区别。我不记得我最后一次需要知道它是否是log n或n log n或log（log n）。大多数时间都足以知道该算法并不令人震惊。  
### 回答 14
Ill Echo Alan Mellor和其他人说，对无症状复杂性（大O）更重要。  
知道哪种操作昂贵。如果n小，则磁盘读取可能比O（n ^ 3）循环更昂贵。  
表现的实际概念比严格的性能理论更重要。  
那说......  
如果您申请了研究职位，最好是正式了解无症状复杂性。  
另外，如果你是一个新的毕业生。此时，您可能有更少的实践经验，面试官可能会检查您在学校注重关注。  
有  
Ill Echo Alan Mellor和其他人说，对无症状复杂性（大O）更重要。  
知道哪种操作昂贵。如果n小，则磁盘读取可能比O（n ^ 3）循环更昂贵。  
表现的实际概念比严格的性能理论更重要。  
那说......  
如果您申请了研究职位，最好是正式了解无症状复杂性。  
另外，如果你是一个新的毕业生。此时，您可能有更少的实践经验，面试官可能会检查您在学校注重关注。  
还有一些大型技术公司会问这些问题。了解他们是否确实问了他们，​​然后准备面试。  
在其他情况下，人们不会如此严格。  
### 回答 15
一般来说，是的。  
我需要知道如何为我的程序估计大o。我不需要经常这样做。我不需要精确计算代码的O编号。我不需要为整个计划做到这一点。但我需要为它的关键部分做到这一点。  
我需要做什么：  
在20年作为软件工程师工作期间，由于算法的低效选择，我的代码有很少的时间。很少有，但他们是至关重要的。当我不得不为LZW或BZIP2算法实施解压缩器时，最令人难忘的是我的第一份工作。我决定削减角落，并使用常规泡沫而不是Quickssort。结果，我的代码几乎无法使用。  
随着时间的推移，我几乎本能地开始为我的代码估算大问题。  
### 回答 16
我们这样做，虽然现实上，说我们想要了解大欧米格或大职，但它真的很准确地说我们想知道我们的算法是否是或不是子地区。二次（即，大欧米茄或n个平方的大θ）或更糟糕的是坏事。子地区是可接受的。  
Knuth中的定义是（我希望）非常简单。如果您有兴趣，请参阅第1.2.11节。IIRC，您只需要了解限制理论，因为大o及其朋友只是运行时的渐近极限。  
### 回答 17
技术上不，但你*真的应该。  
非常同样，会计师并不需要知道如何添加和乘以数字以管理您的财务状况，因为它们可以使用计算器为它们执行此工作，即使他们真的不知道如何添加和乘以。  
但我不会雇用这样的会计师。  
### 回答 18
有一个很好的理解  
不是那么多，但是对常见数据结构和算法的时间复杂性和实现的理解很重要。例如，如果您正在编写某些阵列/向量/尺寸M的阵列/载体列表中的代码，并且在此阵列中执行线性搜索，那么知道这是O（m * n）并赢得了对于大的m和n刻度很好。并且，一些更好的选择可能是保持阵列排序和使用二进制搜索，或者使用不同的数据结构，如地图或哈希表，可以让您O（n log m）或更好，并且明显更快。  
对数据结构和算法具有良好的理解，以及它们对各种操作的一般属性和时间复杂性非常重要。一旦我分析了一些花费太长的代码，并且在其他事情中使用MFC CMAP类，其中内部使用哈希表。现在，设计良好的和正确使用的哈希表可以在最佳情况下获得O（1）查找。但是挖掘MFC源代码，我看到这个哈希表正在使用一个固定大小的数组，17我认为它是，而且永远不会越来越多的内部阵列，导致许多哈希冲突。我们正在将成千上万的元素放入其中。所以基本上在哈希找到正确的桶后，代码正在在该桶的链接列表中进行线性搜索，以查找所需的元素。因此，我无耻地复制了MFC代码并修改它以创建自己的版本，它将动态地增长哈希表大小，因为添加了元素。了解哈斯赫表的工作以及它们的属性是如何理解和解决问题的关键。  
### 回答 19
在我的经历中，这很少发生。通常有人在设计讨论中的优化讨论期间或更早地提出它。  
现实世界的程序员通常采取最实用的方法，即，我的计划是否在分配的时间和资源框架内做了什么？如果答案是肯定的，则没有更多的讨论。基本规则是机器时间总是比编程器时间便宜，除非在计算资源或时间内有巨大的节省，否则您只需将其留下即可。  
但是，如果您正在使用受限制的资源或时间，实用方法是配置代码。它的原因是，任何现代的非琐事程序都将使用一堆库，并且这些图书馆将使用其他库，并且绝对没有办法了解所有这些的复杂性，除非您阅读所有代码。但读取库代码击败了使用库的目的，因此除非读取库代码的具体原因，否则您不会这样做。但是，您所做的是您的代码的个人资料。您在探查器中运行代码，您可以在您的代码中学习最多的时间。  
代码分析经常返回惊喜，您的代码花了很多时间在您永远不会想象的地方。特别是，当您使用除其预期目的之外的其他内容的库时，会发生这种情况。然后您以适当的方式优化代码。您可以重写代码位，您可以更换您使用的库，可以优化您的数据，以便您需要更少使用昂贵的操作，您可以为您的数据介绍缓存，因此您不必经常获取它，解决方案是多样的，也是如此问题。  
一般来说，您很少需要计算您程序的复杂性，实用方法是更常见的。  
### 回答 20
你在这里得到了很多答案，这不是真的  
但这取决于......这取决于  
对于你可能做的大部分工作，它并不重要。对于一些工作，它确实很重要。  
在典型的业务应用程序上工作，您可能会很少有此类讨论。  
我创建的一个产品是一个数据库  
我可以向你保证，当我们在建造东西时，有很多地方发生了大o讨论的地方，因为......嗯，在建造这样的事情时你需要拥有它们。当我们在索引中有一个哈希碰撞时，实际发生了什么？我们最糟糕的情况是什么？  
你在这里得到了很多答案，这不是真的  
但这取决于......这取决于  
对于你可能做的大部分工作，它并不重要。对于一些工作，它确实很重要。  
在典型的业务应用程序上工作，您可能会很少有此类讨论。  
我创建的一个产品是一个数据库  
我可以向你保证，当我们在建造东西时，有很多地方发生了大o讨论的地方，因为......嗯，在建造这样的事情时你需要拥有它们。当我们在索引中有一个哈希碰撞时，实际发生了什么？我们可能看到的最坏情况是什么？这可能是病态的，需要在生产中发生之前被思考。  
### 回答 21
重要的是要记住那个符号背后的想法，因为是一个有效的团队沟通的被证明的工具。所以它不是严格必要的，但它是非常可取的。  
### 回答 22
我们遇到了许多例子，这就是Buil的本质  
不完全，但我想我可以在没有殴打死马的情况下添加一些东西，并重复其他人都在说什么。  
大O的基本思想与速度快速制作课程，因为它是关于了解计算资源的限制，以及您的代码可能会影响到这一点。  
例如，我们知道如何从点A到B获取，但计算机无法有效地执行此操作，因此我们必须使用不同的策略来解决这个问题。这是经典旅游推销员问题，一个难题的问题。  
我们遇到了许多例子，这就是建立超出基础知识超出任何规模的软件的本质。您可能不得不考虑记忆和速度。  
大学课程使用排序算法，因为它是概念最简单的插图，但是一个好的程序员可以将这些想法应用于更复杂的例子。至于各种类型，我们编程语言中的功能将比我们可以在99.9％的时间内写入的更好。  
### 回答 23
不，但他们应该能够感觉到它，至少大约。如果您处理大量数据，它通常变得重要，否则您可能会自由地忘记它。  
例如，如果在它们中的每一个中使用N个元素（或其他号码）的线性循环，则每个循环大致有助于新的O（n）产品项。在分割和征服算法的情况下，通常是O（n * log n），用于二进制搜索它是o（log n）等。  
顺便说一句，有时编译器可以优化某些类型的循环，因此它们变得更低的复杂性。有时候，很少在程序员的现实生活中。甚至那么，还有许多其他因素影响程序的性能，例如您的数据结构和算法是缓存/存储器/线程/资源/注册友好等。  
### 回答 24
你必须有一个感觉，你必须有一个意义对它的重要事件。  
如果您正在拍摄用户输入或给用户输出，请忘记它 - 没有人关心，计算机比人们快得多。  
如果您从股票代码中获取输入并将计算写入磁盘，那么您应该知道。  
如果您在喂养实时医疗设备，那么您该死的更好。  
### 回答 25
这是一个相当常见的技能，很少（虽然不是永远）所需的;没有那种能力是一个小小的缺点，而不是一个主要的缺点（如果需要，你可以问团队中的别人寻求帮助......如果你自己编写了编码，那么就没有办法对这些问题有关的规模）。  
但是，当您需要能够计算该价值时不知道何时更严重。  
### 回答 26
另一方面，您可能想要驾驶赛车并推动违法行为  
是的！这就像询问司机是否真的需要知道如何改变他们的车辆的档位。  
当然，如果您在完全平坦的区域中驾驶自动传输，那么您不需要非常做。但是这一天你可能决定乘坐公路旅行到落基山脉去滑雪。您将不得不驾驶大量陡峭的倾斜和下降。如果您不知道如何换档，您将通过刹车片穿过刹车垫，并了解侧面的失控车道是为了艰难的方式：/。  
另一方面，您可能想要驾驶赛车并推动速度的边界。是的，你需要了解一些Snazzy双夹紧技术。  
更广泛地说，我发现很多这些Quora问题是相当于我真的需要流利的法国人成为一名法语时，我只想订购咖啡吗？不，你不需要流利地订购咖啡，但是你这样做是为了成为一个实际讲法语的人......除非你很高兴成为这个陌生人坐在一个不明白任何人的角落里偶尔跳起来，每次跳起来喝咖啡......  
### 回答 27
脚注  
我是我博士的一部分。复杂事件处理的论文工作（A.K.A.事件监测/事件组成）[1]。我会说程序员实际做到这一点罕见，它需要很多工作。我使用复发关系做了我的，当我解决了他们时，我必须考虑基于启发式的渐近方面，以简化复发关系。我还基于运行实验证实了时间复杂性。  
<a> [1] </a>  
但是，正如许多人所提到的那样，专业程序员对此感受/直觉及其后果。如果您实施/设计算法，则必须遵循数据结构，并且数据结构必须设计为适合您的算法。该组合通常应求解一组相关问题，而不仅仅是一个相关问题。在设计算法和数据结构时，应解决关键问题，其中经常使用关键问题和/或（真的只或）对结果产生重大影响。它是一个批处理问题，在哪里可以进程处理数据？数据是不可变的吗？在您运行您的算法时可以发生变化，以及如何处理那个？  
无论如何，您通常可以查看数据结构，考虑您应该做些什么并弄清楚复杂性。但是，如果您应该比较两个相同复杂度（类）的算法，那么它变得更加困难。您可以通过推理来估计这一点，但有些情况令人棘手。通常，您比较不同复杂性的算法，然后唯一的问题是如果您处理大批数据（如果它很小，则其他因素可能比复杂性更重要）;例如，在Java中，您会注意到哈希映射和树映射之间的差异约为100.000秒的对象。  
就个人而言，我从数据结构开始（OOP的焦点），并在这样做时考虑功能。基本上，我尝试优化用于关键需求的数据结构，从而管理可扩展性和性能。例如，如果您可以遵循鸿沟并征服策略，则获得类似O（x log n），其中x基于您对数据的作用，并且日志n必须处理搜索/迭代的部分数据。在这种情况下，您可以通过对索引进行排序或通过维护索引来执行此操作。  
脚注  
### 回答 28
不，但他们必须知道计算复杂性作为概念。  
此外，只要您正在进行新任务，您需要确保您处于最低可能的Compslexity类中为您的问题。否则，您的Web服务器将需要90秒才能响应，并且您将能够在Web服务器上支持4个用户而不是10000。所有因为您没有将小丑从汽车中拿出来。  
此外，如果您不了解算法复杂性，您将被降级到The The Crud应用程序直到时间结束。  
### 回答 29
在一些数学应用程序中，我写的是我需要知道程序是否在某个时间范围内完成（例如我的生命周期），并且知道大O是有用的。  
### 回答 30
取决于程序员正在进行的工作，它有很大的变化，它有点取决于你的意思。很少有程序员做出如此严重的算法开发，以至于它们必须对异国情调算法进行复杂分析。但是，重要的是严重程序员对时间复杂性的一致了解，并且知道如何构建没有严重问题的算法。在实践中，这通常意味着选择从中构建更大算法的尝试和真正的算法，因此程序员很少实际上直接考虑时间复杂性。更重要的是他们对它有直观的理解，并知道如何避免陷阱。  
当然，要理解的另一件事是，在任何主要的软件中，通常只有一个微小的软件都包含任何有问题时间复杂度的算法。绝大多数软件是通常是线性时间复杂度的结构代码。换句话说，对于绝大多数编程工作，时间复杂性并不是一个问题。  
### 回答 31
不经常。您莫尔常常需要能够判断给定的算法是否比特定O刻度得多。如果您尝试竞争算法的影响，则可以在规划阶段中使用。虽然我的知识EOF算法复杂性绝对是指导我所做的决策，但我从未明确计算过，但了解如何和影响的知识可能是最重要的。  
### 回答 32
正如其他回复所指出的那样，程序员需要具有可扩展性的感觉。他们需要知道（以及其他事情）是什么指数增长，以及它如何影响他们的计划。  
我记得一个用户问我是否可以编写一个程序来打印出一堆字母，在某个代码中可以混合。  
我并不完全确定他们想要的东西。是的，我可以编程。如果您知道如何编程递归，它真的很简单。  
即使产生所有组合也会在这种情况下采取合理的时间，因为代码相对较短。  
问题正在打印它们。该计划将印刷数百万代码基本无用的信息。  
所以我所做的是，一开始就告诉用户请求这一点，关于国际象棋的起源的传说。然后我向他们估算了在这种情况下结果的大程度。  
### 回答 33
程序员真的必须知道如何为他们的程序计算大o吗？  
我从未听过大型讨论的程序。原因是大o描述了算法的渐近运行时间。除了用单一用途设计的程序外，仅执行单个算法，它不会延伸到程序。虽然它当然可以讨论一个完整程序的聚合，这涉及讨论渐近行为，而该程序实际上并不是在尺寸接近无穷大的输入上运行。  
此外，没有办法指定每个程序的大o行为。这个问题与停止问题有关。如果我们无法确定程序是否停止，我们当然无法说明它是否是有限的或无限的。  
### 回答 34
我不知道如何计算任务的复杂性。有两个关键的想法：了解大o，并了解它是如何谎言的。它确实如此。  
例如，假设我有一个问题以排序顺序存储10,000个32位整数。将有很多插入和删除。我应该将它们存储在列表中还是在数组中？  
BIG-O可能会建议插入和删除的列表更快。但它不考虑找到插入或删除该项目的地点的成本。此外，如果将其存储在列表中，每个列表单元将在开销的64个字节的顺序中添加，这涉及大量的存储空间。此外，根据插入和删除的数量，元素可以散射全部内存。这意味着页面错误。每个页面错误比缓存命令慢七个数量级。 Big-O表示法告诉您计算尺度增加的域大小，但它并没有告诉您O（f（n））真的意味着c * f（n），其中c是比例常数，a单一操作。除了它不是一个常数;多级缓存和页面故障意味着在每个计算上，您不知道它是否成本1或成本300,000,000，因此这种变化违反了大o符号的基本假设。三阶效果可以杀死你。拒绝数组表示最终更快。这是几十年前在Lisp机器的设计中被证明的。  
### 回答 35
知道怎么？是的，这不是那么困难，但乏味，需要一段时间。然而，您没有真正需要，因为您应该在经验中，能够觉得某些东西会以高速表现出来，EX。制作一个游戏并说它像100个敌人一样可以立刻在屏幕上，它不会滞后  
### 回答 36
大o指的是算法而不是程序。根据他们使用的排序，索引或搜索算法，他们将理解他们的程序所需的时间和空间。  
### 回答 37
对于现实世界的编程，它是一个经验的规则。  
看看你的循环，询问它最大可能的操作的大问题应该是什么。将循环的顺序乘以。因此，如果您有带有行和列的图片，并且您对每个单元格执行DB查找并编写。最慢的部分是写入。让我们说出它的成本= n x（log_128（n）-2）（因为你的记录可以适合每个磁盘页面和它的b树。预期50％的占用率，并且前两个级别几乎总是缓存）。注意其n，而不是n ^ 2，其中n是宽度倍。这是正方形和双回路的事实是一个诡计。上面的大o是n log n。但是您可以估计最慢的操作的实际数量：IOPS。  
现在，如果您想计算具有连接的DB查询的成本，则YOUD在表1中具有n个记录，以及表2中的M记录。您扫描表1，但在表2上执行日志M查询（记住该日志基座128和负2更逼真）。所以我们有n x log m，buut。当n接近无穷大时，m看起来更像是一个常数。我们的查询实际上是o（n）。然而，这是一个他妈的迟到的估计。我的拇指规则是将m作为n（这是谎言，而是更有用的估算者）  
现在想象一下，我们的存储过程，对于表1中的每个元素，基于一些非索引约束来计算表2中的过滤的计数成本。即我们漫步表1，查看属性和Requery表1（所有记录），然后加入对表2的每个元素（我们的日志M表）。现在我们有n x n x log m.如果我们眯起其很难是n ^ 2 log n.清楚地，谁写它并在共享生产硬件上运行应该被解雇。因为创建一个临时表可以摆脱连接，然后将n ^ 2缩小到n log n的地图减少算法，所以现在你在最坏的情况下有n log n + n log m。 。或者只是n log n的大o（用良好的地图减少，你的日志基础是100万，而不仅仅是128）  
最后部分是理解大O非常有用。为什么在AWS的Hadoop或EMR上花费很多钱，而刚刚在Postgres中运行了查询（并且必须解释为CTO的原因）是良好和坏产品/公司之间的区别。  
更常见的二进制树与哈希映射O（n log n）vs o（k）对话是bs，因为这假设您可以将随机存取存储器扩展到无穷大（如您可以使用基于网络磁盘的DBS）。哈希似乎甚至在小规模上几乎总是更快的哈希。  
### 回答 38
它不是计算。它关于大o（）代表的定义。  
举例：  
a = b * c  
是O（1）吗？  
好吧，我们假设是。但在这个例子中，缺少一个重要的事情，这是值的类型。因此，只有当这些数字被告知整数时，它将是O（1）。  
假设数字是大小的1000个二进制数字。  
即使您的语言像Mathematica，Matlab或C与支持数学的图书馆，表达式仍然是表单  
但后面的编译器将生成此类计算所需的两个嵌套环。外循环用于迭代B和内部的块  
它不是计算。它关于大o（）代表的定义。  
举例：  
a = b * c  
是O（1）吗？  
好吧，我们假设是。但在这个例子中，缺少一个重要的事情，这是值的类型。因此，只有当这些数字被告知整数时，它将是O（1）。  
假设数字是大小的1000个二进制数字。  
即使您的语言像Mathematica，Matlab或C与支持数学的图书馆，表达式仍然是表单  
a = b * c  
但后面的编译器将生成此类计算所需的两个嵌套环。外循环用于迭代B和内圈的块，用于迭代C组，转换它们并应用求和。  
所以它还是o（1）？  
这是Big-O（）表示法的问题。您必须知道某些特定的代码如何在某些特定硬件上执行。  
在具有并行硬件乘数的假设CPU上，让我们说1024位仍然是O（1），但在日常计算机上它不是。当您继续增加数字数量时，它变为O（n ^ 2），其中n表示由硬件乘数的块大小除以划分的数字数。  
### 回答 39
我在其他帖子中介绍了这一点，但我会在这里重复，因为它是一个重要的主题。首先，在大学中，您有三个基本课程（和数据结构。）基本课程，高级课程和数学分析课程。最后一门课程几乎总是毕业计算机科学课程，学生需要强烈了解基础知识，因为算法分析通常是毕业计划中最具挑战性的课程之一。  
但中产阶级也有一些数学分析。通常是学生学习大O的课程。你学会一般应该做的是什么以及你不应该做什么（总有例外！）。高级数据结构类开头的一点数学有助于学生了解他们为什么需要了解此东西。  
每天都是人们计算大O？不。不是大多数工作。除了求职面试外，人们还记得大o吗？不。再次，不是典型的工作。如实，我认识那些梦幻般的Web开发人员 - 比我更好 - 谁没有，因为现代框架隐藏了它们。只知道这些东西不会让你比那些没有的人更好。  
它有用吗？绝对地。一些工作确实要求人们了解算法。  
### 回答 40
这是我的秘诀。  
如果您想了解大O，只需运行不同数量的数据样本S这样的代码S 1,10,100,1000或更多，并且计算它运行的时间。  
大o用于告诉如果增加数据样本，则会判断一部分代码的一部分代码。你不需要准确，但你应该知道粗略估计。  
大o是上限。  
### 回答 41
我是一名程序员的懒惰恐龙，他们可以节省努力。  
我可以计算'大o'？是的。  
我吗？如果我能帮助它。  
我的重点是问题。错误的答案快速比正确的速度更慢。  
那个泡沫排序我写道（最糟糕的是*），谁在乎？它是用于排序有计算机等待的100个记录，同时用户在用户键入中，然后再次等待它吹口哨Dixie暂停串行端口吐出。  
然后有多百万记录银行申请转换，在漫长的周末运行中需要72小时。这需要8个小时  
我是一名程序员的懒惰恐龙，他们可以节省努力。  
我可以计算'大o'？是的。  
我吗？如果我能帮助它。  
我的重点是问题。错误的答案快速比正确的速度更慢。  
那个泡沫排序我写道（最糟糕的是*），谁在乎？它是用于排序有计算机等待的100个记录，同时用户在用户键入中，然后再次等待它吹口哨Dixie暂停串行端口吐出。  
然后有多百万记录银行申请转换，在漫长的周末运行中需要72小时。扫描文件需要8小时。我的客户匹配分部24小时分配（是Bryan White'的同一个人'B White吗？电话号码看起来类似但不同的前缀）。然后其他部分花了太久;我可以减少我的吗？  
经过一些研究，我说'是的;给我2个小时，他们说是不可能的。  
不，如果我之前的一周匹配每个人，那么只需匹配这些少数，从那时起，漫长的周末就会有记录的更改。哦。这是一个好主意。  
'大o'甚至看起来都看起来。  
*好的，是的，你可以写得更糟糕，但我在这里是平淡的。  
### 回答 42
不是特别的，它真的可以是非常人为的，而它给出了对潜在问题的粗略期望，而不是确定代码的唯一方法是合理的。  
最准确的方式是体面的性能测试。您只需要勤奋，并确保您可以达到更糟糕的输入和用法的情况。其中在于优势，它通常是并发访问的动态，导致问题或像缓存和内存大小等阈值因素，或锁定和信令限制。您还需要大衡边缘收益是否值得额外的代码时间。一个月运行一次，几小时内运行的操作不需要优化（在原因内）。时间将更好地花费在其他地方优化或做更多的测试来检查代码的逻辑。在现实世界中，您必须准备延长时间贸易，我们并不真正有不断追逐完美的奢侈品。  
考虑到在现实世界的节目中常常有多少点，以确保质量，我永远无法设想时间将更好地花费计算复杂性过度测试的情况。它纯粹是一个学术工具，让新的程序员了解写作代码时要了解的内容。当您在商业上编写代码的时候进行编写到生产，人们希望您有足够的掌握，以便不需要正式做到。您应该能够查看您的代码并在其运行中的上下文中了解其影响。  
当然，这就是这些日子往往倾向于崩溃的地方。似乎新一代编码器并不真正了解其代码的影响。对他们来说，这是魔法，更像是吟唱一个咒语，然后一些仙女来了做这项工作。代码和实际操作之间的连接已丢失。人们维护您不需要在这一深度时知道的事情，但他们的系统否则证明。您可以抛出硬件一段时间，但最终的成本且往往是差的可扩展性意味着它达到了限制并停止工作。更多地编程比知道如何分配变量并写入循环。不幸的是，行业似乎忘了。  
### 回答 43
虽然当我们编程我们从未计算过'正式'算法的效率，但研究了如何做到这一点，以便意识到计算资源，主要是时间和内存非常有限。  
在我的经验中，您可以轻松地常常看到已经研究过“正式效率算法分析”和那些没有的程序员的差异。  
### 回答 44
在30多年的写作代码中，我从来不得不明确计算大O.我们基本上只是避免用已知的病理性能特征（泡沫分类，线性搜索等）写作任何东西。  
鉴于现代语言提供现在管理数据的各种漂亮的内置容器（词典，地图等）真的不需要。  
### 回答 45
这是一个非常可怕的视频。（对于记录，它在这里。我不会花太多时间撕裂它，但它很浅，误导，偶尔是平凡的。它甚至没有提供大O的定义！） 。你多么需要了解大量符号，我不能告诉 - 我的妈妈没有知道关于它的任何东西，也不知道一个合理的快乐和完成的人。但是，如果你想了解如何研究职能的增长，包括算法分析，然后你应该找到其他来源来学习这一点，而不是这个YouTube视频。知名的东西是绝不是能够背诵定义。我会在片刻里给你一个大o的定义，它相当短明确。在一个正式的意义上，这就是你需要知道的一切：只有其他一切都可以从它中衍生出来。然而，现实，学习使用，申请和玩大o表示练习，耐心和时间。永远，曾经期望知道你需要了解的一切主题从youtube上的5分钟视频。结构围绕着理解的学习，而不是可怜的快捷方式。你知道所有你需要了解大问题，当你能够有效和一致地解决与它相关的问题时，而不是你的问题在Quora.ok上看了视频或阅读答案。 Big O表示法意味着：我们有两个功能f（n）f（n）和g（n）g（n），以自然数nn为实数为输入和返回值（这可以进一步概括，但是现在没关系）。我们这么说  
f（n）= o（g（n））f（n）= o（g（n））  
如果满足以下条件：存在一些阈值N0N0，以及一些相称常数CC，以及  
| F（n）|≤c| F（n）|≤c| g（n）| g（n）|  
每当n≥n0n≥n0.in：f（n）f（n）是g（n）g（n）的大o，如果g（n）g（n），也许乘以某种东西，则最终大于f （n）f（n），如有必要地看绝对值。这一切都是寒冷的，形式的定义，就像我在某种意义上说这是你所需要的。但是你可能觉得定义是不透明和混乱的定义如果你以前从未见过这一点，这很好。努力工作是通过它的意义来源的，为什么它的建造以及如何使用它。大O表示法的使用延长以允许O（g （n））O（g（n））在表达式，方程和不平等中更灵活地显示出更灵活。例如，  
n2 + o（log（n））n2 + o（log⁡（n））  
表示具有n2 + f（n）n2 + f（n）的形式的函数，其中f（n）= o（log（n））f（n）= o（log⁡（n））。我们没有指定f（n）f（n），我们甚至没有打扰它一个名字：我们关心的是它是O（log（n））o（log⁡（n））。以这种方式您找到了例如，陈述  
log（n！）= nlog（n）-n + o（log（n））log⁡（n！）=nlog⁡（n）-n + o（log⁡（n））  
这表达了log（n！）log⁡（n！）的事实由nlog（n）nlog⁡（n）主导，并且下一个最有意义的贡献是-n-n术语，然后有一些剩菜这少于日志（n）log⁡（n）。这是一个理解斯特林的近似的一种很好的方式。您可能已经注意到，在定义中没有发现这个词算法.big o表示法在分析中非常有用算法，但它在一百个其他环境中也非常有用。在任何关于学习分析数字理论的人（Bachmann，Landau）的人的算法复杂性思考之前是很久的发明。我们在19世纪末谈论了这一点。现在，为什么这个定义？大o符号的目的是帮助我们研究职能的增长。当在组合者的表达式，数字理论，复杂性理论，复杂分析和其他地方分析表达时，了解最终会赢得胜利，以及最终赢得谁通过多少。例如，如果您比较函数10n10n和n！n！，您可能会发现，最初，10n10n是更大的。检查n = 1,2,3,4,5n = 1,2,3,4,5甚至n = n =的那些函数的值。 10n = 10;你怎么看？似乎10n10n赢得了一夜之间。<ol> n = 1：10与1 n = 2：100 vs 2 n = 3：1000与6 n = 4：10,000 Vs 24 n = 5：100,000 Vs 120 n = 10：10,000,000,000 vs 3,628,800 </ OL>  
<li> n = 1：10 Vs 1 </ Li>  
<li> n = 2：100 vs 2 </ li>  
<li> n = 3：1000与6 </ li>  
<li> n = 4：10,000 vs 24 </ li>  
<li> n = 5：100,000 Vs 120 </ li>  
<li> n = 10：10,000,000,000 vs 3,628,800 </ li>  
然而，这是误导。NN继续生长，n！n！赶上并最终超过10n10n。当n = 24n = 24时，10n10n大于24的60％！24！，但在n = 25n = 25时比36％更小，事情迅速从那里升级。  
### 回答 46
你在马之前有车。  
大OH表示法通常用作描述时间和空间的算法复杂性的方式。通常我们谈论时间复杂性，但有时候空间复杂性也很重要。  
大哦捕获渐近行为：也就是说，随着问题大小的大小，运行时间或空间如何长大地增长。它不会捕获恒定因素，它并不真正捕获处理小输入的成本。  
一些算法具有比其他渐近复杂性更大，而每步（恒定因子）具有更低的成本。对于有界输入大小，较高的复杂性算法可能赢得性能方面。  
例如，由于分支行为更简单，因此我发现了一个应用程序中的线性搜索击败二进制搜索，并且我有一个相当小的数据集以搜索。 （我将XML标记与动作表相匹配。线性搜索也是如此。）  
你会注意到我还没有提到循环。循环，嵌套或否则，是算法定义的一个方面。他们既不好也不糟糕。  
额外的循环嵌套并不意味着更大的算法复杂性！  
例如，如果我使用蛮力DFT来计算一些数据的傅里叶变换，则具有两个嵌套环和O（n2）O（n2）复杂度。如果我使用Cooley-Tukey FFT，它有三个嵌套环，但是为O（NLGN）O（NLG⁡N）。  
<OL>算法迭代-FFT输入：N个复数的Array A，其中n是2.输出：阵列A的DFT。位反向拷贝（a，a）n←a.s.Sthgstengths的length of s = 1到log（n）do m←2sωm←k = 0到n-1 by mdoω←←← 1对于j = 0至m / 2  -  1 do t←ωa[k + j + m / 2] u←a [k + j] a [k + j]←u + t a [k + j + m / 2]←U-TΩ←ΩΩ返回a </ OL>  
<li>算法迭代-fft是</ li>  
<li>输入：n个复数的数组a，其中n是2. </ li>的功率  
<li>输出：阵列a的dft。 </ Li>  
<li> </ li>  
<li>位 - 反向拷贝（a，a）</ li>  
<li> n←a.length </ li>  
<li>对于s = 1来日志（n）do </ li>  
<li> m←2s </ li>  
<li>ωm←EXP（-2πi/ m）</ li>  
m为k = 0到n-1 by m do </ li>  
<li>ω←1 </ li>  
<li>对于j = 0至m / 2  -  1 do </ li>  
<Li> T←ωa[k + j + m / 2] </ li>  
<li> U←a [k + j] </ li>  
<li> a [k + j]←U + T </ Li>  
<li> a [k + j + m / 2]←U-T </ LI>  
<Li>Ω←ΩΩm</ li>  
<li> </ li>  
<li>返回</ li>  
因此，尽管具有更深的循环巢，FFT方法应该比足够大的输入的DFT方法快得多。  
最后：通过使用循环计数器创造创新，我经常可以轻松地将n级循环嵌套转换为n-1级循环巢。这并不会改变算法复杂性，但它可能会改变恒定的因素 - 有时更好，有时更糟。 IIRC，我们的DSP实现FFT将所有三个级别的Cooley-Tukey循环嵌套折叠到汇编代码中只有一个级别，并且它是一个大的胜利。  
大哦只是一个说明算法的渐近行为的符号。嵌套循环仅仅是算法实现的一整面。  
天真地连接两人并匆匆跳到结论将是糟糕的做法。您需要了解算法的行为和成本，以及适用于您的应用程序的典型输入，以便您知道它的表现方式是如何现实的。  
### 回答 47
基本差异在于您选择在每个步骤中添加旁边的边缘。  
在Prims中，您始终保持连接的组件，从单个顶点开始。您将当前组件的所有边缘视为其他顶点，并在其中找到最小。然后，您将相邻顶点添加到组件，将其大小提高1.在N-1步骤中，如果我们有连接的图形，每个顶点将合并到当前一个顶点。  
在Kruskals中，您不会保留一个连接的组件但是森林。在每个阶段，您可以查看全球最小的边缘，不会在当前森林中创建一个循环。这种边缘必须必须将两棵树合并到当前的森林中。由于您从n个单顶树开始，在n-1步骤中，如果图表连接，它们都将合并为一个。  
### 回答 48
是的。 BIG-O真的只是对大型输入大小有趣和有用。例如：当输入大小很小时，泡沫排序（O（n ^ 2））通常可以比大容量或Introsort（O n Log n）更快。  
O（1）代码可能花费大量常量设置数据结构，该数据结构将使任何输入大小启用O（1）性能。如果执行程序在执行少量输入，则设置O（1）机制的时间可能需要长时间的时间，只需使用Naive O（n！）或o（n ^ 2 ） 算法。  
如果您询问O（n）是否可能比O（1）更快，答案是否定的。但是，对于小的输入（以及小的是依赖于情况），甚至o（n！）或o（n ^ 2）可以比O（1）更快。  
### 回答 49
我的看法是，任何为生活编写代码的人都应该理解大O的想法。他们不需要提出严格的数学证据，表明代码片段是O（无论如何）。  
对于实际工程目的，大O基本上了解问题的大小与解决这个问题的时间之间的关系。  
o（1）意味着解决问题所需的时间不会根据问题大小而变化。例子：  
o（log n）意味着完成算法需要的时间将以问题大小的增长为基础上增加。这显然不如O（1）那么好，但它仍然很糟糕。  
因此，想象一下，Foobar（x）需要执行log（x.size）操作以提出其返回值。假设每个操作都需要.1微秒。所以（舍入）如果x为尺寸1000，则log2（1000）= 10，因此完成时间（在完美的世界中）将是1微秒（10 * .1微秒）。现在，X有多大的是将1微秒的时间加倍？嗯，log2（x）= 20  - 解决x。拒绝答案是1,000,000.0。因此，问题尺寸必须增加一千倍，因为它需要加倍。  
O（log n）操作的示例  
1-使用二进制搜索或二进制搜索树在排序阵列中找到一个数字  
2-从平衡二进制搜索树插入或删除项目  
3-使用欧几里德的算法找到两个固定大小整数的GCD  
在） -  
这些操作的时间量与问题大小线性增长。非常直接。  
例子  
1-循环在整数数组上  
2-将项目插入整数数组（在阵列达到容量时的开头或结束以外的位置）  
3-在链接列表中定位第n个项目  
4-枚举平衡二进制搜索树中的所有项目  
o（n log n）  
这些操作比线性操作更长，但不可识别。经典示例是一种有效的排序算法 - 就像大量。  
o（n ^ 2）  
这里的时间相对于问题大小而变化。对于合理的问题大小，这些问题是由现代计算机解决的。对于大数字，可能需要很长一段时间。  
示例 -  n尺寸的嵌套循环。  
然而，我会注意到，我从我对CS的正式学习中消除了最重要的事情之一是你经常不能总是击败多项式时间。例如，泡沫排序（你可能像一个孩子想出的那种只是试图弄清楚如何在数组中排序）是O（n ^ 2）。但更有效的排序可以给你一个（n log n）。  
或者，例如，写一个给定整数n的函数返回由所有先前整数添加到一个的n返回n。例如，5 => 5 + 4 + 3 + 2+ 1 => 15.您立即提出的方式o（n）。但如果您知道合适的算法或可以从数学知识中获得它，可以在O（1）中完成。整洁的东西。  
任何时候，我都没有经常对我的代码进行这个分析，因为我的大部分工作都是强烈的I / O绑定。这并不意味着我不知道在未排序的阵列中查找数字之间的差异与散列集。或者经常使用的.NET库中操作的基本时间复杂性。我认为这是大多数程序员都需要知道。  
### 回答 50
快速注意，这几乎肯定会使大o符号（这是一个上限）（这是一个双边绑定）。在我的经​​历中，这实际上是典型的非学术设置讨论。对于任何混乱的方法gucture.big o复杂性可以通过此图可视化：  
我可以提供的最简单的定义是这样的：Big-O表示法是算法复杂性的相对表示。这句话中有一些重要和故意选择的单词：  
当你阅读其余时，回来并重读上面的上面的。我可以想到的大o的最佳例子是做算法。出故两个数字（123456和789012）。我们在学校学到的基本算术运算是：  
这些中的每一个都是一个操作或问题。解决这些的方法称为算法.Addition是最简单的。您的数字向上（向右）并在列中添加列中的列中的数字结果。该号码的一部分被携带到下一个列.Lets假设这些数字的添加是该算法中最昂贵的操作。它代理能够将这两个数字添加在一起，我们必须一起添加这两个数字6位数（并且可能携带第7页）。如果我们在一起添加两个100位数字我们必须做100个添加。如果我们添加了两个10,000位数字，我们必须做10,000个添加。将图案（是操作）与较大的数字中的数字N成正比.WE调用此O（n）或线性复杂性.Subtraction类似（除了您可能借用而不是携带）。可能是不同的。您的数字是不同的。起来，取下底部号码的第一个数字nd乘以依次乘以顶部号码的每位数字等每个数字。所以将来乘以我们必须做的两个6位数字36乘法。我们可能需要多达10或11列添加到结束结果也是如此。如果我们有两个100位数字，我们需要执行10,000个乘法和200个adds.对于两百万位数字，我们需要做一万亿（1012）乘法和200万个添加。算法缩放与n平方，这是o（n2）或二次复杂性。这是介绍另一个重要概念的好时机：我们只关心最重要的复杂性。精灵可能已经意识到我们可以表达次数：N2 + 2n.但是当您从我们的示例中看到有两个数百万位数的电视时，第二个术语（2N）变得微不足道（占该阶段总操作的0.0002％）。一个人可以注意到Weve假设最坏的情况这里乘以6位数字如果其中一个EM是4位数，另一个是6位数，然后我们只有24个乘法。我们计算那个n的最坏情况场景，即两者是6位数字。很大的符号是关于最糟糕的场景算法电话簿  
我可以想到的下一个最好的例子是电话簿，通常称为白页或类似但它因国家而异。但是我谈论姓氏，然后是姓名缩写或名字，可能地址电话号码。如果您指示计算机在包含1,000,000名姓名的电话簿中查看John Smith的电话号码，您会做什么？忽略您可以猜到SS开始多远的事实（让您假设您cant），你会做什么？一个典型的实现可能是向中间开放，拿到500,000个并将它比较史密斯。如果它恰好是史密斯，约翰，我们刚刚得到真正的幸运。那么John Smith将在这个名字之前或之后。如果我们之后我们将在一半和重复的时候划分一半的电话簿的最后一半。如果之前，我们将在一半的电话簿中将前半部分分开并重复。这被称为二进制搜索，每天都在编程中使用无论您是否意识到它，如果您想在一百万名称的电话簿中找到一个名称，您实际上可以通过执行此操作来找到任何名称。在比较搜索算法中，我们决定此比较是我们的n。  
这是惊人的好的不是吗？在大问题术语中，这是O（log n）或对数复杂性。现在所讨论的对数可以是ln（基本e），log10，log2或一些其他基础。  
### 回答 51
DFS和BFS都具有O（v + e）的整体复杂性，V是顶点的数量和图表中边缘的数量。  
您可以在此处找到一个快速的解释。[1]  
<a> [1] </a>  
但我建议您通过Cormen阅读算法的介绍[2]。有一整套解释算法以及它们的复杂性分析。  
<a> [2] </a>  
脚注  
### 回答 52
你的意思是bachmann landau符号：大o符号 - 维基百科。  
它非常滥用操作员符号。  
书籍是充足的 - 一种可以使用：具体数学 - 维基百科  
以及计算机编程的艺术 - 维基百科，对于更简单的文字，可以使用算法介绍 - 维基百科，  
我更喜欢算法，第4版。  
简而言之，让允许有两个功能f（n），g（n）f（n），g（n）  
n，相关的n：  
LIMN→∞F（n）g（n）=升高→∞f（n）g（n）= c  
一些常数'c'。这也可以是0.在这种情况下，我们写入 - 渐近束缚明智之函数f，包含在g的范围内（非常明显，n  
你的意思是bachmann landau符号：大o符号 - 维基百科。  
它非常滥用操作员符号。  
书籍是充足的 - 一种可以使用：具体数学 - 维基百科  
以及计算机编程的艺术 - 维基百科，对于更简单的文字，可以使用算法介绍 - 维基百科，  
我更喜欢算法，第4版。  
简而言之，让允许有两个功能f（n），g（n）f（n），g（n）  
n，相关的n：  
LIMN→∞F（n）g（n）=升高→∞f（n）g（n）= c  
一些常数'c'。这也可以是0.在这种情况下，我们写入 - 渐近束缚明智的函数f，包含在g的范围内（非常明显，无论f gets多大，g都在那里，即使n是无穷大，也只偏移通过一个常数），我们写：  
F∈gf∈g.  
现在，使用我们写的令人难以置信的滥用符号：  
f = o（g（n））f = o（g（n））  
现在，例子。  
假设我们采取函数f = 30n.30n。  
我可以找到多个g（n）g（n）  
这样的挥霍限制持有，  
g = {n，n2，n3，n4，n5，。，zh，n！...} g = {n，n2，n3，n4，n5，。，zh，n！...}  
因此我们可以写：  
30n = O（n），O（n2），... o（en），... 30n = o（n），o（n2），... o（en），...  
现在这是令人难以置信的愚蠢。  
当然，30n是由en.en的界限。  
那不是我们应该如何写它，对吧？  
是的。欢迎来到符号的地狱。  
现在，世界各地的人们使它成为挑选最小界限的良好做法，这是在f = 30n的情况下，它只是n。  
因此，在实践中我们说：  
30n = o（n）30n = o（n）  
现在。问题正在发生，因为我们让常数'C'到0。  
观察，限制转到0，我们使用以外的任何东西的时刻为g（n）。  
现在，如果我们只将c的值限制为非零正为正，那么表示法变得稍微有意义，它变得向上和向下界定，它被称为θ（），θ（），所以我们可以写：  
30n =θ（n）30n =θ（n）  
但显然  
30n≥θ（n2）30n≥θ（n2）  
我们应该使用θ（。）θ（。）  
一直，因为这就是我们真正的意思，有点。  
同样，这是一种务实的方法，而不是正式的方法。正式，定义很少有点，究竟是什么意思表示？  
但你明白了。  
这就是那里。  
我知道，很讨厌令人困惑，对吧？  
### 回答 53
Big-OH​​符号（O）：  
>> O（g（n））= {f（n）：存在正常数c和n0，使得所有n> n0的0 <f（n）<c * g（n）。  
>>它是渐近的上限。  
>>功能f（n）= o（g（n））IFF存在正常数c和n0，使得所有n的f（n）≤c* g（n），n≥n0。  
>>语句F（n）= o（g（n））仅在所有n，n≥否的f（n）的上限上仅绑定G（n）。  
>>例如：  
1. 3n + 2 = o（n）  
所有N≥2的3n +2≤4n。  
2. 3n + 3 = o（n）  
所有n≥3的3n +3≤4n。  
3. 100n + 6 = o（n）  
所有n≥6的100n +6≤101n。  
Omega表示法（ω）  
>>ω（g（n））= {f（n）：存在正常常数  
Big-OH​​符号（O）：  
>> O（g（n））= {f（n）：存在正常数c和n0，使得所有n> n0的0 <f（n）<c * g（n）。  
>>它是渐近的上限。  
>>功能f（n）= o（g（n））IFF存在正常数c和n0，使得所有n的f（n）≤c* g（n），n≥n0。  
>>语句F（n）= o（g（n））仅在所有n，n≥否的f（n）的上限上仅绑定G（n）。  
>>例如：  
1. 3n + 2 = o（n）  
所有N≥2的3n +2≤4n。  
2. 3n + 3 = o（n）  
所有n≥3的3n +3≤4n。  
3. 100n + 6 = o（n）  
所有n≥6的100n +6≤101n。  
Omega表示法（ω）  
>>ω（g（n））= {f（n）：存在正常数c和n0，使得所有n> n0的0 <c * g（n）<f（n）}  
>>渐近下限。  
>>功能f（n）=ω（g（n））IFF存在正常数c和n0，使得所有n的f（n）≥c* g（n），n≥n0。  
>>语句F（n）=ω（g（n））仅在所有n，n≥no的f（n）的值上只有一个下限的界限。  
>> e.g.  
1. 3n + 2 =ω（n）  
所有n≥1的3n +2≥3n。  
2. 3n + 3 =ω（n）  
所有n≥1的3n +3≥3n。  
3. 100n + 6 =ω（n）  
所有N≥0的100n +6≥100n。  
Theta表示法（θ）  
>>θ（g（n））= {f（n）：存在正常数c1和c2和n0，使得所有n的0 <c1 * g（n）<f（n）<c2 * g（n） > n0}  
>>功能f（n）=θ（g（n））IFF存在正常数c1，c2和n0，使得所有n的c1 * g（n）≤f（n）≤c2* g（n）， n≥n0。  
>> e.g.  
1. 3n + 2 =θ（n）  
所有N≥2的3n +2≥3n。  
所有N≥2的3n +2≤4n。  
所以，C1 = 3，C2 = 4＆n0 = 2。  
>>语句F（n）=θ（g（n））iff g（n）是f（n）的值上的上限和下限。  
小哦符号（o）  
>> O（g（n））= {f（n）：对于任何正常数c> 0，存在恒定的n0，使得所有n> n0的0 <f（n）<c * g（n）}  
>>我们使用o表示法表示没有渐关节的上限。  
>> O-符号和O符号的定义是相似的。主要区别在于，在f（n）= o（g（n））中，绑定的0 <f（n）<c * g（n）保持一些常数c> 0，但在f（n）= o（ g（n）），绑定0 <f（n）<c * g（n）保持所有常量c> 0。  
小omega表示法（w）  
>> W（g（n））= {f（n）：对于任何正常数c> 0，存在恒定的n0，使得所有n> n0的0 <c * g（n）<f（n）}  
>>我们使用W表示法表示不渐关节的下限。  
来源：渐近符号|数据结构中的渐近符号  
### 回答 54
我认为人们不认识到他们在内化大o的程度，并且甚至不考虑它。  
每个人都知道嵌套的循环是坏消息，通常是θ（n2）θ（n2）。每个人都知道他们需要一个处于最差θ（log2n）θ（log2⁡n）的搜索算法，并且线性搜索不是它。他们知道他们需要一个处于最差θ（nlog2n）θ（nlog2⁡n）的排序算法，尽管人们更少知道他们有时可以做得更好。  
任何人都设计了一种新的算法，我承认不是每个人，都必须敏锐地意识到他们的算法的主导学期。我必须在职业生涯中几次进行此分析。他们必须能够比较替代算法并选择最快的算法。它们通常与已知的大o复杂性竞争竞争。  
### 回答 55
如果您没有对大问题的内化，直观了解，那么驱动您如何实现性能敏感要求，那么您不是程序员，更不用说软件工程师。  
你是一个通过编写代码来伪造它的假装。  
是的，真正的程序员不仅知道如何至少估计他们编写的代码的大o，他们认为它们在他们使用的库中，例程和算法中。  
### 回答 56
HMPH。  
这是一个棘手的。  
一方面，在象牙塔之外几乎有零程序员必须能够提供他们计划的渐近运行时间的严格证明。另一方面，如果您没有评估情况并相应地行事，您可能会编写错误的代码。  
通过评估情况并相应行动，我的意思是什么？  
类似，想想输入数据的结构，如何构建输出数据，程序对其收到的输入进行了多少计算，程序的内存使用情况，内存的速度  
HMPH。  
这是一个棘手的。  
一方面，在象牙塔之外几乎有零程序员必须能够提供他们计划的渐近运行时间的严格证明。另一方面，如果您没有评估情况并相应地行事，您可能会编写错误的代码。  
通过评估情况并相应行动，我的意思是什么？  
类似，考虑如何构建输入数据，如何构建输出数据，程序对其收到的输入相比，程序的内存使用情况，访问内存的速度，文件/数据库访问的速度网络，等等。  
一般来说，快速看看程序可以让您粗略地了解其时间或空间复杂性，并且通常这种粗略的想法就足够了。  
### 回答 57
然后有人写得非常紧密限制的服务，可能被称为数百万次seco  
有不同的程序员。  
在过去，我们有4格，但那些已经消失了。他们已被最基本的全堆叠开发所取代。许多人都写得很多，更多的配置代码而不是我们可能术语真正的逻辑。我离开发展的一个原因是，很明显未来将需要更多的配置和集成代码，这通常是一种少数几天的魔法线，而且包含很少的逻辑。  
然后有人写出非常紧密的限制服务，这些服务可能被称为全球系统的数百万次。它们不仅需要了解大量大问题（以及复杂性分析的其他方面），他们需要了解可以从O（n2）O（n2）到o（n * log2n）从O（n2）的算法和数据结构O（n *log2⁡n）和从o（no（n）到o（log2n）o（log2⁡n）。真正的好的人处理超越二次的问题。  
然而，公平地，他们没有计算大O.没有人遵循规则。好吧，有些教师，我会告诉学生，但你发展（正如戴夫voorhis写道）的直观感。我不同意这是（甚至应该是）所有程序员，甚至是所有软件工程师;这取决于您正在处理的问题。如果您正在进行性能，那么您就会培养这种意义。在我知道关于大o的任何事情之前，我正在致力于表现问题，因为我痴迷于效率（刷牙需要两分钟，所以如果我在刷牙时我不能做其他事情，它会驱动我坚果）。  
这种直觉是什么？一个例子是，固有的二进制结构和操作（不说话的操作）与日志基础2规模复杂度深度连接。  
专业开发人员不正式分析的一个原因是他们具有这种直观的感觉。另一个是，大问题和复杂性分析通常只会告诉你故事的一部分。您还必须配置您的代码并了解您的数据。如果您只是排序100个数字，则优化您的排序算法可能会令人满意，但无论您需要进行排序的频率，您都不会实时节省。 （您可能会受益于不使用线性数据以开始，但这将依赖。）  
### 回答 58
不完全是。  
对于我在过去四十年中写的任何程序，我从未这样做过，但我一直疯狂地了解小CPU上的时间和内存限制。  
我知道嵌套环是坏的 -  O n平方或立方体或更糟。我知道嵌套循环有条件 - 带入日志术语 - 更好。我知道，除了删除该功能之外，不能击败某些东西即时 -  O（1） - 不能击败。  
我从来没有学会计算大o;但在数学课程中，我确实学会了关于图表上的渐近，这是​​一个非常相似的东西。  
但是，你这样做，你需要了解记忆  
不完全是。  
对于我在过去四十年中写的任何程序，我从未这样做过，但我一直疯狂地了解小CPU上的时间和内存限制。  
我知道嵌套环是坏的 -  O n平方或立方体或更糟。我知道嵌套循环有条件 - 带入日志术语 - 更好。我知道，除了删除该功能之外，不能击败某些东西即时 -  O（1） - 不能击败。  
我从来没有学会计算大o;但在数学课程中，我确实学会了关于图表上的渐近，这是​​一个非常相似的东西。  
但是，您做到了，您需要了解内存使用和执行时间。您需要知道如何衡量和配置这些。您需要大致了解您写入的代码如何影响这些指标。您需要了解在这些条款下拖到高级的每个库呼叫。  
大o和相关措施是比较和评估代码在较大负载下的正确运行的正确技术的方法。在实践中，仅仅因为大多数目的而感到足够好。  
这是一个有趣的老世界。在20世纪80年代，这是必不可少的。由于计算在2000年代更大，我不再关心。在20世纪20年代，我们现在支付亚马逊和谷歌的字节 - 第二，因为大多数事情：每个人都会再次关心;）  
### 回答 59
我同意Jake Van Wagoners的答案。  
你不经常这样做，你不非常严格地做到这一点，但了解大o符号可以帮助您了解您可以在问题缩放时的代码，以及您不能进行的代码。而且，同样的是，能量花了很好的地方，在哪里浪费它，旋转轮子。  
例如，我在几个夏天前工作的项目。它有助于公司为银行开发高性能分布式数据库。我很肯定我被带来了因为他们认为解决他们的问题的解决方案是使用LLVM向机器语言编写翻译，这不是一个坏主意。然而，我做了一些测量，并看到了改善他们表现的真正关键是他们正在追求的不同之念，这是一个不同的想法，它是矢量化的，这是一次性的，而不是一个接一个地做出1000行。切割开销的高效性和成本效益比手工调整汇编程序更高，用于逐一操作。  
这是一个案例，在这里知道一个大o型概念，将项目保留在错误的事情上。我们采取了一个问题，即n ** 2，并将其减少到n个案例（不渐关节上，而是通过相关的输入相关范围）。了解复杂性帮助人们看到这样的事情。  
这就是为什么计算嵌套环数的简单的东西是有效的。它不是一个精确的大o计算，但它大部分时间都在正确的方向上给了你一个提示。并且，如果您了解您的复杂性，您可以看到循环在每次迭代中将其数据切割成一半，并且实际上是log n，而不是n的一个因子。这是稍微更复杂的分析，但仍然不一定是不一定严谨的。  
### 回答 60
不是真的，我在采访中得到了大问题，但我从未妥善了解过。通常代码要么足够快或不是，如果不是，那么我会找到更快的方法来使它更快。  
然而，上次要求我在采访中进行分析的人，不想给我一份工作，因为我不太了解，所以它可能值得从这方面了解。虽然他似乎没有多么了解并行处理和低延迟计算，但了解如何进行订单分析并不有多使用，除非您知道如何修复它。  
### 回答 61
不可以。您需要知道的只是您的程序如何执行数据输入的数量：线性是好的，指数是坏的：  
计算此类事物的最简单方法是简单地运行几个测试，例如10项，100项，1000项等，并查看会发生什么。当然，记住这种速度只是确定程序质量的竞争目标中的一个。例如，请参阅这里...  
…和这里：  
et voila！  
### 回答 62
我已经近40年了。直到我阅读Kurt Guntheroth [https://www.quora.com/profile/kurt-guntheroth-1]我甚至不知道你在谈论什么。  
你看，我们在学校学习了编程逻辑。  
我们没有一些惯例一些数学家思想将证明我们的效率。  
我们必须使用其中一个  
是的，我仍然拥有那个。  
在背面或前面，有时是连续形式的绿色棒的两侧，我们不得不画出整个东西。它 ...  
### 回答 63
大是在真实世界的编程中是一个糟糕的，悲伤，可怕的措施。  
现实生活程序员必须做得更好。  
确实。  
找到θ。  
但即使也没有锻炼身体。  
我们需要了解确切的常量。对于现实的数字范围，所以逆..  
当n合理估值时，不是无穷大的时间是多少。  
你有100万件物品作为UI列表？  
发生这种情况 - 当我开始写这篇文章时。  
我开始以覆盖功能和所有的方式建模 - 然后原作者说 - 不要。  
我解释了这一点  
大是在真实世界的编程中是一个糟糕的，悲伤，可怕的措施。  
现实生活程序员必须做得更好。  
确实。  
找到θ。  
但即使也没有锻炼身体。  
我们需要了解确切的常量。对于现实的数字范围，所以逆..  
当n合理估值时，不是无穷大的时间是多少。  
你有100万件物品作为UI列表？  
发生这种情况 - 当我开始写这篇文章时。  
我开始以覆盖功能和所有的方式建模 - 然后原作者说 - 不要。  
我解释了速度将滞后一定的时间。  
但他维持 - 我不应该。  
事实证明他是对的。  
我的过载被吮吸了。  
这是真正的世界实时渲染可以获得 - 在玩具环境中。  
我学到了 - 真的 - 那天，O（）是一个可怕的想法，总的来说，对于任何实际的编程。  
θ更好，  
如果你可以 - 焦点获得a（）。  
===>总结..考虑恒定因素，考虑恒定因素。  
### 回答 64
开发人员是否正式计算了整个真实计划的大o，由大量的源文件组成？不。  
但是，大概念（无论您是呼叫它）是否必须进入选择和/或创建属于程序的算法和数据结构。否则，您将不知道软件将如何扩展，可扩展性对于许多现实世界项目来说都很重要。一些库和框架为特定功能提供了此信息，因此，虽然您自己不必自己计算，但您确实需要了解文档正在告诉您的内容，因此您可以制作智能选择和设计决策。  
专业软件开发人员需要有一种算法的可扩展性和他们选择和/或创建的数据结构。这涉及正式或非正式的大o分析，您可以在某种程度的经验之后了解。在这些术语中没有至少思考，Naïve决策和方法可以，并确实导致可能为小型数据集工作的解决方案，少量用户，小文件等，但在面对现实世界的输入时崩溃。  
所以，如果你在学校或书中教授大型概念，请注意。使这种思考的方式是重要的。  
