---

title: 您在简单变化中的代码中最戏剧性的加速是什么？
date: 2022-01-23T22:08:18+08:00

---




## 您在简单变化中的代码中最戏剧性的加速是什么？  
### 回答 1
一个10,000倍的加速。  
我的朋友正在制作一个开放世界的团结游戏，并写了一大吨的程序代代的东西。唯一的问题是，一旦他试图运行它，它变得非常慢。他打电话给我，几乎泪流满面，因为他写的所有真正酷的东西都在运作正常，如他调试所展示，这只是太慢了。  
我看了看它，瞬间困惑。他没有做任何复杂的事情，沿着一些程序生成的地形网顶部的佩林噪音实例化了大量的树木和岩石。  
我们停止了播放模式，几乎没有运行，我看了几分钟的代码。一切似乎是对的，然后我意识到他的缓冲区已经弄清楚球员在球员周围产生了多少是错误的，因为他在地形块距离而不是米的情况下产生它，就像他想象的那样。基本上，他的生成了地形100倍，而不是他需要它。每个地形块约100米。  
我删除了三个或四个zeroes，以便当播放器大约10个地形块而不是1000时，对象只会生成。然后我点击了播放，他只是坐在绝对的惊奇，因为一切都加载在毫秒内。  
通过删除几个零，我从技术上得到了10,000倍的加速。这种优化可能永远不会发生在我身上，但它是我生命中最满意的经历之一。  
### 回答 2
写入慢Python代码的一个非常简单但非明显的方法是通过字符串连接。相信它与否，这是一个n ^ 2操作：  
<ol> upperstr = f for c大字符串：upperstr + = c.upper（）</ ol>  
<li> upperstr = </ li>  
<li> </ li>  
<li>在大字符串中的c：</ li>  
<li> upperstr + = c.upper（）</ li>  
这里的问题在于Python中的字符串是不可变的。使用每次迭代，创建一个新的缓冲区，并且将2个字符串复制到其中的字符。  
但如果输入很小，您可能甚至可能不会遇到这种性能瓶颈。此外，您想要执行大字符串.Upper（）而不是将Upper（）应用于字符串中的每个字符。  
这是一个非常出色的情景b  
写入慢Python代码的一个非常简单但非明显的方法是通过字符串连接。相信它与否，这是一个n ^ 2操作：  
<ol> upperstr = f for c大字符串：upperstr + = c.upper（）</ ol>  
<li> upperstr = </ li>  
<li> </ li>  
<li>在大字符串中的c：</ li>  
<li> upperstr + = c.upper（）</ li>  
这里的问题在于Python中的字符串是不可变的。使用每次迭代，创建一个新的缓冲区，并且将2个字符串复制到其中的字符。  
但如果输入很小，您可能甚至可能不会遇到这种性能瓶颈。此外，您想要执行大字符串.Upper（）而不是将Upper（）应用于字符串中的每个字符。  
这是一个非常出色的场景，因为字符被单独流入脚本。而且，有问题的输入字符串是人类基因组 -  3亿个长串。  
DAWG。  
这是热闹的，因为它是少数几个现实，极端情况之一，其中Python字符串连接真的拧紧。当另一个实习生让我帮助调试他的代码时，我在生物信息学实验室中担任实习生。  
通过切换到可变数据结构，我们将运行时间从4小时减少到单位分钟：  
<OL> UPPERSTRCHARS = []对于大字符串中的c：upperstrchars.append（c.cupper（））返回.join（upperstrchars）</ ol>  
<li> upperstrchars = [] </ li>  
<li>在大字符串中的c：</ li>  
<li> upperstrchars.append（c.upper（））</ li>  
<li> </ li>  
<li>返回.join（upperstrchars）</ li>  
### 回答 3
最大的数据嘎吱作响的任务之一，无论是你看地震还是H型炸弹，都是COND  
为一些严肃的令人惊讶的令人惊讶的勇敢！  
在冷战的高度，科学家使用精致的地震仪监测全球核爆炸。 （IVE在高北极地区看到了一系列传感器。）因此，数据收集中存在浪涌和对数字信号处理的日益增长的需求。  
然后，巨大的1964年阿拉斯加地震呈现了Geologists想要分析的更大的数据集。 （记住，他们刚刚开始考虑这次板块构造。）  
最大的数据嘎吱作响任务之一，无论是看地震还是H型炸弹，都是对地震表数据进行光谱分析，是一种称为傅里叶变换的过程。  
标准数字傅里叶分析是一种关于超大二维数据矩阵的矩阵操作的思维矩阵操作。这涉及读取两个数据点，执行简单的算术运算，并重新编写它们。  
1964年的计算机内存很小，它很慢。磁盘和胶带甚至更慢。所以这一切阅读和写作都是笨重的，每个傅里叶变换都花了几个小时。  
然后来自两个辉煌的计算机科学家，他们重新发现了一个由高斯1805发明的替代算法（是的，那个高斯!!），并实现Cooley-Tukey FFT算法 - 维基百科。  
粗略简化，而不是通过N个不同的数字序列（n ^ 2操作），Cooley和Tukey，指出，可以对那些不同的序列进行反对，将操作数减少到NLOG2（N）的序列。 （感谢Jim Lux的修正。）  
结果是，在同一台计算机上的Alaska Quake数据进行了原始数据 - 在几秒钟内完成了！性能增益是三个数量级。  
这是一大堆成功的成功，几十年来一直没有流口水，但我不知道另一个量子飞跃像这个一样令人惊叹。  
### 回答 4
我与一家公司合作，在收到的一些大文件上使用XML转换。这本身就是感觉;格式完全适合XML。  
然而，实际上解析了它们是一个噩梦。千兆字节文件在一个和两个小时之间才能处理。它无可救药地积压他们的系统和刺激在较大文件中发送的客户。有时它会得到如此糟糕，因为他们的服务器耗尽内存，因为等待通过的文件的积压。  
转换为XML是我最初怀疑问题的地方可能是，但它很好。它将其转换为最少的额外开销。所以接下来我看着解析，而且很好地有你的问题！  
编写文件格式的解析器才能使用XPath，但写作它们的人们很少知道它，因此他们刚刚使用来自root语法。基本上意味着每个单一解析操作都将整个东西加载到内存中并通过它进行搜索，以便符合规范的节点。  
我重写它们使用实际的XPath并钻取到有问题的特定节点而不是使用文档根。一个千兆字节文件的解析时间从大约一个半小时到五秒钟下降。他们起初并不相信，并广泛测试旧的和新的方法，以确保它们在测试数据库中完全匹配。他们做到了。  
注意：如果您在货币化空间内读取此答案，则存在与作者的意愿。  
### 回答 5
不是我的代码更改，但是朋友：Phillip remakers回答最好的程序员使用最少的代码行，就像我的经历一样符合？  
我最喜欢的故事之一涉及一个有一份新工作的程序员朋友。 CTO说，OK，NewBie，看看我们最优化的代码（这是我们的系统核心），并尝试挤出10％的改进。我们不认为你可以，但至少你会熟悉这个系统。  
在检查代码的同时，他在最内循环中遇到整数划分操作。 Intel CPU中的整数差异是深刻的低效率，因此他返回到全部算法，并将操作重写为矩阵计算，该计算采用了几十行代码，该矩阵计算将利用Intels SSE2指令集。  
结果？ 50％的速度提升。  
CTO是令人震惊的。但是你添加了更多的代码行！他溅着。怎么可能更快？  
他们是令人难以置信的，指责他打破代码。但是，它通过了他们扔掉的每个单元测试。  
他在那家公司上没有久了。有些地方真的很讨厌能力。  
### 回答 6
所以我介绍了平行端口通信如何工作，如何在差异上进行相应的手摇动，信令等  
大约20年前，我被要求在我们制造的产品中实施并行端口的固件装载。设置是我们使用了一张可以连接到我们制造的任何类型的产品的通用I / O卡，我必须使用位敲击来实现从头划线的并行端口通信和固件加载。  
（应加载固件的设备，打印服务器，打印机前几天使用的网络连接。）  
因此，我介绍了平行端口通信的工作原理，如何在不同引脚上进行相应的手抖动，发信号牌等，然后在我们的固件加载软件中实现它。  
此处的问题是固件加载软件是在OS之上运行的用户级应用程序，并编写低电平I / O通信需要几个非常非常短的等待在不同状态变化之间。在应用程序级写入软件，您不能等待非常短的时间，最佳约10毫秒。最终结果工作，但它相当慢，加载固件大约需要20-30秒。  
将解决方案卷出来的一个生产车道进行测试，看看它是否可以使用并且可以使用。生产的反馈是它比他们的旧遗留解决方案更好，但是对其进行了缓慢的投诉。  
所以我再次看着它来看看可以做些什么。我知道这个问题是等待，我替换了线程等待着忙碌的循环，试图让等待更快。这确实有所改善，但是这样做的其他副作用。然后，我挖出了从ROM运行的引导加载程序代码，该代码在加载固件的设备中。  
事实证明，引导加载程序中的代码真的削减到裸露的最小值，并且它对如何在并行端口上接收固件以及在此级别的情况下进行了一堆假设，也是如此进行比特敲击。  
我被告知，并行端口必须在上传固件之前在特定模式下设置，这可能是真的，如果进入正确的并行端口驱动程序，但是看引导加载程序代码，它就会清楚地关注模式所有，它确实回应了它，但它不会有任何效果加载固件。所以用那个代码，尝试了它，它运作并加快了。好的。  
意识到引导加载程序真的遵循并行端口协议根本不需要做到这一点，也可以抛出一堆其他代码和信令。最终解决方案只有满足引导加载程序所需的内容，并且使用此非常最小且优化的代码，我可以忙于等待在固件加载器的其他部分上没有副作用。固件装载从20-30秒到一秒钟的一小部分，这是令人难以置信的。  
为了好玩，我击败了生产测试工程师，随便说我在这里和那里做了一些改进，不确定它真正的差异，让我知道如何结果。一旦他在生产中测试了他回来，他回来了说他们已经测试了几次并工作了，但他们无法相信差异，现在几乎是瞬间。我解释了我所做的事情，我们对此有一个很好的笑声。  
它进入生产，每个人都很开心，这让我看起来很棒。当然，我在第一次尝试中写了糟糕的代码，但最终解决方案仍然比旧的传统解决方案更快，它正在通过并行端口驱动程序，实现完整的并行端口协议而不是执行任何快捷方式。这是一个非常伟大的感觉。  
### 回答 7
编辑：有人根据该人向我指责抄袭，以前的观看以前看到类似的答案。这些是我的经历，没有一个elses。我在97中使用我的会议徽章向javaone添加了另一张图片，它有我的名字和我的雇主（太阳）。对于那些记得那些日子的人来说，我在Pal1（Garrison Lab）那么MPK02，它在建成后搬到了纽瓦克。我最后一次是在MTV16（Sunlabs）。我有点不确定是否是MTV16或不同的数字，但它是最接近海湾的MTV建筑。基思梁先生从一开始就是我的同事，他仍然在这些年后在基准中心（这几天他是老板），但现在在甲骨文下。  
Solaris线程的早期。公司建立了一个高度同时的线程文本搜索引擎（90年代谷歌时代末期）。用于国会库和类似的地方。特定新的64 CPU Sun E10K服务器。来自维基百科的E10k的照片。  
代码繁忙但像狗一样跑。主要是用户级别，根据跟踪，几个等待系统调用。疑似记忆锁争用在与开发人员交谈后，关于代码实际的代码。  
决定尝试查看在全局锁上序列化的线程，用于制作Malloc（）和Free（）线程安全。添加了每个线程内存管理的新库，并与libc malloc（）兼容。求出伟大的，代码开始嗡嗡作响这些处理器。基本问题是锁定争用和太多Malloc，（）/ free（）调用在全局锁上同时堵塞。  
然后我删除了一堆线程调度逻辑，让内核调度程序管理线程调度。应用程序逻辑用尽更多时间管理调度VS只是蛮力强迫它并以带线程依赖内核来定向那些CPU来定时到CPU。内核调度程序远远多于HomeBuilt调度程序（并且像Gang Scheduling一样很酷的内容为缓存亲和力）。 App Developer已轻松删除调度逻辑。 Yhey有一个预处理器指令，让我重新编译源并使用-d标志禁用此调度逻辑。如果不是它，它将获得更长时间才能让内核调度程序管理线程并发。鉴于它是多么容易（感谢开发人员），我认为这是值得的，对我来说，当我看着痕迹和系统统计数据时，他们在代码的那一部分中度过了太多时间。但是，无论如何，我可能会尝试过它，风险很低，潜在的奖励是值得一试运行。  
全部在大约10,000倍的加速度。大多数是删除内存锁的序列化，然后获取线程以刚刚运行。太可爱了。可能是一小时的工作左右。太阳在我工作的Menlo公园的基准中心。美好的回忆！  
一些更老的回忆。在E10K中的处理器。关于手掌的大小。在系统板上扭转，每个系统板4次CPU和每个机箱的16个系统板。  
对于那些不熟悉该计算机的系统架构的人。它是一个64处理器高速缓存相干，均匀的内存（即不是NUMA）机器。系统架构：  
我的Javaone徽章从97起。javaone的第二年。早些年…  
### 回答 8
通过重新编码检查Z80汇编器的小C函数，我曾经实现了7％的整体性能改进。没有其他优化我们试图嵌入式项目甚至1％。  
我一度通过重新编码由refy制造的字符串函数来提高大Windows程序的性能超过100％来通过引用而不是按值传递STD :: String参数。  
我曾经修正了一条手动构建过程，通过改善Makefiles，在三天内完成了10名工程师，因此他们可靠地建立了一切。由此产生的构建过程一半的工程师。然后，我改进了构建过程使其完全自动，包括扫描日志文件以进行回归。它变得自动，可以在大约10分钟内检查。  
一个名叫David Jacobson的智能家伙，我曾对替换O（n log n）算法进行的电路板测试仪开发了一个O（n）内存测试算法，但具有更好的覆盖范围。节省时间令人惊叹，基本上将产品的一生延长约10年。  
我曾经重新编码了一个网络监视应用程序，处理约1,000个网络端点，以便处理约25,000个端点。虽然涉及几种优化，但是每次读取器线程唤醒时，所以在读取器线程唤醒的情况下，所以在额外的传入数据包中的轮询是对额外的传入分组进行轮询，而不是使每个传入的分组唤醒读取器线程。加速是如此戏剧性，即我无法相信很长时间。  
在业务管理应用程序中，我增加了可以通过大约10倍处理的代理数量，主要是通过将在日志记录函数中本地创建的CString变量移动到类成员变量，以便它们每次都不要分配存储项目已记录。内存管理器的争用是序列化多线程系统的线程。  
### 回答 9
100倍在Matlab计算机视觉算法上。  
我被计算机视觉启动被聘为顾问。他们的代码是用Matlab写的，并且需要几分钟来处理单个图像。  
事实证明，代码正在处理使用循环的所有图像像素。 MATLAB被称为，因为它具有高度优化的矩阵数学作为基于原始的内置，但它们根本没有使用此功能。我更换了20个代码实例，这些代码看起来像这样：  
<OL>对于Y = 1：x = 1的高度：宽度图像[x，y] =图像[x，y] * 0.5结束</ ol>  
<li>为Y = 1：高度</ li>  
<li>对于x = 1：宽度</ li>  
<li>图像[x，y] =图像[x，y] * 0.5 </ li>  
<li>结束</ li>  
使用代码看起来像这样：  
<OL>图像=图像* 0.5 </ OL>  
<li>图像=图像* 0.5 </ li>  
每个循环都ran 40  
100倍在Matlab计算机视觉算法上。  
我被计算机视觉启动被聘为顾问。他们的代码是用Matlab写的，并且需要几分钟来处理单个图像。  
事实证明，代码正在处理使用循环的所有图像像素。 MATLAB被称为，因为它具有高度优化的矩阵数学作为基于原始的内置，但它们根本没有使用此功能。我更换了20个代码实例，这些代码看起来像这样：  
<OL>对于Y = 1：x = 1的高度：宽度图像[x，y] =图像[x，y] * 0.5结束</ ol>  
<li>为Y = 1：高度</ li>  
<li>对于x = 1：宽度</ li>  
<li>图像[x，y] =图像[x，y] * 0.5 </ li>  
<li>结束</ li>  
使用代码看起来像这样：  
<OL>图像=图像* 0.5 </ OL>  
<li>图像=图像* 0.5 </ li>  
每个循环都越来越快，随着这个变化，整个系统从10分钟到几秒钟。作为奖励，新代码也更容易阅读和理解。  
### 回答 10
他们说瑟  
我曾经建立用于分析脑电图数据的工具，使用具有移动平均线的低通滤波器分析脑电图数据。我正在做的科学家们可以输入移动平均水平的距离有多少毫秒。  
这是1982年，机器是慢动布。我正在使用PDP 11/44，需要10分钟才能分析一小时的数据。  
我做了一些分析，发现延迟完全是通过样品数量分割平均水平。我回到科学家们说嘿，如果你可以从以下价值观中选择：2,4,8,16,32等。毫秒？  
他们肯定地说，我改变了划分（这是浮点并采取许多时钟周期）到二进制班次（采用完全一个时钟周期）。代码增加了10倍！  
### 回答 11
40万美元的变化！  
设置场景，这是在大约2001年左右。我在一家提供服务的公司工作，将报纸放在线上。然后，Ad-Serving仍然存在于其初期，我们做了自己的。  
我们次要成功，并在我们需要两个SQL服务器来处理广告的程度上。这包括确定所显示的页面和显示的适当广告，然后记录信息。 SQL服务器运行的CPU容量约为60-70％。但偶尔会飙升超过80％，当它确实时，它将基本上飙升到100％，广告服务会被积压。我们开始看另一个大型服务器，（用磁盘等，将运行约40千万美元）加上必要的SQL许可证。  
我在SQL Server杂志中遇到了一篇文章，该文章开始讨论如何处理SQL Server如何查找存储过程的名称以及如何获得最高数量的称为重新编译。后台，SQL Server没有几乎可以使用它来调试性能的工具。但这篇文章给了我足够的线索。  
一个开发人员和我在一起进行了多次改变，但其中两个基本上是相当于将存储过程从sp_servead重命名为dbo.usp_servead。  
简单地缺少架构，并使用SP_前缀存储过程的名称（许多人仍然做，请不要！）导致SQL引擎在主数据库中首先看（SP_表示系统过程，未存储过程，因此它由SQL引擎特殊处理），并且当它找不到它时，请查看当前数据库，然后重新编译它。  
速度改进是如此令人印象深刻，不仅我们不需要第三个服务器，而且我们可以在单个SQL Server上运行整个广告负载，以不到60％的CPU运行，当我们超过之前的60-70％CPU时我们不再会飙升到100％。相反，它将继续以良好的线性方式缩放。  
因此，单个变化不仅保存了新服务器的成本（加上了许可证），而允许我们将现有的广告服务器基本上转换为DR服务器。  
所有这一切都具有简单的变化。  
### 回答 12
许多年前，我们有一个闪光部分，似乎表现不佳。它应该能够在每秒1-2兆字节左右写闪光灯，但它正在努力达到每秒千字节。我被分配到了这一点。  
因此，对于这种闪光部分，擦除相当慢：大约100毫秒。如果我记得，则在子毫秒范围内写入并读取相当快。该部分也没有中断线来告诉我们操作完成后，我们必须轮询它。对于RTOS，这意味着您可能会阻止其他线程进行有用的工作，并且在CPU时间方面，100毫秒是很长一段时间。换句话说，我们不想在擦除上旋转循环。另一方面，读取和写入很快旋转环路。  
我们以前决定最多可以将线程设置为100毫秒的时间，而擦除发生，以允许其他有用的工作发生。我开始测量读，写和擦除时间，最后发现了问题。粗略地，代码读为：  
好吧，有你的问题！  
我们想在擦除命令期间睡觉，而是我们正在为一切睡觉而是擦除命令。我将代码更改为预期：  
<ol> if（flash_command == flash_erase_cmd）millisecondsleep（100）; </ OL>  
<li> if（flash_command == flash_erase_cmd）毫秒（100）; </ Li>  
我们立即能够接近理论最大速度。所以，是的，我只通过更改一个字符来获得〜1000x的加速。  
### 回答 13
3台机器上的3台机器日降至10分钟。432x性能改进通过将一行代码转换为几行。  
一些机器学习人士正在生成一串键值对，因此它们将每对附加到一个字符串。此代码在Python中，其中字符串是不可变的。因此，每次追加发生时，先前的字符串都是首先复制。具有O（n ^ 2）运行时，所以我将它更改为o（n）的东西。  
我的加速超过1000倍，但那些没有简单的变化：他们花了几天时间来实施。  
### 回答 14
我改变了别人写道的后端T-SQL查询。整个查询长度超过400页，因为原始作者在整个地方创建了TEMP表，以保持和处理可能因各种条件而异的数据而变化。我使用Pivot函数更改了代码，并将代码从400页减少到大约8页。旧代码耗尽每秒约1次纪录。新代码耗尽每秒约500条记录。要公平，枢轴功能是由我们小组以外的人提出的，所以这不是我的想法。  
### 回答 15
TLDR;通过更改一个简单的命令提示符批处理文件脚本，我能够将我的Windows文件传输速度从2个以上时间增加到常规消费者Windows 10的实体结束到终端到底，而不使用任何特殊的高端企业等级以太网硬件或以任何方式修改我的窗口。解决方案实际上是一个非常简单的想法。在Windows上的文件传输是一个常见的问题，大多数人可能在他们的生活中遇到了大量的文件或复制时文件到新的硬盘驱动器，闪存驱动器或通过网络。我当前运行的房地产商启动的小型Shopify是没有什么不同。对于这些问题而言，没有任何魔法解决方案，我面临着任何其他消费者面临的问题。每一个24小时都面临着同样的问题，由于复杂的房地产行政规则对我的业务决定的原因，以换取我从我所在城市的最新MLS房地产数据的访问，我需要下载200,000+ jpegs权重65GB的Real Est。来自集中式MLS服务的照片，所以我可以在自己的服务器上托管它。这些65GB的JPEG和200MB原始XML数据我接收然后通过我自己的自定义REST服务搜索引擎摄入我，我设计了我的客户可以访问他们的访问权限一体化套餐$ 16每月公积器IDX网站，我卖掉它们。我的技术知识必须能够做出通常需要10人的工作。我不能在物理上同时为十个人进行物理工作但我可以尝试实现十个人同时工作的结果。我基本上是一个男人技术团队与成立的百万美元公司竞争，每月至少收取4倍的价格，但我赌博是我广泛的技术知识使用非传统优化技术构建精益，超高效，完全自动化将通过超低运营成本给我一个主要的价格优势，即我可以在保持竞争水平的同时传递给客户质量是一些MLS带宽规则限制每台计算机的最大下载速度，因此下载过程本身可能需要8小时.Luckily，数据分为两个不同的类别，可以单独下载。将下载时间分开设置两个桌面计算机，两者都开始同时下载不同的MLS JPEG流。该解决问题，但我仍然需要解决文件合并问题。MLS数据下载软件最初是直接下载文件在托管服务器上，但我看到的最便宜的虚拟专用服务器每年以30,000美元开始......这是我的启动预算一点。重要的事情总是很简单。简单的事情总是很难。简单的事情总是艰难。始终成本为30,000美元.since我是一个鞋子串预算初创公司，运行了我的公寓的全部运营，在60美元的消费光纤互联网连接中，我托设了我的所有图像数据由CloudFlare的CDN服务缓存的预算服务B2 Backblaze加速（带有一些重要的东西，其中速度在AWS S3上非常关键）.b2的DIY云服务实际上花费了2美元，以举办数百千兆字节（GUI消费者友好版本每月无限制托管）。这本基本上每年节省30,000美元。我必须确保所有65GB都在下载到Desktop Computers之后向B2上传到B2。我已经写了一份自定义多线程程序来自动跟踪，排序并删除从前一夜上传的服务器上的任何现有图像，以避免重新上传相同的文件，因此大大缩短了上传时间.My旧的四核CPU仅产生8个同时上传的线程，这将占用2天上传200,000+ jpegs，所以我最终必须购买一个新的12个核心CPU，以实现24个同时上传，以满足我们24小时合同义务与t他的service.edit：很多人都在评论中询问为什么我不能在B2上的UNIX服务器上使用一些解决方案，而不是写自己的复杂解决方案，以便在UNIX上使用Premade解决方案。B2每月花费2美元的原因是因为它只是一个非常高廉的存储解决方案，实际上没有其他能力。  
### 回答 16
这取决于你认为简单的变化。最戏剧性的加速在时间上，原始程序到达更改的时间是在C ++编译器时使用的Alpha编译器优化器中。  
C ++编译器确实非常激进功能。当大多数孩子被整合时，这对于非常大的功能。这些功能的数据流图同样非常大。并且唯一变量和表达的数量也很大，因此程序的优化数据增加了立方措施（或可能更糟）。我们的比特向量有n次，比特向量至少为n ** 2更大。  
因此，某些大应用程序上的编译器将在优化器数据填充整个DEC工程集群的寻呼磁盘（注意复数字）之前运行几天，并且由于分页空间耗尽而导致集群崩溃，实际上没有生成任何代码。这是（在很小的意义上）相当于以某种方式编写一个会崩溃谷歌的搜索。它是不可思议的，程序正在服用多少资源。而且，我被分配了优化器，以解决它。  
它没有长时间看到这个问题。也许30分钟的调查。而且，解决方案显而易见，我们需要一种使数据更加压缩的方法。我做了两件事。  
首先，我意识到每个位向量中的大多数位值都是空的。大多数代码只需操纵几个变量和表达，并且只有那些将具有非零位。因此，我从位向量中修剪了导致和尾随零。我不认为我甚至困扰在中间删除零的运行。  
其次，还有很多位向量是一样的。因此，我检查了重复的向量并共享那些重复的矢量。  
它可能会带我一天或两个代码，并将其工作，也许只有几个小时。我不再记得。然而，改进基本上是瞬间一旦编码。该系统不仅没有崩溃，而且需要几天的时间，在不到一个小时内完成，通常在几分钟内。结果，我没有打扰在更小的数据方面寻找更多方法。  
### 回答 17
在Python中，我改变==（测试平等）是（测试标识），并减少了10系数的执行时间。  
我正在处理一大一组套装，其中每个组都代表了物质或材料的术语。在这个特定的代码块（编辑：这是一个小功能增强的服务中）我想对代表水的术语做一些特别的东西，因为它具有最重要的同义词。因此，对于每个输入，我测试了相应的集合等于水的设定。代码近90秒加载特定的大型数据集。运行指定此特定行的探查器。当我意识到可以使用身份测试时，执行时间下降到小于8秒。 （平等的测试也没有特别好））。我花费超过90％的执行时间反复迭代每个输入集的成员，看看它们是否相等，而是我可以通过检查它们是否是所需的对象。  
### 回答 18
这在数据库代码或查询中发生了很多频繁......  
这是成为数据库家伙的最有趣的方面之一;你觉得偶尔走在水上:)  
从我的早期从卫星星座模拟器仿真，模拟了不同卫星星座配置的行为。您可以填写几十个或数百个配置文件。如果你喂它百分之一，SIM将需要几周的时间来在我们的vax 11/780上运行，并且SIM非常重要，以至于我们正在认真考虑获得我们可以访问的CRAY Y-MP上的时间（当然，对于Not-al-all-all小费）。  
我当时是一个全新的工程师，他们让我看看它。代码是由一堆航空航天博士写的，所以我真的希望问题 - 如果有的话 - 如果没有在实际的SIM算法中。  
经过一点分析，我意识到问题不在SIM核心中，但在包启动和关闭代码中。事实证明，它有一个Fortran阵列，其中具有百万个元素，它由SIM填充，具有各种参数。大多数运行只会设置几百或几千元素。整体主循环是类似的  
所以，我做了以下事情：  
这取得各个包从一小时到不到1分钟运行，这意味着现在在大约4个小时内完成了两周的运行。航空航天家伙（正确）坚持深深的代码审查，以确保我的变化没有以某种方式搞砸了核心算法，但在此之后，我的变更被接受了。  
一个酷炫的辐射是我们的团队能够投标 - 并赢得了一项卫星项目，我们否则即将通过，因为我们无法在竞标截止日期内完成模拟。  
### 回答 19
FIFO而不是filo。  
每秒32,000个连接每秒与8,000个连接。  
中国工程师不明白为什么热发动机调度工作。  
### 回答 20
问题是，在DEC / VM上表现令人震惊 -  a  
这是我咨询的代码，而不是做改变 - 并设法将食物中毒作为额外的利益。  
1990年，英国一支位于贝尔法斯特的团队，在中产量的UNIX机器上开发了一个完整的OSI兼容的7层堆栈，他们能够以每秒大约35个数据克的速率驱动堆栈端到结束（这是没有额外的加工）。  
然后，他们将代码移植到DEC / VMS（自DEC / VMS是POSIX符合POSIX自符合POSIX的那种合理的作业 - 我理解移植主要是重新编译和一些制作文件调整）。  
问题是，在DEC / VM上，性能可怕 - 大约1或2个数据报每秒。  
我在萨福克，U.K.在一个使用DEC / VM的项目上工作，并为自己带来了一点名称，因为DEC Comms堆栈中有点专家。  
所以我被要求飞往贝尔法斯特咨询团队，为什么他们的DEC / VMS PEFormance非常糟糕。  
我和团队一起聊天，然后看了他们的代码简介：他们有来自UNIX的执行配置文件，而不是DEC / VMS  - 但由于代码相同，配置文件信息仍然有用）。  
很明显，最常用的函数是执行查找将“名称”转换为接入点值的代码（在OSI中，协议使用Access Port号 - 但是每层的可调用API使用服务名称，因此每个名称都使用服务名称翻译。  
翻译名称的函数打开了文本文件并读取了正在寻找合适条目的每行。这是在UNIX中对的正确件事 - 打开和阅读文本文件总是很快，这意味着如果文件更改，您不需要做任何可怕的事情。在DEC / VMS下打开和读取文件昂贵，使设计永远不会表现。  
代码更改很简单 - 具有静态数组，只需存储文件中的行。如果数组为空读取文件并将其存储在数组中，并将其存储文件的修改时间的时间戳。如果阵列具有数据，并且时间戳没有改变，则使用阵列中的数据。如果时间戳已更改，请重新读取该阵列。  
一个功能的简单变化：  
全部介绍了一个简单的文件缓存：使用HashMap或类似可能一直更好。  
### 回答 21
SQL计数吗？  
在我们与一个主要的新保险计算机系统一起生活后不久，我们发现有人猜到了如何在转换数据中设置特定字段并猜到错误。  
该字段中的值对系统来说不是一个巨大的问题，因为它没有做任何事情，但它被展示给了那些非常困惑的用户，因为它是他们用于决定如何处理受影响的政策的指标。  
大约600,000 000人需要改变100,000次政策。  
问题在于识别需要哪个策略需要一个依赖于for的6表加入  
SQL计数吗？  
在我们与一个主要的新保险计算机系统一起生活后不久，我们发现有人猜到了如何在转换数据中设置特定字段并猜到错误。  
该字段中的值对系统来说不是一个巨大的问题，因为它没有做任何事情，但它被展示给了那些非常困惑的用户，因为它是他们用于决定如何处理受影响的政策的指标。  
大约600,000 000人需要改变100,000次政策。  
问题在于识别需要哪些更改的策略为依赖于表中嵌入的外语和一些相当复杂的决策逻辑。  
我是任务的写作查询来做到这一点，并提出一个在测试数据的样本上完全跑的一个，但每次尝试在预生产中的完整数据集上测试它时都会超时。  
它只是吃太多的CPU时间，我们估计要为真实运行它可能需要3天成为现场生产系统唯一运行的东西 - 显然是不可能的。这是在20世纪90年代中期，系统和查询在IBM大型机上运行，​​因此我们没有选择扩展处理能力，很少有工具，以帮助我们了解所需的优化。  
在绝望时，我寻找方法可以将其分解为可管理的块。如果它不会运行整个查询，可能会对数据库的子集进行查询？  
我在策略号码范围的10％之间添加了一个语句。它以秒为单位。我在几个其他范围内尝试过它，最终识别最高和最低的策略编号，我很难编码到查询中。它在任何额外的时间内更新了在Preprim Prep Prop Prop Prop Prop中的策略。  
在我被允许对直播数据库中运行之前，其中一个生产DBA必须批准它，他制定了发生的事情。  
原始查询基本上看了复杂的加入，并决定它必须在内存中建立一个自定义索引来处理它，这与几百个记录很好，但与索引的百万策略变得令人表征。通过对策略编号的语句之间应用于大多数表的主要键或主键的一部分，我强迫它使用现有的索引，这是大规模的索引。  
显然，我试图加速的其他一些事情是完全不必要的，可能会对的，但DBA宣布了我的声明相当聪明。  
### 回答 22
在实际生产代码方面：  
有一次，我通过重构和删除了几十多行代码来获得所有图像的速度〜30-40％的速度  
然后，通过运行六个预图像构建命令，我通过〜50％进一步降低了图像构建时间。  
就刚刚随机的东西，我写道：  
我自动化定期完成的各种事物。两年前，我的整个（40多小时/周）的工作现已减少到每周工作的几分钟。我尝试编写可用于在永久性中生成时间/资源节省的东西。根据我的计算  
在实际生产代码方面：  
有一次，我通过重构和删除了几十多行代码来获得所有图像的速度〜30-40％的速度  
然后，通过运行六个预图像构建命令，我通过〜50％进一步降低了图像构建时间。  
就刚刚随机的东西，我写道：  
我自动化定期完成的各种事物。两年前，我的整个（40多小时/周）的工作现已减少到每周工作的几分钟。我尝试编写可用于在永久性中生成时间/资源节省的东西。根据我的计算，在我的第一年这样做，我救了公司最低130万美元......我写的大多数东西都涉及很多关于问题域的思考，然后写下Dead-Simple代码让事情变得更容易和修复问题。  
### 回答 23
一旦我在国家银行和其中一个主要系统工作，突然遇到了巨大的绩效问题。系统无法访问，耗时地耗尽。有恐慌。  
一间战争室被设立，所有专家都聚集在一起。来自印度的专家们被召唤，计划我们从美国使用的一些工具中飞行......这将是一个漫长的周末，因为它立即明确了每个人都在夜晚工作即将到来的周末解决这个问题，根据专家们的巨大，所以人们没想到会很快就会解决。所有通常的嫌疑人都被排除在外。大镜头绝对没有线索发生了什么......  
我被称为主题专家并运行测试和模拟。我当时不是一个大型技术专家，只是一个软件测试仪......  
所以在第一场战争室会议之后，在彼此喊叫各种各样的技术事情之后，每个人都被告知开始分析了东西，而不是。老实说：我没有任何条切，他们都在谈论......这也意味着我不知道我现在应该做些什么......所以我刚决定看一下机器的监控。虽然每个人都在谈论100％的CPU和Ram陷入困境，但我立即注意到别的东西：磁盘IO非常高......它似乎无法应对周围的数据量。所以我问了技术专家，是的......当然他们知道！我在想什么......它是因为RAM充分利用磁盘努力存储临时数据。  
作为测试仪我我不只是买......真的，真的很高的磁盘......所以我开始潜入被写入磁盘的东西，并快速发现一个以惊人速度增长的日志文件。据我所知，我们甚至没有在生产上使用的日志文件......所以为什么要在那里抽水？从日志中获取任何数据，因为磁盘如此忙碌，所以要忙碌......但是有一些毅力，我设法从所述日志文件中获取一些信息，并立即注意到那里的“冗长”...经常...检查代码了解到我有人因某种原因设定了记录来冗长，它是银行的关键系统，总是面临高负荷，它在日志中写出了大量数据。  
所以回到专家。结果，一些程序员已经将它设置为详细检查测试环境上的内容，并忘记将其重新设置回到其正常设置（仅记录错误）。但是，这可能是问题......但他们说，纠正它没有伤害。所以他们做到了。花了30秒。和Voila：所有系统都回来了在线，表演恢复了。问题解决了…。  
不用说我是当天的英雄。我自己不喜欢自己......我只是典型的软件测试仪唠叨一些小小的，可能无关紧要的细节，没有人认为相关。这是我的工作......我更加惊讶所有那些大射击专家都失败了这一件简单的事情。 ;）  
### 回答 24
我撰写了一个Python程序，读取包含numpy.loadtxt（）列的文本文件。对于数百万行，它非常缓慢。通过更改为Pandas Read_CSV（），读取大文件增加了十倍以上。  
### 回答 25
我曾经制造了几十个Perl程序，通过在一个Perl模块中更改13份$ _到_更快地运行了大约14倍。运行情况是，在做一个文件测试的整个混乱时（-e，-f，-d， ETC）在一个用于循环的目录中的每个文件上，如果你做明显的事情，那就非常慢：  
<ol> for（@filepaths）{接下来的if！-e e $ _; if（--te $ _）{$ type = t;} elsif（-ce $ _）{$ type = y;} elsif（--be $ _）{$ type = x;} elsif（-s e $ _） {$ type = o;} elsif（-pe $ _）{$ type = p;} elsif（-le $ _ && -de $ _）</ ol>  
<li> for（@filepaths）</ li>  
<li> {</ li>  
<li>接下来的if！-e e $ _; </ Li>  
<li> if（-t e $ _）{$ type = t;} </ li>  
<li> elsif（-c e $ _）{$ type = y;} </ li>  
<li> elsif（-b e $ _）{$ type = x;} </ li>  
<li> elsif（-s e $ _）{$ type = o;} </ li>  
<li> elsif（-p e $ _）{$ type = p;} </ li>  
<li> elsif（-l e $ _ && -d e $ _）</ li>  
我曾经制造了几十个Perl程序，通过在一个Perl模块中更改13份$ _到_更快地运行了大约14倍。运行情况是，在做一个文件测试的整个混乱时（-e，-f，-d， ETC）在一个用于循环的目录中的每个文件上，如果你做明显的事情，那就非常慢：  
<ol> for（@filepaths）{接下来的if！-e e $ _; if（--te $ _）{$ type = t;} elsif（-ce $ _）{$ type = y;} elsif（--be $ _）{$ type = x;} elsif（-s e $ _） {$ type = o;} elsif（-pe $ _）{$ type = p;} elsif（ -  $ _ && -de $ _）{$ type = s;} elsif（-le $ _ &&！-de $ _）{$ type = l;} elsif（-de $ _ && $ ml）{$ type = m;} elsif（-de $ _）{$ type = d;} elsif（-fe $ _ && $ ml ）{$ type = h;} elsif（-fe $ _）{$ type = f;} else {$ type = u;}按@filerecords，{path => $ _，＃path到文件类型=> $ type ，文件的＃类型}; } </ OL>  
<li> for（@filepaths）</ li>  
<li> {</ li>  
<li>接下来的if！-e e $ _; </ Li>  
<li> if（-t e $ _）{$ type = t;} </ li>  
<li> elsif（-c e $ _）{$ type = y;} </ li>  
<li> elsif（-b e $ _）{$ type = x;} </ li>  
<li> elsif（-s e $ _）{$ type = o;} </ li>  
<li> elsif（-p e $ _）{$ type = p;} </ li>  
<li> elsif（-l e $ _ &&！-d e $ _）{$ type = l;} </ li>  
<li> elsif（-d e $ _ && $ ml）{$ type = m;} </ li>  
<li> elsif（-d e $ _）{$ type = d;} </ li>  
<li> elsif（-f e $ _ && $ ml）{$ type = h;} </ li>  
<li> elsif（-f e $ _）{$ type = f;} </ li>  
<li> els {$ type = u;} </ li>  
<li>推@filerecords，</ li>  
<li> {</ li>  
<li> path => $ _，＃path到文件</ li>  
<li> type => $ type，文件的＃类型</ li>  
<li>}; </ Li>  
<li>} </ li>  
这太慢的原因是，每个文件测试运算符都运行stat（），它收集有关当前文件的大量信息。但是这是一个巨大的资源浪费，因为您只能执行一次文件，如：  
<ol> for（@filepaths）{接下来，如果-e e $ _; lstat e $ path; if（-t _）{$ type = t;} elsif（-c _）{$ type = y;} elsif（-b _）{$ type = x;} elsif（-s _）{$ type = o ;} elsif（-p _）{$ type = p;} elsif（-l _ && -d _）{$ type = s;} elsif（-l _ &&！-d _）{$ type = l;} elsif（-d _ && $ ml）{$ type = m;} elsif（-d _）{$ type = d;} elsif（-f _ && $ ml）{$ type = h;} elsif（-f _ ）{$ type = f;} else {$ type = u;}按@filerecords，{path => $ _，＃path到文件类型=> $ type，＃类型的文件}; } </ OL>  
<li> for（@filepaths）</ li>  
<li> {</ li>  
<li>接下来，如果-e e $ _; </ Li>  
<li> lstat e $ path; </ Li>  
<li> if（-t _）{$ type = t;} </ li>  
<li> elsif（-c _）{$ type = y;} </ li>  
<li> elsif（-b _）{$ type = x;} </ li>  
<li> elsif（-s _）{$ type = o;} </ li>  
<li> elsif（-p _）{$ type = p;} </ li>  
<li> elsif（-l _ && -d _）{$ type = s;} </ li>  
<li> elsif（-l _ &&！-d _）{$ type = l;} </ li>  
<li> elsif（-d _ && $ ml）{$ type = m;} </ li>  
<li> elsif（-d _）{$ type = d;} </ li>  
<li> elsif（-f _ && $ ml）{$ type = h;} </ li>  
<li> elsif（-f _）{$ type = f;} </ li>  
<li> els {$ type = u;} </ li>  
<li>推@filerecords，</ li>  
<li> {</ li>  
<li> path => $ _，＃path到文件</ li>  
<li> type => $ type，文件的＃类型</ li>  
<li>}; </ Li>  
<li>} </ li>  
下划线标记_告知文件测试运算符使用最后一个统计数据或lstat中已获取和存储的信息，而不是运行stat一遍又一遍地运行，这节省了大量的时间。  
### 回答 26
在美国的一个主要银行，我们拍了一夜之间，并将其降至30秒。这是一个具有完全内存数据集的机器集群中的并行处理的力量（由于Tangosol Conherence，现在是Oracle的一部分），而相比，与相同的数据一起延长一个差的集中式数据库。  
在美国国税局，我能够采取一个系统，最大化2x E10K服务器（128次CPU总共，2000年代初期，多数百万个纳税人美元），并将其CPU的影响降低超过99％，而（显然）超速一切从...重写一堂课。大o是你的朋友，要么是你的敌人。 （我不应该参加信贷：这是一个顾问，使用......一个探查者确定了这个问题。他不相信他的能力，所以他害怕告诉任何人他所发现的东西。我看了一下他的数据，和知道他已经想到了它。）  
### 回答 27
通过从循环移动到用户定义的函数的几小时以几小时将在大型电子表格上运行的excel宏的运行时间减少到只有几小时运行。我正在研究正在编写的HRM（人力资源管理）系统的开发项目在Oracle数据库上的PL / SQL中，使用Oracle Forms作为前端的前端。系统的输出的MANY是使用固定宽度数据字段的扁平文件的形式，每行来自100-250个字符的任何位置long.blank字段只是没有分隔符的白色空间。这使得手动检查/验证平面文件输出非常困难（在合理的时间内不实用）。解决此问题，我开发了使用Excel的多个电子表格宏导入文件，将固定宽度字段解析为电子表格中的单个列。[在几个实例中，不同的记录类型在整个文件中具有不同的数字，宽度和数据类型，所以对于我写的那些展台-alone vb appl.解析它们并将它们转换为人类可读形式。文件，在生产系统中有100,000条记录（测试/开发系统中超过16,000个），每个付费运行，所有固定宽度字段，使用COBOL签名的数字图片（!!）以获得货币金额。据所有当然，当然，我们需要一种方法，我们需要一种方法来验证文件中报告的金额是否正确，但Excel没有（或没有）具有原生处理/解析的原始手段COBOL签名编号图片，我从来没有见过它们，所以这是一个挑战。在一些研究中，我写了一个解析例程来将COBOL字段转换为十进制值，然后将其放入1）解析的宏并将文件（每个字段导入到它自己的行/列）; 2）在COBOL签名的数字图像格式中包含货币值的右侧的右侧的列，3）循环在每个插入的列中的每个单元上，将小区解析到左侧并插入其相对十进制值（格式化为货币） 。这需要大约20分钟才能从测试数据库上运行输出文件，但是被认为是可接受的，因为这通常在自动回归测试期间运行过夜。但是......  
当我们接近第一个生产版本时，他们尝试了在PROSS System的文件输出上。首先，他们必须将文件拆分为较小的块，因为此时Excel仍然限于65,536行;然而，他们的主要投诉是它已经运行超过3小时，没有完成迹象一些情况）.so，如何使它实际上可用于Prod测试？循环显然是次优（并且整个东西是一个快速又肮脏的黑客来解决即时需求）。一点更多的研究和我试论我可以将COBOL数图片解析例程转换为用户定义的函数。这意味着我可以将函数输入到一个单元格中作为公式，就像一个内部Excel函数一样.I测试了它，并且有一点调整它的工作！所以，而不是通过包含Cobol签名的数字图片的每个单元格，而不是将宏循环，而是解析和插入所需的列，而是将宏禁用的自动重新计算插入每个插入的单元格（用左相邻地插入公式单元格作为参数），重新启用自动重新计算并最终重新启用屏幕更新。在20分钟的情况下，现在的东西在大约16秒内运行了测试文件，从内存中只有1-3分钟而不是几个小时。在Prod输出文件中！说DBA和Dev团队对这种改进感到满意，这也是轻描淡写的。我也非常满意！顺便说一句，我写的很多工具最终被传递到内部和外部审计员在系统进入生产之前协助签约。  
### 回答 28
我有几个好的。  
我一度通过将复杂（2000多行）SQL查询分成多个单独的查询来优化，将中间结果存储在临时表中，然后从临时表中选择以生成最终结果集。运行时间从20分钟到2秒到2秒。  
我重新编写了一份批处理作业以使用批处理更新，并分区作业步骤将运行时间从几天降至2或3分钟。  
我最骄傲的那个是没有具体的数字指标的人，程序的数量是多少。该程序是一个CGI Web应用程序，需要从用户处理文件上传。出于安全原因，需要将上传的文件存储在单独的文件服务器上，而不是在Web服务器上。没有共享文件系统，可以由Web服务器和文件服务器安装。当我被要求修复应用程序时，用户在上传大文件时遇到超时。  
文件的原始实现将暂时将文件存储在Web服务器上，然后shello出来将文件传输到文件服务器，然后在传输完成后，它会向用户发送响应。不幸的是，对于大文件（公共发生），浏览器请求将在程序完成将文件转移到FTP服务器之前，并向用户生成响应。还有一个安全问题，因为应用程序实际上是在Web服务器上登上文件。  
在完成发送请求后，Web浏览器启动超时时钟。对于具有大文件上传的请求，请求的上载可能需要几分钟，但在完全发送请求之前，超时计时器实际上并未开始。因此，如果我们可以以某种方式重叠文件从Web服务器转移到FTP服务器，请通过从浏览器接收请求，我们应该能够在浏览器超时等待响应之前发送响应。在原始程序失败的情况下，它直到它在收到整个请求之前在甚至开始将文件发送到FTP服务器之前。这是必要的，因为程序依赖于外部FTP客户端进行文件传输。  
我的解决方案是编写FTP客户端类，允许程序立即开始将传入的文件数据传输到FTP服务器，因为它来自浏览器。它不需要等到整个请求收到。当完整请求最终完成时，该文件也几乎完全转移到FTP服务器。作为安全奖励，文件从未实际降落在Web服务器的文件系统上，因此需要担心清理。我学习了关于TCP网络，BSD套接字API和FTP协议的吨。  
### 回答 29
另一个项目：程序将到数据库几百次查找  
（在Java）10k时间改进或更好，从伐木框架的变化。在编码器将HashMaps转换为字符串然后将它们连接到高级需求循环中的调试记录时，有一个问题。问题是，是否启用了调试，始终发生调试到字符串和字符串连接的转换。使用不同的日志记录框架（SLF4J）并将值传递为要格式化的对象，在生产中跳过转换和连接。  
另一个项目：程序将到数据库，几百次查找相同的配置值列表，并在循环中调用这一点。在开始时设置缓存，以在ReadOnly Map中加载Config值，然后仅将它们分享到所需的组件。  
### 回答 30
我正在使用小组来更快地枚举，嗯。  
在许多情况下，我有一个组gg的轨道列表，我希望轨道列表较小的子组hh。  
该问题的常见方法是使用双轴分解。如果您在哪个GG作用和元素XX上有一个设置ωω，则轨道为Gxgx。  
如果计算稳定器SXSX并计算双螺旋分解作为  
g =∪ihyisxg=∪ihyisx  
然后你得到  
gx =∪ihyixgx=∪ihyix  
那是你已经将你的轨道分成较小的轨道。  
足够好，直到你在一个90000轨道的情况下拆分，在那里  
我正在使用小组来更快地枚举，嗯。  
在许多情况下，我有一个组gg的轨道列表，我希望轨道列表较小的子组hh。  
该问题的常见方法是使用双轴分解。如果您在哪个GG作用和元素XX上有一个设置ωω，则轨道为Gxgx。  
如果计算稳定器SXSX并计算双螺旋分解作为  
g =∪ihyisxg=∪ihyisx  
然后你得到  
gx =∪ihyixgx=∪ihyix  
那是你已经将你的轨道分成较小的轨道。  
很好，直到你在90000轨道的情况下拆分，在这种情况下变得不切实际。当我意识到分裂中出现的轨道数量有限时，允许更快的东西。这是许多稳定剂组在再次发生或相当于它们的缀合物。  
现在这是事情。如果对一对（U，V）（U，V）计算双轴分解，那么您对一对（U，GVG-1）（U，GVG-1）具有双轴分解。  
如果你有的话  
g =∪iuyivg=∪iuyiv  
然后你通过应用g-1g-1  
g =∪iuyivg-1g =∪iuyivg-1  
所以  
g =∪iuyig-1 {gvg-1} g =∪iuyig-1 {gvg-1}  
因此，通过使用Memoization，最终结果是在特定情况下更快地运行500倍的程序。一般来说，改善并不好。 （注意：我正在使用用于计算离散代数的GAP系统）。  
### 回答 31
我们刚刚在这里发出了一个问题，这导致了一个非常显着的速度增加。数据库表中有数字，问题是：在数字列表中找到第一个间隙。因此，如果存在1,2,4,5,8,9，则应发现3，因为它是到目前为止未存储的最小数字。 （问题有点复杂，但它可以以这种方式逐渐变化。）  
一位同事们在纯SQL中实施了这次搜索，将桌子加入本身，并在令人讨厌的地方做一些令人讨厌的。这效果但他超越了，由于关系代数的一般限制，此代码将始终在o（n²）中执行n为存储号的计数。  
当存储超过6000个数字时，问题迫在眉睫。 SQL查询需要大约12秒才能发出最小的免费电话号码，它不会变得更好。  
我们分析了代码并决定重写它：返回从数据库中排序的存储号码，然后通过我们在Java 8中实现了最小的差距，然后使用流框架来并行化该步骤。虽然数据库中的订购步骤仍然需要一些O（n * log（n））（或者这些天需要任何现代订购算法......），但是从O（n²）到O（n）的比较步骤缩小。  
从12秒到约0.15秒的执行时间缩小了相同的数字（和相同的结果......），这是因子80的速度增加。并且该因子变大并且存储的数量越大。虽然在此处的另一个答案中傅里叶变换故事并不令人印象深刻，但我发现这种速度增加了很大。并且它表明即使在2021年，祖先的谚语仍然是正确的：如果你必须在更多的计算能力和更好的算法之间加速一些执行时，最好的算法可能是更有希望和可持续的选择。  
### 回答 32
我们为我们的CDN使用Apache，POS非常慢，我看着主服务器循环，我的一个人在大约70行的Perl中实现了Web服务器。在响应时间和吞吐量方面，它的速度速度为10-100倍。是的，它没有完成Apache可以做的所有功能，但我所需要的只是它是一个表查找并发送URL重定向响应。  
### 回答 33
两个例子来到了思想。第一个是运行时间相当正常的优化，但第二个是非常有趣的。  
循环  
当我制作手机相机时，我们有一些代码模拟像素阵列，计算数字处理后每个像素的预期值（与我们芯片实际上的芯片相比）。它贯穿每个像素并应用各种功能以计算预期值。  
代码最初是为小型摄像机编写的。我不记得确切的尺寸，但它是256x192像素的东西 - 远低于1 mpixel。我接过代码来使用它为2个MPIXEL相机（这对手机时对移动电话非常惊人）。  
嗯，令人惊讶的是，计算我相机的预期像素值花了很长时间。它之前没有问题，但现在我必须通过何时思考循环所做的，看看可以在循环之外推送的代码。我必须从循环中删除所有函数调用，用关联数组查找替换它们，并确保在循环通过每个像素之前计算每行（或整个帧）的任何常数。  
我不记得确切的性能增益，但它真的很明显。喜欢从五分钟开始，不要在用它时注意到运行时。  
每个角色的最佳加速  
最近，我一直在使用ASIC的模拟[1]。这些是计算的沉重，运行时间从10分钟到几个小时完全正常。尽管如此，我们开始思考我们的模拟太慢了，我做了一些貌相，看看我是否可以改善运行时间。  
<a> [1] </a>  
根据剖析，在UVM [2]框架中使用超过50％的运行时间，标准库。我不得不挖掘图书馆以了解它在做什么，并发现了一些有趣的功能。  
<a> [2] </a>  
该框架包括他们调用配置数据库的内容，它基本上是可以从代码中的任何位置访问的光荣关联数组，以将系统信息和其他配置全局存储，标准键/值配对。  
事实证明，此配置数据库在引擎盖下有两种模式，隐藏在用户隐藏，而是根据它的使用方式激活。标准模式仅使用关联数组。但是，它还支持将正则表达式或单键放入密钥中。但是，如果您这样做，框架会注意并从正常模式切换到正则表达式模式。在此模式下，数据库中的每个查找都是通过所有键的正则表达式搜索。  
我追踪我们的罪魁祸首：在我们的代码中的一个地方，用'*'输入了一个密钥。它根本不是必要的，并且在写完时可能只是一个错误。我删除了'*'，整个模拟的运行时间大约需要一半。  
50％的运行时间改进删除一个字符！那天我对自己非常满意。  
脚注  
### 回答 34
有一个IP流量分析脚本必须每月运行一次。它称为来自各种路由器的日志的一些集合脚本，使用Java程序导入数据库，最后我可以调用另一个脚本来运行该数据库的统计信息。  
从理论上讲，很多有趣的分析可能已经在该数据上运行，但最终通过源IP的总交通汇总是重要的。其他几年的其他功能刚刚晒干。  
但是，IP流量数据是笨重的。面向对象的DBS对于庞大的列表作业不完全是最佳的。和Java 1.3也不是最表情的语言。  
因此，收集脚本将经营周五的主要部分，然后我会在晚上开始进口并准备好在星期一运行分析，所以我可以在下午晚些时候出示结果电子表格。也就是说，如果不是我的同事那不是一个同事认为长期运行的工作作为僵尸并破坏它，一些分区ran完整或其他东西打破了。  
该修复程序包含在自定义日志输出格式化器（一行）中，该格式化程序（一行）已经在路由器日志中聚合了汇总流量。  
整个分析从那时起20分钟。  
### 回答 35
必须是那个时候我不知道我在做了什么，并在uno编程语言中犯了错误，在找出我所做的错误之后，我在一块着色器代码中改变了一些着色器代码的几个字符，以将渲染从CPU切换到GPU。  
可能也是有史以来最令人难忘的变化之一，而且一个教导了我的GPU是多么强大。  
我通过改变几个角色IIRC，在全高清中以高度降低的分辨率，在高度降低到100多个fps的情况下，我从15 fps运行。  
### 回答 36
这是我对类似问题的答案：  
<span> tom davis </ span>  
<span>退休的数学家</ span>  
不是一个错误，但......  
Ades Agay一位朋友在一个新的迷你电脑上工作，他抱怨说编译器是不可能缓慢的。在那里工作的人只是说他在巨大的大型机上工作了这么久了，他被努力工作了，并且康复只需要习惯较小的机器。  
好吧，这太慢了，所以他做了一些研究，发现当编译器被移植到迷你的人调试的人已经将磁盘读取和写入缓冲区大小设置为一个字符。所以基本上，对于编译器想要读取或写入的每个角色，它必须等待完整的磁盘旋转。  
### 回答 37
有趣的是，我过度应用了这一课。我在未来十年中从应用程序级别t转换了一堆代码  
我得到的最大的加速是将代码从“应用程序服务器”移动到数据库。该算法本身很好，但它被设计用于逐行处理，从数据库中向逐行的小数据包发送数十亿个小数据包。  
只需将此从C＃从C＃转移到数据库中，将代码从几小时从数小时到少于一分钟。这是我们每天呼叫数十次的代码，因此加速使我们不再需要额外的服务器和一名工作人员。  
有趣的是，我过度应用了这一课。我在下一年从应用程序级别转移了一堆代码，从应用程序级别到T-SQL和数据库内的CLR，它创建了一堆难以维护的系统。  
### 回答 38
我的一个同事曾经在他的SQL查询中忘记引用。  
选择...其中account_code = 43215678  
代替  
选择...... account__code ='43215678'  
而不是使用索引来检索具有给定帐号的单个帐户，而是通过〜100万帐户迭代的数据库，以查看是否有任何帐号（数据库中的字符串）将与查询中提供的数字相比。  
添加引号将查询时间从55分钟从55分钟更改为200毫秒。由于这里有网络延迟等（这里有一些严重的瓶颈在家里工作），而且  
我的一个同事曾经在他的SQL查询中忘记引用。  
选择...其中account_code = 43215678  
代替  
选择...... account__code ='43215678'  
而不是使用索引来检索具有给定帐号的单个帐户，而是通过〜100万帐户迭代的数据库，以查看是否有任何帐号（数据库中的字符串）将与查询中提供的数字相比。  
添加引号将查询时间从55分钟从55分钟更改为200毫秒。由于在这里的图片中有网络延迟等（在家里与图片中的一些严重瓶颈工作），因此性能增益甚至比这些数字更高。  
### 回答 39
不是最戏剧性的，而是最有趣的之一。  
服务器确实屏幕擦掉，从上一张图像中的每个图像上做了一个简单的增量，并将Cleta图像发送了压缩。我删除了所有的三角洲处理，只需发送图像，压缩。两侧的加速很重要。  
### 回答 40
我是在德州仪器仪器上在专有的16位小型计算机上运行的集成电路设计系统中优化CALCOMP绘图仪驱动器的任务。我发现它在驾驶员的核心中使用浮点，因为它需要超过16位的精度，即使处理本质上是整数。但是小型机没有浮点处理器，因此Fortran编译器有一个仿真库，慢慢地跑得好。我用16位指令编写了一些小装配函数来合成32位整数添加/减去/乘以/划分/ SQRT（谢谢唐纳德Knuth），并以一些尴尬的代码的成本获得23倍。  
该项目的系统工程师喜欢函数，因此他使用包含缩写子程序调用机制的库添加了一个包含我的例程的库的长期数据类型，该缩写子程序调用机制将另一个因子从执行时间中缩小2。添加了奖金：我可以将函数调用退出并返回使用+  -  * /在表达式中，使代码看起来很大程度上就像原始（但更改真实声明）。  
### 回答 41
可能o（n）到o（1）。几十年前，我正在看一个商业程序，被惊呆了，看到一个子程序计算从1到n的整数的总和，如下所示：  
<ol>函数sum_of_1__to（n）{var sum = 0;对于i从1到n {sum = sum + i;返回金额; } </ OL>  
<li>函数sum_of_1__to（n）{</ li>  
<li> var sum = 0; </ Li>  
<li> i从1到n {</ li>  
<li> sum = sum + i; </ Li>  
<li>退货总和; </ Li>  
<li>} </ li>  
我用这样的东西取代了它：  
<ol>函数sum_of_1__to（n）{return n *（n + 1）/ 2; } </ OL>  
<li>函数sum_of_1__to（n）{</ li>  
<li>返回n *（n + 1）/ 2; </ Li>  
<li>} </ li>  
最近我越过另一个O（n）到o（1）改进，虽然这个问题几乎是简单的变化。可以在O（1）时间中添加一组整数的所有倍数<= n，例如，全部的总和  
可能o（n）到o（1）。几十年前，我正在看一个商业程序，被惊呆了，看到一个子程序计算从1到n的整数的总和，如下所示：  
<ol>函数sum_of_1__to（n）{var sum = 0;对于i从1到n {sum = sum + i;返回金额; } </ OL>  
<li>函数sum_of_1__to（n）{</ li>  
<li> var sum = 0; </ Li>  
<li> i从1到n {</ li>  
<li> sum = sum + i; </ Li>  
<li>退货总和; </ Li>  
<li>} </ li>  
我用这样的东西取代了它：  
<ol>函数sum_of_1__to（n）{return n *（n + 1）/ 2; } </ OL>  
<li>函数sum_of_1__to（n）{</ li>  
<li>返回n *（n + 1）/ 2; </ Li>  
<li>} </ li>  
最近我越过另一个O（n）到o（1）改进，虽然这个问题几乎是简单的变化。可以在O（1）时间中添加一组整数的所有倍数<= n，例如， 6,10和15的所有倍数的总和，高达十亿。  
### 回答 42
无论如何我们决定了  
大约一百万年前的计算机时间当恐龙漫游地球的大型机，即197 x我被指控为系统360设计一个新的IBM Fortran编译器。我在1959年开始编码，所以它完全是我的第一个牛仔竞技，但编译器是棘手的确实和噩梦到调试一个错误占据了整个开发团队，超过一个月才能找到和根除）  
无论如何我们决定从现有的编译器开始，并优化地狱的性能。 Fortran具有完全忽视的白色空间的特征。 B C与ABC相同。结果表明，约有30％的CPU时间被吸入扫描并挤压空白。由于没有声明终结者，您必须扫描卡的末尾，以找到最后一个非空白，因为您有最后的桥梁问题 - 您知道，在跨过最后一次桥接的情况下右转。事物。所以愚蠢的循环刚刚索引到每张卡的末尾，即使很多陈述只是少数人的角色。  
考虑此事。它能够更快地找到完全确定的第一个非空白比上一个更快。因此，我们通过使用单个指令来消除循环来翻转卡，以及另一个指令找到第一个非空白的索引。添加几个设置说明，整个东西都是每张卡的单一执行指令而不是60-一些循环执行。  
### 回答 43
这取决于你称之为简单:)。  
几十年前，我下岗下岗，我的专业朋友决定发给我一些代码，给定一组单词（缩短的牛津字典），生成了用户请求的大小的字正方形。  
这是一个单词广场是：  
他的实现基本上是暴力 - 为每一行生成单词长度n的排列，然后检查列是否也形成有效词。  
如果你想生成维度n的单词平方，这是可怕的  
这取决于你称之为简单:)。  
几十年前，我下岗下岗，我的专业朋友决定发给我一些代码，给定一组单词（缩短的牛津字典），生成了用户请求的大小的字正方形。  
这是一个单词广场是：  
他的实现基本上是暴力 - 为每一行生成单词长度n的排列，然后检查列是否也形成有效词。  
它的性能是可怕的 - 如果你想生成维度n的单词平方，你的字典中有长度n的单词，那么你就必须评估p（w，n）= w！/（w-n）！独特的单词平方。哎哟!  
他计划使用Hadoop集群并行并行于他的代码 - 但我意识到你只能从并行度获得线性加速。使用他的暴力算法来获得答案仍然需要年龄。  
经过一点思考，我意识到您可以使用分支和绑定算法来解决问题（具有非常有效的切断测试的深度首先搜索）。  
基本上我将问题转变为单个玩家游戏，其中移动包括将单词长度N添加到下一个可用行。  
这里的诀窍是它可以实现截止测试 - 您可以探测您的字典，并检查是否有一个单词以迄今为止每列的字母开头。如果测试失败任何列，您知道当前位置无法解决方案，您可以安全地回溯。  
例如，假设我们有一个部分单词广场，完成了两行，其中一个列包含字母XZ。切断测试说我们可以立即停止从此节点搜索，因为xz没有开始英语单词。  
此算法如此高效的原因是因为每列都必须通过截止测试。在许多情况下，可以丢弃浅度深度处的节点，因为至少在列失败的截止测试中。  
最后，您可以通过代表您的英语词典作为数字树，使您的字典探测在接近持续时间内运行。  
在切换到更高效的算法之后，使用单个线程的单个机器可以在几秒钟内产生大小为8到10个字母的字正方形。  
### 回答 44
我已经完成的最简单代码更改的最戏剧性的加速是向常用函数添加一个'＆'，以防止只能用锁复制的复杂对象的不需要的对象副本。该代码需要20秒才能运行或甚至完全冻结......达到约150毫秒。添加了一些const正确，一切都很好。我想我在那个补丁上键入了每封信100美元，大声笑！  
然而，有史以来，一段代码的最戏剧性的加速度，概念性简单的变化比这更戏剧性。我正在优化一个大约10分钟（！）的大分布式数据库，以返回甚至简单的查询结果。我所做的就是修复它的所有都是向数据库添加正确的索引。这个过程花了很长时间才计算，但结果是在50ms中返回的查询而不是几分钟。  
### 回答 45
我不记得确切的数字，但我在模拟中减少了执行时间到原始值的5-10％。  
我继承了MXN战场电子战仿真，M是多种飞机，其对策，n是试图检测所述飞机的多个传感器。  
SIM在CDC网络上运行，被政府受到限制和拥有的内存，因此CPU使用率并不高度优先。  
然而，正如MXN所成长的周转时间变得有问题。  
该问题每次步骤，飞机的位置和方向发生变化，必须重新计算视线（LOS）  
我不记得确切的数字，但我在模拟中减少了执行时间到原始值的5-10％。  
我继承了MXN战场电子战仿真，M是多种飞机，其对策，n是试图检测所述飞机的多个传感器。  
SIM在CDC网络上运行，被政府受到限制和拥有的内存，因此CPU使用率并不高度优先。  
然而，正如MXN所成长的周转时间变得有问题。  
该问题每次步骤，飞机的位置和方向发生变化，必须重新计算视线（LOS）和范围。如果没有飞机与传感器匹配的视线，可以忽略使用雷达范围方程，信号强度和对策电力的其他明智的大量计算。  
原始程序有一个例程，每次检查传感器/飞机/对策时计算范围和LOS。  
给定帽子一架飞机的对策可以保护另一架飞机逻辑变得复杂但是大致如：  
这种安排保守储存以牺牲CPU周期。  
我构建了一个传感器与飞机的矩阵，并计算和存储的LOS和范围。如果没有LOS I在范围内存储NaN，那么到处都存在原始例程，我称为矩阵中的值。  
较大的MXN模拟的性能速度速度速度速度约为10-20倍，并且额外的好处是暴露一些以前未被发现的逻辑误差，其中互动被视为有效，因为实际上没有洛斯存在。  
在结构上和以编程方式上变化是一块蛋糕。  
ymmv.  
### 回答 46
取决于你的看法。  
### 回答 47
我记得的一个人回到了20世纪70年代。我们的PDP11 RSTS / E服务器上有一个实用程序，我们的服务器操作员人员使用，以确认所有用户是否已从我们的各种生产软件数据库包中注销夜间批量处理。每次运行需要很长时间，有时必须多次运行。  
我看着它是如何检查锁的 - 它正在以完全直接的方式访问锁定数据，一段时间从头到尾都锁定。  
当我查看数据文件格式和结构时，我意识到它可以被视为虚拟数组而不是原始数据。一个角度来说，说话。我这样做了，运行时间下降到一秒内。  
### 回答 48
数据集的差异暴露了文件服务器中的瓶颈。 WH.  
十几个加上年前，我为大学设计了一份电子邮件服务。大约20k用户。我们非常符合无法跟上的存储困扰。在一点时，我们正在使用我们姐妹团队运行大型数据库的电子邮件服务下的文件存储。我们没有考虑他们的数据需求基于一些非常大的文件......我们是面向彩色数百万的非常小的文件（因为它是一个邮件程序设置，每个邮件文件夹和每条消息的1个文件） 。  
数据集的差异暴露了文件服务器中的瓶颈。当我们达到一定量的交易时，文件服务器实际上锁定了整个数据存储处理交易。它是由文件服务器硬件使用单个和小文件处理缓存缓冲缓冲区的所有事务引起的。太多的一笔交易意味着您将在几乎所有读取时开始查看缓存未命中。然后文件服务器将锁定整个文件系统，直到解决缓存未命中。  
所以我们做了一些东西来解决它。一个人从邮件程序切换到mbox格式（每个邮件文件夹的1个文件，在文件中按顺序存储的消息）。问题是：我们会字面上打开系统上的每个文件，然后连接到其中许多文件。许多文件操作。一旦触发瓶颈，这肯定会锁定文件系统，然后慢慢地走。  
我的初步估计（我们为富达的测试）是......也许3个月。我的老板说永远不会与管理层一起飞行，也不会飞行用户群（特别是教授）。当然，每个帐户可能会脱机一小时，但随时随地随时随地发生中断的月份？ … 不。  
那么我的老板说：你能使它并行运行吗？ ......这是在Hadoop很受欢迎之前，作为一个免费且着名的地图减少平台。并且基本上我必须写的东西......地图减少电子邮件文件系统翻译的网格计算基础架构。所以我这样做了，并以每条流都将首先取得大量帐户的方式做到了这一点，以减少前面的文件计数。  
新估计：1周。只需10倍的加速即可。我的老板每周五和周六晚上落下它，几周。这仍然需要几个星期，但它们将是可预测和非高峰时期。教师买入它，管理层进入它，一切都很好，对吧？  
但是你可能会说：你为什么吹嘘10倍的加速？  
我的袖口决定首先做大帐户，而不是小账户（随着一个人建议）有意想不到的好处：我没有记得确切的原因，但通过让大帐户首先解决，我们设法得到了这个号码在阈值下的文件停止触发缓存未命中问题。  
我看了第一个补丁需要我预期的时间......没有错误，一切都看起来不错，所以我上床睡觉了。当我醒来8小时后，我的所有加工都完全完成了。我甚至不需要阻止他们。事实上，他们已经停了三个小时的奔跑。我很奇怪：他们一定是失败的虫子，我们浪费了我们的大部分时间。  
我的老板正在寻求地位......我真的很紧张。我找不到一个错误。我找不到一个失败的工作。我不会能够告诉我的老板，为什么我们浪费了我们第一次块的一半。  
这是关于我的同事登录的时间，看起来还有一些东西，并说你没有找到失败，因为他们没有失败。在第二组工作期间，您的优化在缓存未命中问题下给我们。  
当我们处理第二层尺寸账户时，我们以全速速度进行，跨越20台机器并行运行10个作业。应该花费100,800分钟的工作约200分钟。一个500倍的加速。  
### 回答 49
仅加入600x  
<ol> @njit </ ol>  
<li> @njit </ li>  
就在函数的定义之前。  
神奇的@njit标志只是使用numba（一个非常低估的python库）jits的python函数，其中Jit仅在时间编译中代表。  
这基本上将您的Python函数与机器代码一致，以便它在裸机上运行，而不是通过臭名昭着的慢Python解释器。换句话说，您将获得类似速度的C ++（更快的数量级），具有完全相同的Python代码。  
### 回答 50
我缓存了材料属性，而不是每次需要重新评估它们。将时间从10分钟敲至几秒钟。这令我震惊的是，因为立方体嵌就是好的o'tran图书馆男孩。显然我不经常被召唤他们。然而，对其他人的谜团是你是如何让它在10分钟内运行的???。  
我的计划解决了掺铒光纤放大器（EDFA）中的光学信号的放大，因此我是一部分，导致几年的1/20亿美元销售额。在该代码中，我们在激发状态下解决了铒原子的分数。当我表达了那个等式时，在传递给自己的情况下，馏分必须位于范围内[0,1]。因此，我将负值剪切至0，值大于1到1。因此，我的代码从未有过融合问题滥用其他尝试，我在大约十五年后学到了大约十五年。我没有看过自己的代码，看看是否已经使用了剪辑。  
至于优化，我遵循了建议 - 仪器代码并寻找热点。热点瞪着，改善需要另一天。  
参与故事是放大器描述文件，Makefile，Lex，YACC，M4和Fortran求解器。我希望Makefile认识到这一点的变化应该强迫重建。这我没有正确的，这导致了与Richard Stallman写回我的FSF的消息，这是我见过的最奇怪的makefile。  
我的Stallman号码是1。  
### 回答 51
无论如何，当用户开始该程序时，所有内容都需要大约10秒钟  
这是在90年代初期回来的，但是一个程序需要从整数字段编号到字符串字段名称的查找表（也是另一种方式）。  
可用字段存储在文本配置文件中，并且还有另一种配置可以添加自己的自定义字段名称。代码被写入C并使用二进制Chop搜索将名称转换为值，反之亦然。这几天我会在几个Python地点扔掉它而不是三思而后行，而是对于C后退然后你必须DIY数据结构。  
无论如何，当用户开始该程序时，一切都需要大约10秒钟，以启动它是不可接受的，所以我挖掘到代码中。大多数初始化都很好，但它到了它在2个配置文件中读取的点并排序键和值。只有大约1100个字段被排序，所以不应该是一个问题吗？对。  
Sorting由Microsoft的C运行时QSORT函数完成，并且当输入分类时，Quicksort非常糟糕。在这种情况下，在数值上，正在加载超过1000个预定义字段名称。然后将几十多个自定义字段名称附加，其中数字耗尽了数量。排序此几乎有序的字段列表需要大约10秒钟才能完成。  
我所做的代码更改是在排序之前随机播放数组。启动时间下降到一秒钟内。  
这就是我不喜欢Quicksort的原因。当时它大部分时间都很好地工作，但总是那些边缘案例等待咬。  
### 回答 52
然后它去了  
有一个系统需要将用户CSV文件导入系统，在后端，有一个PL / SQL过程有（例如）10参数，对于10列的输入，它做了一些操作然后插入它在数据库上。  
经过一段时间的播放到表和CSV时，但分配给它的开发人员没有勇于更改PL / SQL函数，所以他调用了10个参数过程，然后执行了简单的更新那个记录填充第11栏。  
它作为使用QA团队的样本文件的魅力，其中大小约为10/20条记录。  
然后它去生产环境，一个用户上传了400K的记录文件，它没有在8小时内完成。  
我更改了PL / SQL函数，刚刚向其中添加了一个参数，并更改调用代码也将传递更多参数。并且只有该列没有进程，刚刚插入。所以我已经更改了插入+更新到插入。  
猜猜发生了什么，在不到一分钟的时间内完成了超过8小时的东西。  
### 回答 53
未经正确测试安装了一个新系统。夜间的批量周期需要35个小时。是的，不是真正做某事的方式！  
没有人能弄清楚为什么系统如此缓慢（在线和批量）。我花了几周审查查询，并发现开发系统的人不了解数据库设计。数据库中有很多表（100+），但其中大约20个是主要表。它们在项目上没有真正的DBA，并给出开发人员访问自己的索引。没有任何努力进入索引设计，因此每个人都刚才创建了他们认为所需的查询。其中有15或20列的表格超过了100多个索引！所有主要表都是相同的。  
花了几周审查指数后，我提出了一个建议，以减少别的任何索引。使用DBA，我们删除了800多个索引。现在夜间批量在12小时内运行！  
然后我们调整了最糟糕的冒犯查询，并进行了更多的索引变化。我们在8小时内批次到了！  
这可能是我职业生涯中最专业令人满意的经历之一。  
### 回答 54
两种不同的场合，都使用SQL。  
在第一种情况下，我们有一个交易数据库，该数据库也用于运行报告（如许多人）。我将报告更改为包含（nolock）提示，基本上允许脏读取。  
性能影响巨大。首先，报告更快地跑得更快，因为他们没有必要检查锁。其次，定期处理也持续得多，因为报告已经生成隐式锁，这是延迟使用锁定实际所需的事务的内容锁。最后，系统变得更加可靠，因为常规处理并未处理失败的锁定，并且由于这些不必要的锁而减慢了一切，通常会失败。  
（是的，我知道肮脏的读物都很糟糕。请不要打扰我在评论中批评他们使用它们。他们是一个有用的工具，就像一把锤子 - 非常适合钉子，脏兮兮的灰色读数知道你正在做什么，无法实现任何其他方式的解决方案。但是，在这种情况下，他们是宝贵的。）  
另一个实例是当我使用链接服务器时，我可以基于远程服务器上的数据库中的信息在本地服务器上的一个数据库上运行查询（我正在更新远程系统的数据，其中包含本地的最新更改系统）。  
当我们从SQL Server 2008升级到SQL Server 2014时，此更新的性能从截至超过24小时内。那是几个小时。  
事实证明Microsoft修复了安全性，以便它执行了对发送到远程服务器的每条记录的权限。  
但是，如果您只读取数据，它就像以来一样快。  
所以，我开发了一个接口，它会在链接的一侧运行查询，然后告诉另一侧读取该数据并运行它自己的查询，然后将控制器传递回第一侧读取数据并运行最终查询。  
仍然在一分钟内运行，但比原来的版本更长，更复杂。  
### 回答 55
使用不同的哈希函数。在我原来的我期望会足够好，但运气（运气不好）它在真实数据中产生了不良分布。在发现大量数据具有相同的哈希函数之后，这基本上是线性搜索而不是哈希表搜索，更改公式无限增加速度。  
### 回答 56
作为一个实习生......> 1200倍的变化时，但随着时间的推移会变得更糟。  
每周越来越慢，速度较慢，速度较慢......  
当它增加到一分钟后，它对用户令人沮丧。  
软件开发人员指责硬件，硬件公司归咎于软件......  
在花20分钟的时候，老板参与其中，呼吁使用硬件和软件开发人员在网站上进行会议。在会议之前，我要求查看来源（通过源访问量访问！）  
看起来没问题。  
选中的数据库，在索引中没有日子 - 所以它必须循环到前几天的所有帖子来制作  
作为一个实习生......> 1200倍的变化时，但随着时间的推移会变得更糟。  
每周越来越慢，速度较慢，速度较慢......  
当它增加到一分钟后，它对用户令人沮丧。  
软件开发人员指责硬件，硬件公司归咎于软件......  
在花20分钟的时候，老板参与其中，呼吁使用硬件和软件开发人员在网站上进行会议。在会议之前，我要求查看来源（通过源访问量访问！）  
看起来没问题。  
已选中的数据库，在索引中没有日子 - 所以它必须通过前一天的所有帖子循环来制作该报告。修正了那个报告不到一秒钟......  
### 回答 57
问：从简单变化中的一段代码中有哪些最戏剧性的加速？  
我不确定你将接受什么作为一个简单的变化，但在这里。  
我通过在编程组中的JPL工作的大学进行了编程。 （只允许这个小组在一些任务组之外有程序员。我们编写了Univac 1108s，其中少量核心，但在鼓上相对大量的储存。  
当有人想要排序时，使用模拟磁带合并的程序来完成排序，用于使用用于输入和输出的磁带和用于中间存储的滚筒。这些种类通常花了几个小时，大部分时间都在读写鼓的写作，这具有一些盖子延迟和转移时间。 （但比磁带好。:-)  
我在1108个装配中写了一个简单的排序算法，将所有键从磁带记录中提取，在滚筒上组织时将其存储在核心存储器中。然后，在核心存储器中完全发生的排序，之后，从滚筒中提取记录，以便为磁带写入磁带。  
分类的时间待了几分钟。我没有数字，但它就像是180分钟到20分钟，9倍。您计算了快速百分比。  
我的老板不高兴，因为他们是在购买Univac 1110计算机购买的过程中。  
后来我在双精度轨道决定计划中致力于将I / O重叠贴在一起，实际上是其计算负载的一半，使其运行两倍，2倍。这是他们最大的计算时间的消费者，所以这并不久以至于他们发现借着劝我的假装。  
更新：排序故事是错误的。这是记忆伎俩的课程。整个时间都在磁带上。我提取了钥匙并将它们放在鼓上，在那里他们被排序。除了排序程序及其本地数据之外，主内存太小而无法保持很多。按键在滚筒上排序后，另外几个通过允许写入输出磁带的输入磁带，排序加速如报道。  
### 回答 58
在专用计算机上的主要（不断）运行程序中600％。这并不是一种加速，如减少浪费负荷。  
我在系统中更改了两个字节：在OS中的一个，在应用程序中的另一个。  
然后我写了一个注明说明：甚至想想留下这个补丁。  
大约8年后，在我长期以来，我被追踪并询问为什么？由跟随我的程序员。  
我的回复：Comm User命令系统（CUPS）响应在系统上发送到它的每个中断。修补程序滤除未指定工作B未指定的中断的无数  
在专用计算机上的主要（不断）运行程序中600％。这并不是一种加速，如减少浪费负荷。  
我在系统中更改了两个字节：在OS中的一个，在应用程序中的另一个。  
然后我写了一个注明说明：甚至想想留下这个补丁。  
大约8年后，在我长期以来，我被追踪并询问为什么？由跟随我的程序员。  
我的回复：Comm User命令系统（CUPS）响应在系统上发送到它的每个中断。贴片滤除了未指定用于杯子的中断的无数。  
我是怎么做到的？  
我花了几个星期的时间坐在操作员的车站附近，只是看着闪光灯的模式。然后，我开始想知道为什么负载在非常高且近零的运营流量情况之间很少变化。答案必须是某种巨大的制作工作。  
然后我花了几个月的守则。 （这实际上是我的工作，由再见，了解系统如何运作并保持运行。）  
我发现了杯子得到了工作要求的地方。然后我通过操作系统挖掘，追踪在哪里以及为什么正在发送许多工作。  
考虑管理（谁没有详细了解系统）花了两个月的时间来了。我终于在星期日（最低的交通时间）拍摄了一个测试镜头。在两种补丁中交换并证明了处理流量的延迟延迟，但系统被淘汰的速度巨大。  
优势？在高流量时代，CPU不再是扼流点。它成为Comm-I / O硬件的限制。  
//参考：  
Wiki页面声明更新的名称。缎面最初是为：Saccs，autodin和tty接口网络。我从1975年→1977年工作了。  
### 回答 59
我有几个，主要是在数据库竞技场中。这是我多年前的最喜欢的：  
### 回答 60
我需要复制和粘贴我对你的老板说什么让你退出的问题的答案：  
我获得了一个绩效评论，将我撕掉，下，横向，并且完全不合理。我拒绝签署并要求第二次会议。我参加了一个统计的统计，展示了我如何将工作票积压降低到我们的软件库从超过800到2。  
现在，一点技术解释。这是预窗口。我们有一个用Microsoft Pro Basic编写的软件库。当我接受它时，一切都在大多数情况下工作，除了它很慢。我修复了出色的错误，然后寻找减速的原因，我找到了它：类型声明。  
没有。如果变量名以$结束，则它是一个字符串。否则，这是一个数字。但是有各种各样的数字，默认值是双重精度浮点。微软对索引和阵列下标应该是整数的大小，并指出它是一种速度交易。我经历了，明确地定义了所有变量，并确保用作循环索引或阵列下标的任何内容被声明为短或长整数。速度大幅增加。现在持续20-30分钟的计算在一分钟或更短的时间内跑。  
现在，回到会议。我指出了对他的所有改进，包括赞扬改进客户的评论。他看着一切，并且有胆情说我的评论不会改变。我走回了办公室，做了几个电话，并有一份工作，更多地支付更多的星期一。然后我编辑了库并拿出了每个整数或长型声明，重新编译了新版本并将所有内容保存到分发文件夹中。我清理了我所有的工作目录，以便我所做的事情并没有容易获得，然后由他的办公室散步，把我的钥匙扔在桌子上，说我退出并走了出去。  
由于这发生了，我在计算机世界中移动，最后作为SQL Server数据库管理员退役。我最好的改变之一是一个大规模的工作，在我招聘时，距离近20个小时才能跑步。它一直在逐渐变得更糟，更糟糕，没有人能弄清楚为什么。  
事实证明，此GargAntuan程序在两个大规模表中执行连接，连接中的一个字段未索引。这导致表扫描，系统只是捶打，因为加入中的两个表都有数百万记录。由于表的波动和事实上，没有实际停机（这是一个全球操作，所以交易发生在24/7），我无法拍摄生产索引。因此，我重写了提取到临时表的过程，索引，然后是连接。  
下次工作运行，它在不到两分钟内完成。这对我来说是一个水上助行者。  
### 回答 61
我重写函数以使用单独的查询来使用一个来检索记录  
有人设计了“巧妙”数据库结构，允许记录以任意数量的键存储。要识别这些记录的代码检索了键，将它们合并到内存中以标识记录的ID，然后检索记录本身。关键检索也仅适用于带有一个，两个或三个键的记录（这是所需的一切）。当有许多记录时，合并过程很慢，因为在一个用户中，发现需要20分钟才能检索某些记录块。  
我重写了使用单独查询的函数，用于使用在存储键上的表上使用显式自动连接使用一个，两个或三个键检索记录。不仅保存了所有内存合并，而且查询也可以利用索引。结果 - 前20分钟的作业在大约15秒内完成，其中大多数是正在检索的所有其他辅助数据。查询本身只有第二或两个。  
在此之前多年来，我写了一套电子表格（Lotus 123），这些电子表格（Lotus 123）被挂钩。他们用于录制部门成本。每个团队都会输入他们的数据，由部门拿起，它将其发送到全球一体之作。上次电子表格在拾取链接的记录时拍摄12分钟。然后，我重新制作了链接，而不是通过各个单元格，我将所有数据放入矩形并链接整个区域。将开放时间减少到“只有”几分钟“。  
### 回答 62
我拍了一个曾经需要4个小时的报告运行并将其转到5分钟的报告，只需通过链接报告的结构。  
管理层从等待FR午餐时间进行日常报告，以便在8:05在他们的收件箱中拥有它们。  
最初管理层将在下半年运营会议上讨论前几天的生产力。我的经理希望我们的团队能够展示该部门的其余部门如何完成工作，因为我们从另一个合同中偏出，因为他们在落后的一个月左右。经过两天后，我的经理希望一些性能人物，并不足以等到2点次会议进行更新。当她从会议回来时，她谈到了会议中所说的话，我有一个脑力，问我是否可以拥有剩下的时间来看待这个问题。下午9点前，我为我们的团队提供了一些人，她下午参加了会议。我的数字符合我们团队表现会议的完全符合人物。她问我是否可以为整个项目生产那些带我20分钟的人（这只是指向不同文件夹的电子表格）的数字。接下来的一周他们将下午2点召开召开了凌晨9点，这是令人烦恼的一些经理人在上午10点之后到达工作。  
### 回答 63
从简单的更改中，您在一段代码中获得的最戏剧性的加速是什么？  
我将循环更改为while循环与退出子句。  
因此，而不是做整个数据集，它只循环直到契约完成。在大多数代码中，节省了一堆时间。  
### 回答 64
1990年左右的某个时候，我正在和通常的凸（计算机系统公司）的朋友谈话星期五派对，他分享他对Nastran的编制杀了他的工作。他们花了24小时！这意味着他无法尝试每周很多优化努力。我告诉他我会展望它。所涉及的文件并不是那么大。一个简单的个人资料显示，时间丢失了字符串比较，由符号表查找功能调用。符号表的哈希函数仅使用符号的前几个字母，并且具有相对小的哈希表（如果我记得，如果我记得16或64个条目）。最糟糕的违规文件有一系列大量的浮点数，在第一次传递我们的编译器期间与任何其他符号相同。缺点是哈希函数仅在几个哈希铲斗中传播它们。更一般地，哈希函数的工作方式，即使使用大多数字母标识符，也使用了几个桶。当同一桶中有多个符号时，它们被放置在单独的列表上。如果遇到了一个新的符号，则列表上的每个其他符号都与其进行比较，以确保它是唯一的。添加n个符号所需的n *（n-1）比较。  
我最近在ACM的通信中阅读了一个漂亮的文章，了解一个有效的散列函数，用于字母数字输入，在256-条目哈希表上均匀地扩展值。提高哈希表的大小并使散列函数平滑以更加均匀地传播差异。单个哈希桶中的最大条目数急剧下降。我已经简短地实施了，测试并向我的朋友提供了新的编译器。他的编译时下降到一个小时内。 24倍的加速不是任何手段的记录，但将工作流程从每周周转24小时更改为1小时是一个用于提高我们在第三方应用程序的关键表现的游戏更换器。反过来加强了我们竞争力的销售职位。我们仍然是一个足够小的公司，在那里我们仍然关心每个系统销售。  
### 回答 65
这与其他人一样戏剧性，但我相信相当教育。  
多年前，我正在使用ZXing Bar / QR码工具。处理QR码需要10分钟以上即可。  
挖掘代码，我发现它是（有点）运行一个迷宫选项，然后当它到达一个死胡同它会抛出异常。  
我重构要检查死胡同。  
所以需要很长一段时间，因为这是代码中的无处不在。  
我的时间从10分钟到大约1秒钟到大约1秒。  
课程真的锤击了家（即使我知道它）：例外是昂贵的！  
### 回答 66
我不确定你是否真的把它称为一个简单的变化，但是一部分业务在桌面PC上托管的Access数据库中有很多数据，并且某些查询需要几分钟运行。我将数据移动到我们对另一个应用程序的SQL Server平台上，并且具有九个驱动器 - 我认为 - 配置为RAID-10数组。  
除了将数据导入SQL并将数据更改为代码中的数据，还有没有更改。  
一切都跑得很快，在他把手指抬起之前，答案就在那里。  
### 回答 67
我们有这个程序存储位置点。这些设备在许多车辆上。车辆移动的速度越快，它存储的点越多。这些设备有许多车辆和个人。这些点必须与来自单独的数据系统的其他数据相关联。必须处理数据并将其转换为不同系统的另一数据。所以......需要搜索数百万数据记录。我当时是一个新秀程序员，我将日期yyyymmddhmms作为一个字符串存储。该计划花了几个小时来处理。那太慢了。我将字符串转换为数字，例如盯着日期，如19800101 ......零零，从那里抬起。所以现在这个数字是长期或int（不记得所有细节）。通过在加载程序时进行小的变化，然后它从大约3个小时到几分钟。那是因为比较字符串与数字速度较慢。  
### 回答 68
从简单的更改中，您在一段代码中获得的最戏剧性的加速是什么？  
= @ nl（行，项目，编号，h5）  
= @ nl（第一，项目，否编号，h5）  
第1行每次检查所有90,000项记录，以便在H5中的值，项目编号  
第2行检查项目卡记录，直到它找到正确的，然后停止  
10分钟刷新现在在10秒内刷新  
我有点惊讶于速度变化，我不会想到蛮力那种东西应该是一个问题，只有90,000条记录，  
### 回答 69
如何坚持做到这一点的一个例子可以杀死你：Java程序员不想知道关系数据库。至少他们绝对没有十年左右。他们有休眠，它隐藏了所有令人讨厌的DB的东西，就像一个很好的，适当的OO门面。  
一个简单的数据库更新（非常简单 - 当您挖掘到其中时，它可能实际上已经清除了几张相关表格）已被写入休眠。它最初花了几分钟。随着涉及的桌子的增长，它只是保持慢。它已经花了超过24小时才能运行的那一点，因为它是一项应该每天运行一次的过程的一部分。  
在挖掘通过行逐行行走的三个嵌套的循环之后，一位同事和我能够弄清楚事情正在做什么 - 并产生一些简单的SQL来完成同样的事情。它在一分钟内跑了。  
### 回答 70
我用大量的大亚查音，在.Net中重写了旧银行流程，通过加载内存和词典中的所有数据，并在做所有的过程没有用这些词典进行特殊调谐查找......  
我尝试了，只要字典可以适应内存，过程就在工作。  
该分辨率从1小时的每日过程到接近10秒。  
这只是360倍的加速。  
经过一年后，新进程开始滞后于60秒，我只需要将一些数据从主要到历史数据库移动到历史数据库。  
后来我做了另一个类似的项目寻找inf  
我用大量的大亚查音，在.Net中重写了旧银行流程，通过加载内存和词典中的所有数据，并在做所有的过程没有用这些词典进行特殊调谐查找......  
我尝试了，只要字典可以适应内存，过程就在工作。  
该分辨率从1小时的每日过程到接近10秒。  
这只是360倍的加速。  
经过一年后，新进程开始滞后于60秒，我只需要将一些数据从主要到历史数据库移动到历史数据库。  
后来我做了另一个类似的项目寻找制裁列表的信息，在词典的帮助下（检查雇员列表，针对巨大的制裁清单）。  
该过程可以每秒制作1000万个检查。与SQL而不是哈希文本搜索，不可能和难以想象。  
哈希是你的朋友。 :)  
### 回答 71
对我来说，这是一个概念的单一变化，但代码中的大量物理变化。我正在努力运行速度较慢，每秒大约10个交易。我探讨了该申请，并注意到物体计数在50万范围内。这没有意义。我正在使用JPA对象的Java。我从JPA实体转换为Plainfield Java对象（PO​​JO）。执行此操作后，对象计数下降到大约10,000个对象。该性能每秒跳跃至约100项交易。好，但不是很好。我所做的下一个更改是替换我可以随处最重要的原始的对象。结果让我走了。没有逻辑更改，只需重构代码，替换我的数据库对象类和新数据访问类以处理像JOA实体这样的POJO对象。而整数的重构是整数到int，长到长，漂浮到浮点等......最终结果仅超过100,000个每秒交易。我通过这个项目了解了Java对象管理和内存管理（垃圾收集）了很多。很容易利用Java中的所有简化功能，而不是注意到性能问题。但通过一些严重的高批量处理，而且那些小效率的效率增加了大量的节省时间（或损失）。  
### 回答 72
大约20倍。  
你知道数学教科书如何经常使用（-1）n（-1）n，以表示公式的变化符号，就像在泰勒系列中？对。那么自然，我们的数学家如何将其翻译成C？当然，为什么，战俘（-1.0，n）。两次。在他们相当计算密集的程序的最内循环中。  
现在，我不责怪数学家不知道C中的POW执行相当昂贵的浮点计算，这是完全矫枉过正（反补贴，偶数），如果您想要做的只是两个值之间的交替。那不是他们的工作。但是，改变这一点以简单的条件改善了整体节目性能大约20分。仍然是我最喜欢的性能错误到这一天。  
### 回答 73
我的戏剧性加速始终处于SQL查询中，并且始终涉及获取优化器正确使用索引。  
找到需要3分钟的查询并不罕见，并将其降至3秒钟。有时我首先写了查询，但数据量增加了预期，或者我只是有一个休息日，或者某事;有时它是别人的查询。  
但是你发现你意外地强迫服务器做了一百万行表的表扫描的那一点，而是每一行输出的5次，然后你停止这样做，然后这一切都很好。  
### 回答 74
我喜欢做的一件事是长摩托车骑行。有时我会通过参加像各种奇怪的清道夫狩猎。 2016年，有一个涉及去县法院的旅行部分。我决定在WV访问所有55个县法院。所以我需要拿出一条路线。  
对于许多这些旅行来说，我将路线插入谷歌地图，然后用眼球播放，直到我有一些看起来合理的东西。我认为它可能不是最佳的，但它不太可能远非最佳。但是，圆形州和55个县，眼球不起作用。  
我想是时候写一个程序了。现在，当然，这是旅行推销员问题，一个经典的NP-Cleante（AKA可能需要很长时间才能解决）问题。也就是说，我常常发现难题往往很快解决，实际上是少数元素。 55似乎看起来不太喜欢。  
所以，我一起攻击了一些代码，这些代码用县法院之间的距离表并开始计算距离。我在（例如，当前计算的路由的距离比我已经拥有的最短路线长，抛出这条路线）进行一些简单的优化我还设置了一些东西，以便该计划会定期向我展示进步。我开始在笔记本电脑上运行。两周后，我决定我应该寻找更聪明的东西，所以开始阅读，意图找到一些更好的优化。我当然发现了东西，但它需要大量的阅读和学习一些复杂的编程技术。  
然后我遇到了一个在一些大型服务器上运行的NP问题求解器。这是由一个研究组提供的，因此它们基于一些最佳技术进行了实现。我将问题重组到他们的表单中，并将其提交给他们的服务器，猜测我会在一两天内有一个答案，他们的服务器更强大，他们的代码更有效。  
叹。做到这一点，它花了不到一秒钟来解决我的问题。在互联网上发送我的数据可能需要更长的时间，而不是服务器生产我的路线。那说，我有一个非常愉快的骑行。  
### 回答 75
在开发自定义格式时，我可以使我的地图图表程序渲染我最终决定三角形规则的常规shapefiles是我最好的选择。所以我搜索了一些三角测量代码，发现了一些stackoverflow。  
因此，虽然三角测量本身很好，但我发现了作者如何使用和分配数据的几个效率。看起来虽然制造商擅长数学擅长他们擅长优化，所以通过大多数添加一堆储备来往的向量并通过引用来传递我设法获得了戏剧性的速度提升，但我不记得完全记得因为大约两年前。  
### 回答 76
刚刚创建了正确的计划的简介，接受了经过验证的  
这是Oracle数据库11.2.0.4。由于表格上的简单完全扫描需要几秒钟，因此复杂查询可以轻松运行许多（20多个）小时，因此有一个错误。  
在那些时间不是单个IO的内容是由查询完成的，它都在内存中发生了。（谁仍然认为在内存数据库中始终是禁食）  
使用小DBA Voodoo，我可以将查询时间带回次秒。没有更改表，没有更改索引，添加或删除，并且当然没有代码，因为它是开发人员伏都教。  
刚刚创建了正确的计划的简档，接受了经过验证的最佳计划并拒绝了所有替代方案。  
如果SQL计划稳定性工作，它就会摇滚。  
### 回答 77
在某些情况下，删除应该优化的内容实际上提高了性能。  
我们有一项任务，我们必须合并许多小日志文件。这是在大数据在工具箱中成为常规工具之前的。步骤大致：测试我们从所有生产者中有日志文件，阅读每个日志文件，将日志文件合并到输出文件。  
这在测试中完全良好工作，但扩大到生产并没有工作。  
我们做了很多调整尝试，直到我意识到从我们开始测试我们拥有所有所需的文件，直到我们开始阅读文件，窗口缓存已重复使用，内核必须从头开始查找该文件。  
因此，我们只需仔细测试我们拥有所有数据，我们只是读取文件（每次1-4 MB）并如果我们缺少生产者的文件，则丢弃所有内容。  
与我在通过通过参考通过通过传递的速度来改变字符串处理的时间相比，原始加速可能不那么戏剧性，但它是一个更意外的优化。  
### 回答 78
我使用单个SELECT语句获取来自各种表 -  9表或SO的一些数据，执行查询大约需要2分钟。  
事实证明，我使用的系统（Visual FoxPro）没有足够好的查询;虽然我不确定是否有问题是特定于Visual FoxPro。无论如何，我发现将其分成几个SELECT语句（从两个表中获取数据，然后将结果与第三表等组合）速度急剧提高;所需的时间下降到几秒钟。从那时起，我总是将数据选择拆分为多个命令。  
然而，有很多情况，特别是在数据选择中，其中一个小变化使得巨大差异。例如，另一个常见问题是查询需要某个索引是最佳的;没有这样的指数可以对性能产生很大差异。  
### 回答 79
例1：  
1970年，我在意大利弗拉斯卡蒂的Sincrotrone实验室工作。他们当时的唯一电脑是IBM 1620（Sei-DiciVenti）。因为它已经11岁了，但它经常失败，经常必须重新启动。其中一个科学家向我抱怨他的计划通常需要2个小时才能运行，但平均失败的时间是30分钟，所以他的计划永远不会完成。  
我看了看福特兰源代码，看到它有三个嵌套环，我，j和k。在最内部的循环中，它计算a * i + b * j + c * k。我告诉他将a * i计算出j和k循环，然后将b * j计算出k循环。在IBM 1620中，乘法时间约为25毫秒，相信与否。所以消除乘法运算非常显着。结果是执行时间将减少到少于平均故障时间，并且他实际上得到了结果。  
例2：  
回到1979年，IBM在肯塔基州列克星敦有一家工厂。虽然它主要致力于组装打字机，但是有一个组装电路卡的部分。在那一天，所有卡组件由人类完成，他们将组件插入卡片中的孔中。然而，上一年，我表明机器人可以可靠地做同样的工作。因此，工程师获得资金来构建机器人卡汇编程序。当他完成项目时，平均速度为每个组成部分4秒，并且在投资回报率积极回报率时太慢了。  
我看了一下他的代码，这些代码是由一些由我的一些同事制定的专有语言AML编写的。 （AML是面向对象的，通过操作员过载，通过内置向量操作，通过内存映射控制机器人和寄存器映射，并在IBM系统7计算机上运行。在随后的几年中，我们将其移植到IBM PC。）发现，在每个子程序调用中，他通过了超过70个标量参数。我所做的唯一修改是使所有这些变量全局全局，尽管我知道全局变量通常是为了避免的东西。第二天我将循环时间从4秒到2秒。不幸的是，这仍然不够好，截止日期已经过去了，所以这项项目无论如何被取消。  
回到那些我们过去唱歌的那些日子里：他没有逢低;他不包装电线;所以他们包裹它不能退休，而是老人机器人，他只是继续滚动。 （今天这将是性别歧视者。我们必须改变他。）  
如今，当然，所有大容量卡都由机器人组装，并且部件均匀安装，未插入。所以我想猜测，超过90％的人曾经去过卡片装配已经退休。  
### 回答 80
我公司正在进行一张9个轨迹录音带。在大型计算机上占用超过100美元的CPU时间。我将其切换到二进制转储，每次运行将其降至6美元。  
### 回答 81
不要修理我  
很难计算加速，如我所做的那样，该计划将无法完成足够的工作，让我们等待它。  
退出我的同事后，现在导致（且仅）程序员，决定符合一些任意代码指南，并将名称的缓存查找删除到Map条目的数组索引。他添加了一个存储的哈希来加快查找，但程序启动需要一分钟而不是它以前所做的第二次。  
我恢复了缓存的索引，这需要一些常规但只有10行的代码缓存维护，并且程序再次启动分秒。  
如果在他的编程指南集中不再被打破，请不要修复它。  
他还通过备份on-on-Mismatch解析器替换了一个状态机JSON解析器，并且对普通违规语法的普通违规是较慢和宽容的速度较慢且更宽。  
他非常擅长建立系统和对深层埋葬的虫子的调试。  
### 回答 82
我有很多次固定代码表现在某事物的大小上的Quaddric或呈指数级。所以，通常将某些东西从完全无用的是有用的。  
通常，您希望大小的线性时间行为。如果特征是指数o（x ^ n）或quadri o（x ^ 2），则其他任何东西都会给出一个非常快速的接近点，在那里，如果特征是指数o（x ^ n）或quadri o（x ^ 2）。  
如果您在此类行为的客户端，当您认为无用时，您会注意到真的很快。  
通常在列表中的混淆列表产生了二次行为。但它可能会更糟糕，架构本身可能是错误的，然后它一体化的手在甲板上找到一个工作。它真的很痛苦。  
### 回答 83
其余的  
在（主要）VB.NET中维护遗留自定义ERP系统。仅用于在某些情况下在Excel（通过COM Automation）中产生90分钟的Excel（通过COM Automation）的报告，有一个巨大的代码（5k + loc）。该报告以超过50k的往返SQL进行，并且可能会使Excel的100k + Com调用。经过几个小调整到SQL  - 使用已经在内存中的字段而不是在嵌套函数中进行单独的呼叫，并缓存一组获取数百次的记录，我将SQL循环降至〜200和平均运行时间降至10分钟。  
剩下的时间主要是在COM调用中，所以我创建了一个适配器层，模仿Excel Com API并重定向所有呼叫使用epplus，所以我不必重写5k行，并将运行时间重写为5k行并将运行时间放在下行10-15秒。  
### 回答 84
从磁带机读取数据（本公司专门从事旧数据存储格式） - 原始开发人员一次读取一个字符，从磁带上字符的物理顺序中读取一个字符。磁带是具有小数据容量的顺序设备所以......ReadThewholefuckingthingintoadiskfilethenprocessityuidiot  
1000x加速。  
### 回答 85
年：1997年。我被要求拿一小块软件并加速它。制作了各种小的变化，每个都基本上是一个环路重写。从1兆字节/小时到> 800兆字节/小时。介意你这是在1997年的奔腾，所以它不能快速做任何事情。  
一个速度加倍来自从Windows到Unix。  
在其他程序也发现了循环重写。  
### 回答 86
我不知道这是最戏剧性的，但它是最近在我的内存中最初步的。它在题为更新的部分的此答案的底部是：  
<span> gerry rzeppa </ span>  
<SPAN> B.S.MATHEMATICS与计算机科学，劳伦斯技术大学（1975）</ SPAN>  
这不是一个微不足道的问题。在这里，在普通的英语伪代码中，是我采取的方法：  
要运行：启动屏幕。屏幕。框5英寸左右2英寸.Center在屏幕上的框.Draw，用白色笔填充框。给出一些对象的一些对象。绘制物体.Awrak.draw object.make在boder中的所有黑色斑点。eStryoy的对象。从列表中的对象进行。绘制对象的对象（一次一个像素）.describe boder下的对象.​​Refresh屏幕.destroy objects.destroy该列表。等待eash eash.shut。阵列和对象  
因此，我们从一个大约92,000像素的二维阵列开始，其中包含在白色背景上的黑色绘制的三个任意形状的物体，如下所示：  
在此阶段的对象是定义明确的多边形，其尺寸和区域很容易导出。这将是作弊的。我们要做的是，除了屏幕上的像素来指导屏幕上的那些对象是什么问题一点较小，更简单，我决定从...开始......  
黑色像素列表  
因此，我们搜索阵列，左右，顶到底部，并制作我们遇到的所有黑色像素的列表：  
要在框中列出所有黑点：将框左上角放入spot.loop.get给出的颜色。如果颜色真的很黑，则将现场添加到列表中。右图1 Pixel.如果那点仍然在盒子里，则重复。将点点重复到盒子的左侧。斑点下降1个像素。如果位置仍然在框中，则重复。声，这么好 - 除了该列表包含来自所有三个对象的所有像素均匀地闪烁成单个列表。因此，我们需要...  
从黑色像素列表中重新创建对象  
......在我们去的时候分离物体。这些是我曾经做过的子程序：  
要重新创建一个对象的列表：如果列表是空的，则为object.allocate内存。首先将列表从列表中的列表到vertics.loop.if从列表中触摸到返回flag的对象。该标志未设置，break.repeat。要将触摸顶点从列表中移动到返回标志的对象：清除标志。将列表归一键入顶点。如果顶点是nil，break.if theptex是nil没有触摸对象，将顶点旁边的顶点放入顶点;重复。将顶点从列表中从列表中键入下一个顶点到对象顶点。将标志设置为顶点。将下一个顶点输出到vertex.repeat中。一般想法是这样：  
•使用列表上的第一个像素启动一个新对象;然后•如果它们触摸已有对象中已有的任何像素，请从列表中移动像素; •重复此过程，直到行程通过列表导致没有像素移动;然后•再次执行此操作，直到列表上的所有像素已移动到Object.test运行  
我有程序在原始黑色对象的顶部绘制了蓝色的重新创建对象，以便我可以在视觉上检查，我们在每个重新创建的对象中获得了所有正确的斑点。然后我写了一点子程序来编号对象并描述每个它们在阵列下。它是测试运行的一些屏幕截图（对象每个运行都有不同）：  
注意，由于它们的形状不规则，因此无法使用像宽度的公式计算实际区域。  
另请注意，该计划并不像兔子那样快速。eteven没有那些日志和大o，而且我确定的是改进的空间。当然，我们考虑运行时间为92,000像素可接受2到13秒的运行时间阵列有三个小的不规则图。如果现在，我认为我会向其他人留下性能增强.IDEAS？更新  
我想提高了一个绩效改进。在这个例行中只有几行（以粗体显示）......  
要将触摸顶点从列表中移动到返回标志的对象：清除标志。将列表分布到顶点。将对象框分为框。提交框1 pixel.loop.如果顶点是nil，break。如果框中的顶点位置不在框中，请将顶点旁边的顶点放入顶点;重复。如果顶点未触摸对象，请将顶点旁边的顶点放入顶点;重复。将顶点从列表中键入下一个顶点。从列表到对象vertices.set标志。如果顶点左侧是左侧的顶点，则从左侧的框中减去1像素。左边的顶点斑点是框右侧，向框中添加1个像素。如果顶点斑点顶部是盒子顶部，从盒子顶部减去1像素。如果顶点斑点顶部是盒子底部，将1像素添加到盒子底部.put下一个顶点进入顶点。......我能够让13秒钟跑到2 1/2秒。一个3分钟运行（具有较大的物体）下降到25秒。  
### 回答 87
免责声明：我不是软件工程师，也不是我真的是程序员。  
我有一个VBA例程从Excel中的一个选项卡中获取数据，解释它，然后基于数据生成格式化的选项卡。它做了很多东西，但那是短版本。  
这件事花了大约45分钟来完成。这是我了解到代码优化的地方！  
一个重大变化是如何在Excel表中浏览行。  
命令将焦点更改一行向下  
ActiveCell.offset（1,0）.Activate  
并且ID通常循环，直到完成某些事情。有一天，我们注意到它在de时造成了明显的延误  
免责声明：我不是软件工程师，也不是我真的是程序员。  
我有一个VBA例程从Excel中的一个选项卡中获取数据，解释它，然后基于数据生成格式化的选项卡。它做了很多东西，但那是短版本。  
这件事花了大约45分钟来完成。这是我了解到代码优化的地方！  
一个重大变化是如何在Excel表中浏览行。  
命令将焦点更改一行向下  
ActiveCell.offset（1,0）.Activate  
并且ID通常循环，直到完成某些事情。有一天，我们注意到它在调试时花了一个明显的延误。那个时候发现切换活动单元时是耗时的。你知道什么方式消耗了将值分配给变量。  
所以而不是像这样的东西  
<ol>虽然thinghasnthappened = true（检查thinghashappened的活动小区）activeCell.offset（1,0）.Activate Wend </ OL>  
<li>而thinghasnthappeded =真正的</ li>  
<li> </ li>  
<li>（检查任务的活动单元）</ li>  
<li> activeCell.offset（1,0）.Activate </ li>  
<li> wend </ li>  
成为  
<ol>虽然thinghasnthappened = true（检查activeCell.offset（var，0）.value意味着thinghashappened）var = var +1 wend </ ol>  
<li>而thinghasnthappeded =真正的</ li>  
<li>（检查</ li>  
<li> activeCell.offset（var，0）.value </ li>  
<li>意思是Thinghashappened）</ li>  
<li> var = var +1 </ li>  
<li> wend </ li>  
那一点变化减少了一半。  
我仍然非常感到骄傲那个一点变化。  
### 回答 88
代码是Excel电子表格。它在一个标签上使用了数千个精确的Vlookup，以查找来自10,000行的值，在另一个选项卡中查找许多列数组。  
原始设计可能有30个Vlookups，以获取每行结果的各个列中的值。  
确切的vlookups非常慢，甚至正在搜索的内容是对这些行进行的。  
解决方案：  
性能改善约为120：1。  
### 回答 89
我继承了一个串行通信库，在UART上实现自定义协议。  
字节超时指定为20ms。也就是说，如果在前一个字节内未接收到上一个的20ms内，则认为接收失败。  
这是一个古典设计。处理字节从UART接收事件的ISR，并将接收值推入FIFO缓冲区。  
单独的数据包解析任务从缓冲区弹出值，然后使用一些嵌套状态机构建并解析接收的数据包。  
解析任务的最低级别将位于20个循环中  
我继承了一个串行通信库，在UART上实现自定义协议。  
字节超时指定为20ms。也就是说，如果在前一个字节内未接收到上一个的20ms内，则认为接收失败。  
这是一个古典设计。处理字节从UART接收事件的ISR，并将接收值推入FIFO缓冲区。  
单独的数据包解析任务从缓冲区弹出值，然后使用一些嵌套状态机构建并解析接收的数据包。  
解析任务的最低级别将位于本地循环中，以便在弹出字节之间交换20ms，然后查看新的接收字节是否可用。在此延迟循环中花费超过90％的处理器时间。  
### 回答 90
通过从一些学术代码重写统计计算的〜3600x，我试图集成到更大的系统中。计算从一天中的大部分时间到几秒钟。是的，写道的任何内容或毕业生都需要更多地关注。实际上我想出了计算不仅是超级慢但错误的计算。它计算了统计数据定义的东西以外的东西。  
### 回答 91
2h下降到几秒钟。  
在附加到数组时，实习生没有了解二次复杂性。  
回答：从简单的改变中，你在一段代码中获得的最戏剧性的加速是什么？  
### 回答 92
一旦将计划从4天（100小时）更改为200：1性能不适应的1/2小时。  
是用基本编写的，涉及从/到磁盘读取/写入大矩阵。这个过程是绑定的  
a）对数据的原位压缩（30：1）做了  
b）使用汇编程序调用BIOS磁盘例程而不是基本IO。 （6：1）  
用户还能够增加矩阵大小，因为它们受到了当前MS DOS的32MB磁盘尺寸限制的限制。  
在另一个客户端，我简单地通过更有效的算法替换了内置的排序例程（可能是shell sort），并实现了类似的重新  
一旦将计划从4天（100小时）更改为200：1性能不适应的1/2小时。  
是用基本编写的，涉及从/到磁盘读取/写入大矩阵。这个过程是绑定的  
a）对数据的原位压缩（30：1）做了  
b）使用汇编程序调用BIOS磁盘例程而不是基本IO。 （6：1）  
用户还能够增加矩阵大小，因为它们受到了当前MS DOS的32MB磁盘尺寸限制的限制。  
在另一个客户端，我简单地通过更有效的算法替换了内置的排序例程（可能是shell sort），并实现了类似的结果。  
当时（80年代中期）编译器，操作系统及其彼此的互动是atrocius。用户开始使用Micro Computers来源严重的商业目的，并击中各种愚蠢介绍的技术问题。  
在一个情况下，当数据在硬盘驱动器上超过1-1.5MB时，“关系数据库”简单地失败。拒绝索引和存储管理已为8英寸软盘设计 -  1.2MB，并不支持数据库任何更大。 8和16位指数（256和65000记录限制）是常见的。  
### 回答 93
不是那么简单的改变，但在概念中它是。我重新制作了一个数据库进程，即花费了一天多，完成了每天30秒的人。我通过使用哈希表来最小化I / O来通过本地缓存来完成。  
### 回答 94
C从Fortran向后分配多维数组。当手转换为C时，有些人忘记了这一点。这可能导致可怕的高速缓存利用率和非常缓慢的执行。逆转阵列上的索引顺序通常会导致数百或数千个的加速。  
### 回答 95
他后几个小时后回来了一个巴洛克式  
在我的头顶，一个数据库查询，几个小时几个小时即时切割到几乎立即，当我将其更换为更简单的查询并使用一些客户端代码来过滤掉无关结果。  
很短的故事短暂这是一个计费应用程序，需要加入五个表，以获取所有发票的所有票据，所有的计费周期为给定客户。或类似的东西。在所有相关表中都不可能干净地加入。  
我去了高祭司DBA（这是一个大型金融公司）  
后来他回来了几个小时的时间，勇敢地（和破产）复杂的查询。  
查询在50个客户开发数据库上运行罚款。  
查询在500个客户测试数据库上花了一个小时。  
所以我们禁止查询并编写了一些过滤了已关闭发票的客户端Java代码。 Dumbed Down查询可能返回一百左右的发票。它在秒内显示结果。  
作为侧面笔记，因为尿子，在特定对话中提高了对性能的关注，我使将该滤波代码尽可能紧。这也使它相当扭曲。我离开这个演出前的那一天，他们让我坐在其中一个开发者，他们在过滤所在的代码中同一社区中解决了一个错误。他自然地遇到了解我的曲线过滤代码（我没有责怪他 - 很难写，应该很难阅读！:-)）并怀疑问题在那里。  
只是为了让他开心，我通过用一个愚蠢的蛮力方法替换高度优化的过滤代码，刚刚将其解析为列表中的列表中的哈希值。它产生了完全相同的结果，从而证明了曲线代码是不是错误的来源。它也像高度优化的代码一样快，至少就是人类的感知。  
我告诉他要提交代码的蛮力版本。没有必要在其他一些可怜的混蛋上造成那个巴洛克式代码。  
但这是一个有用的实践经验，证明我应该应用第一个优化规则：别。  
现实是，大多数时候，你并没有真正跟踪速度改进。您通常忙于忙于正常工作以开始使用，而99.9999％的时间性能是无关紧要的，或者在基本设计选择中解决（AKA算法优化始终击败热点优化）。  
在某些情况下，性能问题可能会随着旨在简单地改善代码和应用模型的工作的副作用而改善。我用XML解析器看到了类似的东西，我写了一个我曾经合作过的最聪明的开发人员。 (Note, I don’t advocate writing your own XML parser — this was fairly early on when the options available weren’t as good, so it made sense for us to write our own, designed for our specific constraints.)  
在审查实际解析的巨大记录（标签的实例化和破坏）的同时，我们注意到了大量的一定数量的某个标签对象，并且几乎立即被破坏。我们提出了一个稍后回到那个问题并优化它 - 这是一项弃权的任务，因为当我们重构代码并清理对象模型时，改进的设计最终删除了问题。  
### 回答 96
1983年，我正在编程TRS-80电脑，用于汽车经销商，用于填写销售汽车所需的表格。表格有四种不同的菜单屏幕。其中一个经销商抱怨说它需要从一个菜单到另一个菜单。这是一台慢速计算机，您将等待大约5秒钟屏幕清除并显示另一个菜单。视频显示映射到内存部分，并且存在存储视频内存地址的存储器位置。我在程序启动时写了十几行代码，将所有菜单加载到不同的内存位置。当用户选择不同的菜单时，而不是将其写入视频内存时，我刚刚将先前存储在存储器的菜单的位置写入指向视频内存的地址。菜单立即弹出。  
### 回答 97
它是一个数据库应用程序。用户抱怨，抬头看起来很长一段时间，差不多一分钟。  
我检查了代码，看起来还不错。检查了DB架构，看起来还不错。检查领域，这是什么？主键未索引。意思是，每次搜索都是顺序的，从纪录1开始，通过每次记录，直到它找到它正在寻找的记录。  
我更改了主键，所以它被索引，查找变得瞬间。  
### 回答 98
在我的职业生涯中，我修剪了超过两个小时的薪资营地。这是我在Liocs工作的时候。我们的一个客户有一个用VAX COBOL写的总公司薪资系统。  
工作存储中有一个表（脚本 -  kiddies的数组），在处理每个检查时存储大量总计和其他计算。有10个级别的东西，但看起来有点像这样。  
<OL> 01截木数据。 05片段机票发生了500次。 10票号PIC 9（10）。 10件数图9（6）。 10次​​速率PIC 9（2）.v9（4）。 ... </ ol>  
<Li> 01截面数据。 </ Li>  
<Li> 05截机票发生了500次。 </ Li>  
<Li> 10票号PIC 9（10）。 </ Li>  
<Li> 10件数图9（6）。 </ Li>  
<Li> 10件PIC 9（2）.v9（4）。 </ Li>  
<li> ... </ li>  
他有一个段落  
在我的职业生涯中，我修剪了超过两个小时的薪资营地。这是我在Liocs工作的时候。我们的一个客户有一个用VAX COBOL写的总公司薪资系统。  
工作存储中有一个表（脚本 -  kiddies的数组），在处理每个检查时存储大量总计和其他计算。有10个级别的东西，但看起来有点像这样。  
<OL> 01截木数据。 05片段机票发生了500次。 10票号PIC 9（10）。 10件数图9（6）。 10次​​速率PIC 9（2）.v9（4）。 ... </ ol>  
<Li> 01截面数据。 </ Li>  
<Li> 05截机票发生了500次。 </ Li>  
<Li> 10票号PIC 9（10）。 </ Li>  
<Li> 10件数图9（6）。 </ Li>  
<Li> 10件PIC 9（2）.v9（4）。 </ Li>  
<li> ... </ li>  
他有一个段落来归零。它有一个执行循环，并为所有500个票证单独移动零。  
在20世纪80年代的课程系统上，您可以想象它跑了多么糟糕。我甚至没有要求解决这个问题。我正在为程序做别的事情并看到该代码。它跟着wtf？片刻。  
所有这些循环和移动都被一行所取代。  
<OL>将零移动到几块工作数据。 </ OL>  
<li>将零移动到几件作品数据。 </ Li>  
就是这样。一天的CISC机器具有OPCODES到NULL或字符初始化RAM块。无论大小，他们都可以在一个指示中进行。  
第一次客户筹资薪资，他们从他们进入的南方州叫我并告诉我  
工资单必须崩溃！它已经完成并检查是打印！  
不，我修好了，而我正在为你做另一件事。  
我们从小到几小时到几分钟才能创建检查文件。打印，嗯，它在纸上印刷，因此没有加速。  
### 回答 99
从简单的更改中，您在一段代码中获得的最戏剧性的加速是什么？  
在我最早的职业工作之一，我是JPL的程序员，为深空网络做VLSI CAD / CAM。那是在20世纪80年代。  
我们的一个对象是一个设计规则检查器。它可以在布局设计中找到错误。对象太小，太靠近在一起，无论如何。我的朋友太过了这个计划。一个结束了我的第一个婚礼的最好的人。  
尼尔和琳达希望在内圈中使用良好的编程方法。我确信他们要使用静态变量来存储当前点为每层材料的位置。那些被计数器进入巨大的阵列（结构阵列不是浮点数的数组）。  
每次调用内部循环时，都会使用静态计数器的开关，它已经在主内存中使用了数据以启动。结果倍数超过10k的性能。一个人可以在整个日期运行一分钟时分析的电路。  
在虚拟内存系统中考虑驻留记忆。摩尔定的法律将推动现代系统能够通过蛮力将其加载到居民记忆中。但VLSI电路成长为确保他们的模型永远不会适合居民记忆。  
### 回答 100
另一个时候，我做了一个重大变化，而不是一个简单的改变，从30个级别的网络页面到达30秒，做  
无限。我们有一个将每日崩溃的系统，每日在东部3：30-4。我试图弄清楚正在发生的事情。我非常彻底研究了这个问题，我发现链条中的一个组件不是服务器安全，直到版本3.我们在版本2.x上。在一些战斗之后，我得到了服务器的人安装更新的组件。这是一个XML组件。我更新并移动到执行XSLT以产生HTML，服务器RAN，AMD RAN和RAN。没有失败。  
另一个时候，我做出了一个重大变化，而不是一个简单的变化，从每一个网页的30个级别广告时间从30秒到大约2秒钟。  
其他时候，它是基础，就像使用之前没有的SQL索引一样。有一种戏剧性的加速。  
一旦，我从Direct DB插入更改为使用Message队列。从不努力工作的东西移动。这不是一个巨大的变化。  
另一个更改是从Web流程向Windows服务移动。提供了很大的性能改善。  
如果你明白你在做什么，那里有很多优化。  
### 回答 101
作为数据科学项目，我有一个SVM在基于WA的数据集中的类别之间绘制决策边界  
所以我不是一个程序员，我的代码很难以糟糕的本身。也就是说，有些时候我已经设法找到了东西。  
一条代码在基于x，y坐标的基于x，y坐标计算位置之间的距离的排序。计算距离的正方形的排名给出了相同的结果，但消除了SQRT操作。总而言之，全部计划加速是谦虚但显着的，但在那种特殊的循环中，它截止了运行时约40％。  
作为数据科学项目，我在基于太多数据点的方式中，我在数据集中的类别之间绘制了决策边界。只需运行一些过滤器即可挑选出我们所知道的绝大多数数据永远不会接近决策边界，让它在大约1000次运行。不是我的代码，而是一个大的加速。  
然后有一个客户推荐系统......我的垃圾是我需要修复的第一个地方。该工具查看了客户的属性，计算了不同产品的一些指标（具有大复杂的公式）然后推荐顶部。在一点点深深的潜水上看，有可能在什么情况下看出产品永远无法推荐的。这是一个周末的工作，可以将评分系统转变为决策树，但它将系统转换为不可行的。  
### 回答 102
我不知道这是我职业生涯中最大的加速，但它非常好。某些情况下近1000倍。  
在Autodesk，一组人士正在构建下一个Gen存储容器（文件格式），用于为我们的工具保存场景资产。我们对我们的云渲染系统的解决方案构建了我们的解决方案。  
事实证明，场景中的资产重复也以格式重复。这意味着使用多次多次使用相同纹理的场景是多次上实例的情况下，将变得超臃肿。  
对于一些玩具场景，这不是一个问题，但对于许多真正的场景来说这很可怕。有一天，场景打破了骆驼回来了。这是一个非常简单的场景，具有许多重复的纹理。加载现场在400秒内拍摄超过200秒，而在低质量上设置和渲染只是几秒钟。  
我花了一周写一种自定义格式，即取消复制和压缩二进制文件，包括网格和纹理数据。运行相同的场景只需要一秒钟的一部分加载。对于这种场景，这种加速伤口比两个更靠近两个数量级，但即使对于没有如此多的复制而甚至持续更快。  
### 回答 103
性能如何增加几百倍，没有代码改变？有人在内循环内编码了相当复杂的计算，但计算只依赖于外环。打开优化允许编译器提升到内循环中的不变计算，从数千个指令到几十个，减少了从数千个指令中执行的代码。实际计算最终从源中的内部环移动，但没有额外的性能改进（当然是未优化的构建除外）。  
### 回答 104
我快速地抨击了原型是拿出来的  
生物信息学。  
我正在使用Bas Tutil的Cat / Bat代码进行分类呼叫;它通过打开阅读帧生成并将每个ORF映射到NCBI NR / NT数据库来实现。然后使用基于每个ORF的最可能分类的投票，然后在ORF上投票以确定CONTIG的分类。我要重新使用耗时的ORF数据并解析功能辅助：这涉及一些重新批准输出以提取注释。问题是我需要对数据库进行这些注释的查找。  
我的快速抨击一起原型是将输出和Grep -m 1抵抗参考文件;然后我通过剥离标题（标题文件有注释，分类和功能信息）来做加速度，使事情更快。  
当我转动剥离标题文件时，大规模的加速来自，在SQL中生成索引并使用SQL执行查询。繁荣！巨大的加速和减少时间和降低内存消耗。在某些情况下基本上几小时到一分钟左右，因此随时减少一个或两个数量级。  
### 回答 105
不是C ++，实际上是在医院的STC接口引擎上运行的Java脚本，处理医疗记录系统和临床系统之间的HL7消息。  
HL7消息的多个段由回车返回分隔。一些段或一组段可以重复。每个段都有多个管道分隔字段。某些字段允许重复分隔符。  
在这种情况下，该消息是放射学事件的结果。有人有一个X射线或超声波，或者有一些这样的结果。  
它看起来像这样：  
代码应该看看文本行，如果它们是不同的子类型，请处理文本转换和它们以不同方式向目的地系统出发的顺序。目的地不想要的一些子类型。有些人，但在消息的末尾而不是开始  
我得到了任务添加另一个子类型......  
我看看多年来积累的代码......  
循环在4级，循环在4A级，循环在4AI级别，if语句用于处理第二个子型。 EndLoop，EndLoop，EndLoop。  
等等  
一直到第五个亚型，我应该加入第六个。  
我想到这一点每个人都看到了明显的代码变化。  
### 回答 106
多年前，我为其中一个vaxes（实际上）的人创建了一个帐户，我们在房子里有的vaxes，所以他可以操纵他收集的一些飞行试验数据。他对他的福特兰人的描述被认为对我来说都不听，好像它正在做任何非常复杂的事情，但它在1月份的糖蜜就像糖蜜一样。在他的代码上快速浏览了这个问题。他被告知将整个数据集阅读到内存中总是更快的速度，操纵它，然后将结果写入磁盘。我让他抛出他在代码中声明的阵列，并修改他的处理循环一次，一次读取一行中的数据，并在每次通过后重新加快文件。 （几次通过数据是他使用的过程的一部分。）他抗议但无论如何都在尝试。修订后的计划现在像润滑脂一样耗尽。通过一次读入内存中的所有数据，他得到了系统来演示延迟的教科书示例，而当它疯狂地交换了他的数据进出内存。  
然后有代码库，我被递送 - 大型机代码在PC上实现 - 其作者遭到他的优化排序例程。在将其上运行并在PC上运行（IBM Fortg到MS F77转换）后，结果证明了整个过程中最慢的部分。我看了一会儿，意识到他的优化排序例程只是一个泡沫。我卷绕成两部分：预排序和后排序。 DOS批处理文件每半都耗尽夹在中间的DOS SORT命令。它跑得更快。  
### 回答 107
在我的职业生涯早期，我被任务提高了一个服务的质量..它提供了一个HTTP端点来接收GPS数据，像位置，速度等的属性列表。该服务将这些GPS曲目转换为地图上的路径。估计的车辆速度。要做任何先进的事情，作为问题的一部分，我必须弄清楚如何更快地运行它。它确实将信号位置投影到地图的段上，计算所有考虑的路径上的概率分布，并恢复最可能的路径。这些速度用于在地图上呈现当前的交通状况。作为子程序，它必须在图表上找到2点之间的最短路径。它是实时这样做的，它很慢。  
基于现有数据的一个观察是相邻的GPS信号在时间上不太宽，并且车辆在该时间覆盖多少距离限制。据我所知，截止距离是2km。正如它所依靠的任何给定的顶点，在该附近的地图图中没有许多顶点，我认为它小于100.因此，可以使用所需的所有统计数据来预先计算所有顶点的所有最短路径。 。  
这不是一个单一的变化，但它达到了大约10倍的显着性能提升。我被告知，我们的管理员在变化消耗几乎很少的CPU后，我们的管理人员特别高兴。  
### 回答 108
我们正在将Solaris的JCAPS实例从Solaris转移到HP-UX超级编辑，但在启动时，大约需要30分钟 - 不适合从某些过度的4种方式接管的64路小型计算机，这在不到1的时间内启动JCAPS UP分钟。  
我突击了这个过程，看到了JCAPS库正在搜索像Open（）这样的标准函数。我重新排序ld_library_path并爆炸它在不到15秒钟内运行。  
这是一个有趣的老东西，为什么需要改变甚至需要 - 我从来没有遵循它，但在我们的Solaris建造上，我们没有必要在路径中包含标准库，但我们已经完成了HP-UX。  
测试需要进一步一半的测试，以确认我的修复没有介绍任何不利行为，所以如果你考虑到这一点，也许我的修复得如此简单！  
### 回答 109
仅通过将编译器选项从-o大小转换为-o速度，仅为一个源文件，仅通过将编译器选项转换为-o速度的30％的运行时减少。编译器优化确实在正确的地方使用时会产生差异。  
### 回答 110
那么这不是一个加速，而是一种速度;）这是一个非常大的房地产，大约100k对象，我不得不解决一个简单的问题，这在城市案件上寻找思想，所以在查询中，我做了一些object.city.Toupper（）= $ city.toupper（）2分钟修复工作。然而，在释放后，整个网站剧烈慢。由于我们没有多少变化，我们真的很困惑是什么问题。现在我们有一个非常好的SQL家伙分析了这个问题，最后他告诉我，SQL Server Egine如果在您的查询上应用帖子备用子，则SQL Server Egine会在区分大小写的数据库上跳过索引;）  
### 回答 111
客户在Java编写的大型应用程序有一个大问题。数以万计的代码行。我想大约15年前。他们问我们，Java Internals专家，寻找可能的问题。它很快似乎对GC，垃圾收集器和创造动态和短寿命的隐藏成本的行为有不好了解。它们的跟踪机制几乎在其代码中使用了几乎到处都是致力于创造旨在打印的大量字符串，轨迹打开和关闭时。因此，即使不需要追踪，也产生了大量的弦，然后几乎立即通过GC除去。因此，对象存储器连续充满了非有用的字符串，并且GC在存储器中连续地移动物体，以便摆脱非有用的对象并获得一些可用空间。解决方案很简单：在每个地方添加一些IF（追踪），在每个地方创建用于跟踪的字符串。速度增益约为10倍。他们的错误是不知道Java如何在内部工作。  
### 回答 112
许多年前，我曾写过一个程序，虽然一个设置匹配和计数某个对象在文件中找到的次数以及我的第一个初始实现使用列表，但如果不多，则需要5-6小时跑到完成。所以下一个版本使用二叉树，而且需要20分钟运行。现在我可能会使用地图或哈希表，并且在现代快速计算机上可能需要一两分钟。  
### 回答 113
避免在循环内部分配和释放内存可以大大加速其他简化的计算强烈应用。  
我曾写过一个共轭梯度求解器，它在迭代内部和上面创建了矢量对象。（我的运算符*创建并返回对新对象的引用，并且每次迭代发生了很多次）。  
当我用一系列向量替换它，这些向量是在编程的开始时创建的，只有一次，我很容易获得10-100次的加速。  
### 回答 114
我重写了一份每日PHP作业，计算Postgres DB中的条目的佣金，注意到它没有任何类型的指数 - 甚至没有什么是主要键。它也加入了整个地方。在定义几个PK之后，从15分钟到不到5秒钟。  
### 回答 115
所以我自己试图这样做。直接向前编程在c中只是读取更新磁盘并写下更新  
很多年前，我在医疗信息系统上工作。我们使用了Omnis（带有集成数据库引擎的RAD），几乎完成了原型以及在数据库的更新模块上工作（数据库将由Pharma行业提供的许多磁盘上的每月基地更新）。集成在Rad-Tool中的更新功能结果是一团糟。要执行单个更新将持续大约15小时，不必说出业务应用程序不可能。  
所以我自己试图这样做。在C中直接编程只是读取更新磁盘并将更新记录直接写入数据库。第一次测试表明令人难以置信的提升。它只持续一小时而不是15个小时。这向我们展示了正确的道路。我们填写了全部并用自己的代码建立了整件。在最终的优化版本中，更新持续了大约30分钟，这是我们的业务应用程序可持续的。  
### 回答 116
在Pre-C ++ 11代码中，当ListBox中的项目计数为10000时，我们在使用UI中的列表框中使用ui中的列表框进行了非常慢的速度。我们执行了剖析和找到列表:: size（）函数花费很长时间。减速原因是GNU C ++实现中的这种功能具有O（n）的复杂性，并在n的循环中调用。有效地o（n ^ 2）。存储列表大小以及列表制作时间复杂度O（n）和所有操作都快速Zippy。o（n）改进时间。变化很小，性能增加巨大。  
在C ++ 11中，现在标准命令大小（）方法应该是O（1）。  
### 回答 117
在一个雇主，开发人员设计了在GUID上排序的所有表 - 这意味着查询连接逻辑速度慢的随机数。  
然后我被要求加快查询来匹配发票和付款，并占用10分钟运行。因此，我添加了一个覆盖索引来排序业务密钥并沿着新密钥匹配，发票日期比付款日期大（毕竟您无法支付不存在的发票）。开发人员嘲笑这种疯狂的逻辑，但在巨大的性能改善方面感到愉快。  
### 回答 118
将变量更改为阵列到集合。将我们的服务器切成两半。从50到25次。保存了很多$$$，并大大加快了代码。  
### 回答 119
结果是载波频率除以频率的快速  
在毕业过程中，我开发了一种用于频率和时间域的电子电路仿真软件。电信系统的时域模拟可以非常慢，因为步骤数量应与载波的频率成比例。  
后来我实现了另一种方法称为包封仿真，使用完全相同的算法，但将浮点更改为复数。在这种模拟中，数字OS步骤应与调制信号的频率成比例。  
结果是载波频率的加速除以调制信号的频率除以载波。例如，由10GHz载波调制的10kHz信号的模拟速度速度速度差不多百万倍。  
### 回答 120
>来自简单变化的代码中最戏剧性的加速是什么？  
为一个分布式应用程序节省约93％，但技术上，这是3个简单的变化。  
另一种衡量它的方法是原来的速度约为14倍。  
很久以前（在远处的陆地上），在拨号调制解调器和国家数据包交换网络的日子里，我的雇主在早期的MacBook上建立了销售队伍自动化计划，允许每个领域的销售经理配置销售分配遵循日期并上传到大型机（IBM 3090），销售人员可以检索个人作业。  
但是，在该字段中部署时，大约需要3个小时才能从Manager按下发送时完成上传。  
此外，克拉皮1993汽车旅馆中断的机会相当大，所以重启（几次）往往是必要的。  
这就是他们带给我的东西。 C ++是我们的新语言，我最近开始在内部教它，所以人们一直在问，你要做什么，在C ++中重写它？ （或类似。）  
规则＃1  - 从未优化，直到您衡量它正在做的事情。  
规则＃2  - 从不优化，直到客户（BOSS，PM等）告诉您需要快速（如果您将其提高100倍，除非您有承诺，否则他们将需要200次。）  
所以我的答案是，我不知道;我将首先衡量，SR MGR和PM表示，一个小时将非常感激。  
事实证明，它在三个地方大致花费了1/3：  
你可以做出这些0中的任何一个，并且仍然只刮33％或掉下来0或掉落到0，几乎没有满足要求。  
此次计划一次发送一条记录（以考虑19bps调制解调器加上或减去符合特定的酒店的比特）所以第一个虽然是让我们批量批量并发送它，但它应该带来网络时间和大型机时间下来很多。  
请注意，主机上的每个记录不仅需要握手，还可以启动那些日子中大型机上的典型事务处理的程序 - 对于年轻人认为向Web服务器或REST API发送一个记录并为每个响应发送响应。  
也许我最多完成了我的2个 - 所以也许我可以通过在笔记本电脑上做更多的处理来获得1小时。  
但后来我仔细看着笔记本电脑代码 - 诚实地写了一种慢速语言（高速公路）所以是的，C ++转换可能有很多帮助。  
同样，对于年轻人高速公路大致类似于Visual Basic或类似的脚本版本。方便，几乎可通过非程序员，但不用于大量提升大数据库计算。  
然后我找到了：程序员正在使用阅读的下一行或一些这样的呼叫来读取3000-5000条记录的文件。他们可能在开发过程中测试了几百条线路，而不了解销售经理将如何实际使用该程序。  
但是，特定的呼叫重新读取每行的文件。它不仅仅读取第二行，而且必须读取第1行，然后读取第2行，然后在第2行得到第二行，随着文件的增长，它会变得更糟（n ^ 2是我们在这里的东西 - 作为记录的数量它不会需要两倍，但大约4次 - 广场。不是一个大问题，几十几个甚至数百次记录，特别是在IT部门内的优质电话线。  
所以，3个变化都是简单的，不是火箭科学，也不是算法的巫术：  
所有三个部分均粗略地下降到5分钟内。典型时间是13分钟而不是3小时。  
通常，呼叫将保持联系13分钟，甚至重启不需要销售经理留下夜间监控和重新发送的一半。  
当您被要求优化别人的代码时，它可能会感到不舒服，因为几乎按定义您正在寻找他们的错误或设计失败。  
但我们可以了解这些差的决策中的每一个可能对原始程序员当时以及在不切实际的条件下测试时的意义。  
快速，简单，让每个人都幸福（我从未与其他程序员交谈过。）  
### 回答 121
我添加了一个`.tolist（）`一次，将5分钟的操作从5分钟到仅限秒。为什么？嗯，它是一个借款操作，使用懒惰的溪流。重新评估延迟流时，需要递归地重新计算所有操作。只需缓存列表中的结果，在这种情况下保存了O（2 ^ n）操作。  
### 回答 122
我在Matlab中写了一个图像处理应用程序，为我的大师项目。这是在1995年回来的，虽然我有一个Comp Sci本科，但我没有经验，这是一个导游的武器研究生计划，所以编程是对我的项目支持而不是中环。我还在我的家用电脑上运行应用程序，这不是/不是很强大。  
我在方块的图像上解析了正方形的图像，执行矩阵计算，它是永远的 - 我的第一次运行之一超过2天才能执行。我意识到，在初始计算之后，我正在向前移动一个像素（在ANXN块上，其中n大约为10-50），并且只需更简单地丢弃不再使用的列/行的方式，只需在新列/行中添加。我不记得确切的细节，但我对解析有了100倍的改进，这转化为整体计划的10倍改善。  
仍然不宜为寻找不蛮力的方法来保护解决方案......  
### 回答 123
这是40年前的回归，我编程的系统没有硬件乘法或划分。作为它需要将二进制信息转换为二进制编码的十进制（BCD），并且BCD到二进制数百次系统在这些时间慢。  
改变改善子程序改变了转换用于除以除以10的10次，例如100,000的电量的连续减法，计算阳性结果的数量。一旦结果为负，将减去减去值并将BCD结果（计数）移入位置。然后减去10的下一个功率（10,000），最终仍然是最后一个BCD值。  
该系统非常慢，每次使用划分所需的时间为35毫秒。 99,999的所得常规占6毫秒。要说，请说出1000的BCD值将需要大约.6毫秒。  
对于BCD到二进制语我使用了一个小技巧来创建乘法10乘以剩余的值乘以8，然后将初始值添加两次，使其成为十两次。将下一个BCD值添加到该结果并再次乘以10，直到转换所有数字。结果为20毫秒至.8毫秒。  
### 回答 124
问题是校准花费太长，这不仅为用户造成延迟，而且可以生成用户  
案例1：我工作的装置有一个力梁，其在推动通过导管时测量力。反复将导管堵塞进入机器，每次插入时，都必须校准力梁至零。  
这是通过计算添加到8位ADC读数的偏移量来完成的。 ADC必须读取几次以获得平均值，每次读数之间存在少延迟，以允许设置。这种延迟，我相信大约是10毫秒。  
问题是校准花费太长，这不仅为用户延迟，而且可以生成用户错误。这是产生大量的支持电话。  
所以我看了代码，它是这样的：  
<ol> for（int i = 0; i <256; i ++）{programoffsettoadc（i）; int val = readadc（）;如果（val == 0）突破;睡眠（10）; } </ OL>  
<li> for（int i = 0; i <256; i ++）</ li>  
<li> {</ li>  
<li>编程OFFSETTOODC（i）; </ Li>  
<li> int val = readadc（）; </ Li>  
<li> if（val == 0）</ li>  
<li>打破; </ Li>  
<li>睡眠（10）; </ Li>  
<li>} </ li>  
测试显示了60-70的典型偏移量。因此，此代码将具有600-700msecs的运行时。  
我改变了代码来做二进制搜索偏移量，这样的东西：  
<ol> int offset = 256/2; do {programoffsettoadc（i）; int val = readadc（）; if（val <0）offset  -  = offset / 2; elewset + = offset / 2;睡眠（10）; } while（val！= 0）; </ OL>  
<li> int offset = 256/2; </ Li>  
<li> do </ li>  
<li> {</ li>  
<li>编程OFFSETTOODC（i）; </ Li>  
<li> int val = readadc（）; </ Li>  
<li> if（val <0）</ li>  
<li> offset  -  =偏移/ 2; </ Li>  
<li> else </ li>  
<li> offset + = offset / 2; </ Li>  
<li>睡眠（10）; </ Li>  
<li>} while（val！= 0）; </ Li>  
在O（log n）上运行，这意味着最糟糕的5.5迭代的情况。因此，运行时从600毫秒到50-60毫秒，加速10倍。更重要的是，它使它足够快，以便不再产生人类错误。  
案例2：  
我有一个程序将导航到网站列表，将HTML保存到文件并拍摄网站的屏幕截图并将其保存为PNG。  
网站列表约为250,000，这个计划正在努力运行。意识到它是I / O绑定而不是计算束缚，对我来说，这是对并行化的尖叫。  
我更改了使用C＃的程序并行循环的程序，为连接数量提供合理的限制并让它运行。  
哇！！  
一个计划在一次运行一个时间下载网站的程序现在一次下载10,000个站点。它需要一些调整来找到最佳的连接数，我有一些数据结构的并发问题（通过使用并发词典等解决），但最终，它可以在30分钟内下载和屏幕截图250,000个网站。  
它比串行方法快10万倍，并将否则不可用的程序变为非常有价值的程序。  
### 回答 125
有几年前，我有一个SQL查询，它是由迄今为止的表ID的记录，其中包含大约10密端大组的记录。简单查询，但它需要> 30秒和超时。我已阅读有关数据库优化的一切，切换到更多RAM服务器，但没有任何帮助。我意识到生成SQL查询的代码是传递id而不是整数的字符串。MySQL Server正在尝试自动播放，这是超时的原因。将整数传递给SQL的SQL ran for milliSeconds。  
### 回答 126
回到20世纪80年代后期，我正在为一个地理信息系统公司工作，我们正在研究一份合同（分包给McDonnell Detwieller），以分析3个加拿大海岸的冰覆盖和冰川。我们所拥有的输入是一系列的线，我认为来自Lidar的一堆飞机，我们不得不打破他们越过的那条线（我们称之为包裹，而是大多数GIS公司称之为意大利面条）并将它们变成多边形。我们有一个测试数据集，用于概念证明，当我开始包裹时，它需要大约2.5小时。基本上，我采取了发现每个线段对每个其他线段的交叉点的代码，并且如果段范围没有重叠，则使其跳过比较。现在包裹花了10分钟，我是英雄。然后另一个开发人员（后来在MapQuest中变得非常高兴）来到了在内存段中的范围，而不是每次去数据库，现在它需要大约1分钟，现在他是英雄。  
### 回答 127
我对我的论文进行了统计分析，与root无法准确回忆）数据点（这是15年前，我在我的笔记本电脑上，所以数据量可用的计算能力相当可用）。  
对于那些没有丝毫想法的人这意味着什么：代码必须计算超过十亿分的参数函数的值，乘以结果，然后在不同的参数重复相同，一遍又一遍，又一次地找到一组参数最大化产品（从技术上讲，它最小化了减号F的总和，但无论如何）。  
现在，我没有对算法进行任何控制，以符合最合适的算法。我没有对函数正在计算的何时何地进行任何控制。完全由根完全照顾。我唯一不得不（并且可以）做的是写作，给定一组参数和一个数据点，吐出一个浮点数。  
继承人的问题：参数函数是一个概率分布函数，这意味着它必须是归一化的。这意味着分母在分母中存在一体化。使用的特定类型的功能没有分析积分：必须在数字上计算积分。需要时间，因为它需要大量计算本身（数千个，如果不是更多）。  
这意味着，对于参数上的每次迭代（通常为100-300），该函数是计算数十亿次（每个数据点的次数），并且对于这些时间，每个数据中的每个次数都有一个数值积分（数千个或更多计算） 😱  
花了很多年龄。  
虽然，使用具有分析可计算的功能的功能测试，但花费不到一分钟。  
.........  
在敲击我的脑海后，我意识到归一化积分只取决于参数，但不是数据点。这意味着，给定对参数的迭代，所计算的积分对于所有数据点完全相同。我的笔记本电脑正在浪费大量的计算，以遍历一遍又一遍地（数十亿次）与相同的参数相同。  
如果我可以计算所有数据点的函数形状，以及两种不同的步骤中的归一化积分，那将是完美的！不幸的是，它是纠正我的功能的根本工作。而我的功能必须返回已经归一化的值，否则最小化将无法正常工作。  
似乎我是f *** ed ...  
…或不？  
好吧，有一个解决方案。它需要做一个有状态的功能。我知道我知道。我现在的java开发人员自我知道它的缺乏风格。但幸运的是，我当时没有知道，利用它来解决这个问题。此外，它只是一个内部状态：吐出的结果并没有以任何方式依赖于之前发生的事情。内部状态允许计算拍摄快捷方式。它基本上是一个缓存。  
我在函数内添加了一个静态变量，存储查找表[参数元组]→[归一化]。每次使用某些参数和数据点调用我的函数时，它会检查查找表中是否存在参数的组元组：如果是，则只需使用预先计算的归一化值。只有当不存在这些参数时（每隔十亿个调用一次，每次测试新参数）时，它都会令人费意计算新的积分（并在退出之前将其值添加到表中）。  
我用简单的查找切换了一个长的计算（数值集成）。  
长话短说：全部最适合所有数据点现在需要30秒钟，而不是三天。  
不错。 😎  
原始问题：来自简单变化的代码中最戏剧性的加速是什么？  
### 回答 128
我在一个不同的群体中工作，但我有一些关于设计的投入  
这发生在30年前，所以我不记得很多细节，除了最重要的。我为Heath Insurance Company工作，我们在可能的数据库中有两个DB2表，或许在50或60个表的数据库中，持有关于服务代码数据的数据和速率覆盖，总是必须在SQL中加入。每个表有数百万行，但在IBM大型机上运行的内连接只需要大约10到12毫秒，以便在大约一秒内完成并将结果返回到在线CICS屏幕。这个原始的力量总是惊讶我。  
我在一个不同的群体中工作，但我在设计用于服务代码的原始数据库时有一些输入。有一天，那个小组的人来到了我的办公桌前来问我是否可以看出他们突然拥有的问题。在按下ENTER键后，在线程序运行几个小时而不是第二个。  
我做的第一件事是询问是否有任何最近发生了变化。他们告诉我不，什么都没有改变。在看几个明显的可能性之后，我决定查看DB2性能日志。在震惊时，我注意到一个特定的查询已经运行了近一小时。我再次询问这个内部连接查询是否已被修改，并再次告诉我。我在查询上做了一个解释，一切仍然看起来正确，但我碰巧注意到所有索引都被定义为升序。我奇怪地问了这是否是正确的，因为我依稀记得一些关于某个下降指数的东西。坐在他附近的立方体中的一个程序员听到了我的问题，几乎在恐怖中抬起头，并表示应该在速率覆盖表上有一个下降指数，但下降指数缺失。下降指数是绝对必需的，因为最近的覆盖是由最新生效日序下令的。  
我们从来没有真正了解到下行指数的失踪，但它必须由DBA集团的某人完成，可能来自程序员或可能没有的要求。它没有重要。下行指数重新创建，突然，该计划又回到了一秒钟。  
当您的数百万行加入另一个数十万行而没有适当的指数（或设计非常糟糕的查询），即使是IBM大型机的大规模计算能力也可能几乎完全销毁。  
### 回答 129
我工作了一段时间（现在已经过错了）搜索引擎公司，其中间件由疯狂的人（约有5000个Java源文件）撰写的。一些特点：  
这家公司有一个新的首席执行官，他们希望将这东西卖给其他行业，而不是美国政府的三个字母代理商，我被聘请用可靠的东西取代这东西。然而，他们在顾问中追溯到弗吉尼亚地下室的顾问上，当它损坏了自己的数据时，在弗吉尼亚州托幼儿，并用十六进制编辑来解决这些数据，这是每天几次。软件尴尬地破碎的是他们的现金牛。而且我了解到这并不罕见。  
所以我不知道为什么斯诺登可以访问他可以访问的东西，或者为什么obamacare网站的第一个版本是灾难，或者为什么希拉里可能不想使用承包商运行的邮件系统。这是政府的状态。  
编辑：由于有些人怀疑这个码比赛中的疯狂程度，我会从中留下这个小宝石，我最近在阅读一些旧电子邮件时找到。它有什么作用？它需要一个整数。并将其转换为字符串 - 即，请使用2并获得2.将字符串转换回整数 - 需要2并将其解析为2.并返回。换句话说，除了浪费CPU周期之外，此代码没有任何内容完成。什么都没有。它是从码比上的各种调用。  
<ol> public int fn_gs_as_int（int fi_p）{string fl_v = fn_gs_as_as_str（fi_p）;返回fn_str_to_int（fl_v）; } </ OL>  
<li> public int fn_gs_as_int（</ li>  
<li> int fi_p）</ li>  
<li> {</ li>  
<li>字符串fl_v = fn_gs_as_str（fi_p）; </ Li>  
<li>返回fn_str_to_int（fl_v）; </ Li>  
<li>} </ li>  
### 回答 130
我认为纯粹的危险简洁，很难击败叉子炸弹。  
叉炸弹  
一个自我复制的代码，只需几乎所有的编程语言都可以非常简单地写入，并且由于指数增加的性质，大部分机器将在任何时候磨损到停止。  
在这里，它是基本的C.所有程序都是在又一次地删除所有资源之前又一次地创建另一个程序 - 通常通过简单地填充操作系统的过程表。  
<ol> #include <unistd.h> int main（void）{whis（1）fork（）; } </ OL>  
<li> #include <unistd.h> </ li>  
<li> </ li>  
<li> int main（void）</ li>  
<li> {</ li>  
<li> while（1）fork（）; </ Li>  
<li>} </ li>  
如Wikipedia的例子所指出的，仔细地使用ulimits  
我认为纯粹的危险简洁，很难击败叉子炸弹。  
叉炸弹  
一个自我复制的代码，只需几乎所有的编程语言都可以非常简单地写入，并且由于指数增加的性质，大部分机器将在任何时候磨损到停止。  
在这里，它是基本的C.所有程序都是在又一次地删除所有资源之前又一次地创建另一个程序 - 通常通过简单地填充操作系统的过程表。  
<ol> #include <unistd.h> int main（void）{whis（1）fork（）; } </ OL>  
<li> #include <unistd.h> </ li>  
<li> </ li>  
<li> int main（void）</ li>  
<li> {</ li>  
<li> while（1）fork（）; </ Li>  
<li>} </ li>  
如Wikipedia的示例所指出的，仔细使用非root用户的ulimits * nix机器可以帮助防止这一点。  
编辑：  
哦，是的，在尝试运行这些示例之前保存所有工作......您可能会惊讶他们锁定您的速度。 （没有真的，我第一次尝试并令人遗憾的是，我没有打扰。）  
编辑2：  
正如用户所指出的那样回答有史以来最危险的代码是什么？当然有许多危险的定义，他将一个例子直接指出生命和肢体。  
大多数无意识别的危险代码的另一个例子是谦卑的Off-of-One错误，这可能是现代软件中安全漏洞的最常见原因之一。这就是程序员支付不充分关注他们所分配的内存程度的地方，或者不要正确地保护其限制，有人能够（意外或故意）注入字节，在他们不应该的地方，不可预测的错误导致或崩溃，或潜在的主机充分利用。  
### 回答 131
我主要是因为我看到很多答案都没有真正地解决过于解决的答案。我不是说所有人，但公平的数字不是真正的过度工程的纯粹例子。它们更好地描述为A）的例子是年轻和缺乏经验的或b）不了解问题或c）只是引入效率低下并且不起作用的坏代码。  
过度工程是过度思考问题的过程，产生过度卷积，然而，可能非常聪明，通常是非常通用的代码，其实在现实中最终难以使用，理解或维护。  
一个例子是工程师创造一个如此令人惊讶的系统的人，使得它可以用来在特定主题域中解决几乎任何问题，但是当实施时，当实施时是一个噩梦，因为它是如此疯狂地从问题中抽象出来。  
过度工程的最大迹象是当代码到目前为止抽象出来的问题，你几乎无法找到一块实际代码，一种方法，可变分配，一些具体实施的东西，等等。  
编辑：几个用户想要一个例子或回答，更好地说明概念并回答问题。同样，将代码放在这个论坛中对于大多数现实世界问题来说是禁止的，所以我将提供一些额外的插图和信息。  
过度工程卡通（伟大的比喻）：  
卡通的点，为什么它说明过于工程，是最终用户（桌子末尾的家伙）只是想要一些盐。这告诉我们什么？避免过度工程的最佳事物之一是不要设计到未来的太远，猜测您的客户可能会要求的内容。这可以是计算的风险，或者是一个良好的业务举措，如果您知道您拥有客户或业务需求将在那里，但您需要仔细考虑它。  
超过工程通常会在您提供超过要求的情况下发生的。我问你锤子，水平和螺丝刀。你去商店并用整个300pc力学工具集回来。这很好，但不必要（B / C在这种情况下我只是挂了一张图片）。有时你可能想要这样做，但你需要仔细考虑他们。  
它通常发生的另一种方式是通过过度抽象。上面的卡通是这个问题的一个完美的例子。它不仅在表格需要结束时提供的远远超过用户，另一个人正在创建一些通用，抽象的系统，以便无论谁要求某种东西，无论什么样的调味品，都可以处理。系统不再适用于盐，创建了一层抽象，然后他建立了系统，为该用户的盐来实现它。一个漫长的过程。在这种情况下不必要。您可以再次进一步逐步摘要，并说这不仅仅是一种传递调味品的系统，现在它将成为通过任何物品的系统。您可以进一步逐步说明它不仅仅是传递项目，它可以组合它们，添加它们，减去它们。另一个步骤更进一步，它不再只是物品，但现在它几乎是什么。  
抽象不差，这是一个精彩的概念，你只需要小心你在寻求方面有多远来实现完美的松散耦合和高凝聚力。  
### 回答 132
我曾经工作过的一些代码，这些代码最初是为旧的小型机编写的，这些代表已被移动到较新的Linux系统。MinioMomuer的网络接口最初有4位寄存器，其中一些内容是为了将64，32,16和8位值转换为这4位啃咬的奇怪的位鞭位例程 - 程序员必须是数学专业，因为他使用方程来做翻转而不是按比基操作 - 非常奇怪。  
### 回答 133
两个，一个由其他人完成的，我确实如此，我仍然非常高兴。  
1）GNU超优化器。 （由其他人完成）  
您将其提供了对指令集的描述，您可能想要执行的计算（例如，x * 17 >> y + 3），并且它发现了实现这一目标最有效的指令序列。  
当您需要在汇编程序中编写壮观的效率时，这通常会产生一个非常令人惊讶的指令序列。  
有趣的是，它只是蛮力;它试图每种指令序列，正在寻找解决方案。  
2）灯光循环  
两个，一个由其他人完成的，我确实如此，我仍然非常高兴。  
1）GNU超优化器。 （由其他人完成）  
您将其提供了对指令集的描述，您可能想要执行的计算（例如，x * 17 >> y + 3），并且它发现了实现这一目标最有效的指令序列。  
当您需要在汇编程序中编写壮观的效率时，这通常会产生一个非常令人惊讶的指令序列。  
有趣的是，它只是蛮力;它试图每种指令序列，正在寻找解决方案。  
2）我构建的OS调度程序中的灯光循环。  
作为背景，您需要知道1970年的小组均带来了花哨的前面板，其中有很多的白炽灯代表位，通常在内存总线上显示了当前地址，以及该存储器位置的数据。这主要用于支持单步说明（前面板上的开关）。在S / S模式下，灯明显打开和关闭。当机器运行不间断时，灯往往显示出涂片，因为它们试图跟上（仅）数百万总线地址和数据转换。所以运行机在灯中显示出涂片。从涂抹中，你可能会讲述它在做什么;不同的环路产生了不同的涂片。当然，如果电脑关闭，灯都没有点亮。  
因此，我为1970-1972大约一个新的Minicomuler提供了一个分时的操作系统。作为一个操作系统，它有一个调度程序;作为一个调度程序，有一个紧张的循环在没有什么可做的事情时等待。那个循环一般看起来像这样：  
中断例程将制造工作，循环将发现它，并且OFF调度程序将决定该做什么。  
计算机在这个循环中花了很多时间。它有一个特征涂片。机房里的人会抬头看电脑，看到这个涂片，并知道操作系统正在运行......无所事事。  
有一天，我决定利用Nova.first的一些有趣的属性，我将空闲循环改为：  
   check_for_work：cmp ... //任何工作要做？ jc do_work //是闲置：jmp空闲//挂起，等待工作  
这种涂片对于这种情况更为独特，因为计算机在空闲时计算机正在进行的不同事物的数量最小化。  
但是，调度程序如何摆脱此闲置循环？偷偷摸摸的技巧：一个中断例程，决定调度程序有一些工作，检查中断的过程是否在空闲状态下有其PC，如果是的话，将该过程设置为do_work。好的，轻微有趣。  
现在有趣的部分：我强迫空转内存位置是内存位置零。在Nova上，将JMP空闲指令放在位置为零，实际上是所有零！  
结果：当操作系统处于空闲状态时，所有前面板存储器地址和数据灯都会出去。机器看起来几乎就像它已经断电一样。非常令人震惊的展示，但它很有趣。如果系统有任何工作要做，那么在工作运行时，灯都会在各种涂片中重新出现，然后再次闲置，噗灯熄灭了。  
操作员第一次看到这一点，他们有一头牛;机器清晰地通电，并且不能好！在我解释过它之后，人们认为这很有趣。  
数据中心经理表示，可爱，但是......我们需要一些指示它可以在没有任何工作的情况下坐几分钟。  
调度程序的另一个补丁。我向时钟中断例程添加了一点代码，即，如果调度程序卡在空闲状态下，它会在前面板上切换携带位，一秒钟。  
现在当调度程序空闲时，所有的灯都会出去，但随身携带位会切换。所以每个人都很开心。  
当我解释的时候，当机器运行JMP到空闲时，总是有一点超越携带位切换。  
无论如何，我以为这真的很有趣。  
### 回答 134
ODE，开放式动态引擎  
首字母缩略词也是普通微分方程上的双关头。更多关于这一刻的信息。  
ode是用于模拟刚体（AKA梁）和约束（AKA关节）的任意结构的物理库。因此，您可以构建粘性数据并将其扔到一段楼梯上，如Dismount™系列游戏中。  
在2001  -  2002年，我花了一些时间下班，当没有滑雪板时，我写了一个编辑，用于联合/光束的控制并将它们设置为运动。我在写身体形态时刺伤了  
ODE，开放式动态引擎  
首字母缩略词也是普通微分方程上的双关头。更多关于这一刻的信息。  
ode是用于模拟刚体（AKA梁）和约束（AKA关节）的任意结构的物理库。因此，您可以构建粘性数据并将其扔到一段楼梯上，如Dismount™系列游戏中。  
在2001  -  2002年，我花了一些时间下班，当没有滑雪板时，我写了一个编辑，用于联合/光束的控制并将它们设置为运动。我在写作物理仿真代码时刺了一下，但很快就绝望了。数学很难。 3D模拟数学很难。但是，幸运的是，颂歌在那个时候释放了，所以我用它来为物理学，并花了所有的时间建立一个UI来构建世界，那么颂歌将模拟哪些颂歌。 （我的应用程序列在ODE网站上，直到我的网络服务器几年前崩溃。我真的需要备份它。）  
无论如何，颂歌基本上是一个疯狂的硬数学。您可以指定您的仿真 - 物体的仿真位置（矩形固体，球形等）和关节（滑块，铰链，物体之间的接触点）。然后，ode库构造了描述了在微小的时间之后，描述了世界上应该是什么样的方程式。然后它解决了常微分方程的系统（因此ode双关语）并告诉您一切都在何处经过多毫秒。当然，这是一堆优化，可以实时制造数学。  
它的宏伟的东西。而且它在我的脑海里，但API非常简单，所以我能够把GUI放在上面。然后我会惊叹于疯狂的数学数学，必须在小世界的渲染之间进行，即我正在模拟带有完全独立悬架的轮式车辆，2/4 / 6腿的蛇，带有20-50个身体段的蛇， 等等。  
这是作者博士项目，如果我记得正确。  
### 回答 135
A2A by Josh Knight [https://www.quora.com/profile/josh-knight-19]。我回答你有史以来被视为一名软件工程师的代码是什么？[https://www.quora.com/what-is-the-bost-mind-blowing-纲 -  ef-code-youve-ever-seen-as-a-software-engineer]  
我加入SAS Institute的1977年以来，我真的不是一名软件工程师。我被托尼巴尔聘用了预期我会贡献代码来实施我的一些想法来改善SAS，但销售，营销，......  
### 回答 136
抬头：他们从你写过的最美丽的代码中移动了这个问题？什么是有史以来最美丽的代码。我绝对不认为我甚至在自己的工作中接近了第二次措施。  
美丽是一个衡量的坚硬基准。  
在其实施中使用或美丽的美丽？如果它在实施中，如果整体设计很棒，您是否获得了对问题的组件的完美解决方案？  
为了轻松使用，它可能是我编写的数据库库，这是我公司的数十个项目中使用的。它与ORM有一些相似之处，但一些严重的哲学差异使其独特。  
如果它在实现中，它可能是一个字符串操作库，我写道，可以在CamelCase，Studlycase，Snake_case和Kabob-case之间进行转换，这也具有非常好的界面。  
如果它是为了解决一个优雅的真正难题的解决方案，我对此无法说太多，因为它尚未发布。这是一种与时尚有一些非常复杂的逻辑的算法。我喜欢认为我写的方式更容易理解它的脸上。它有一些笨重的零件，但它很好。  
### 回答 137
我曾经做过一个科学计算，其中我想在编程语言c屏幕上制作800x800像素的颜色绘图，但我没有像DirectX或OpenGL这样的图形界面。然后我想出了立即将绘图写入位图图像文件的想法，通过查找位图文件的标题和添加像素值（RGB颜色值）。所以我立刻在BMP文件中，我可以在照片查看器中查看它。  
#include <stdio.h>  
#include <stdlib.h>  
int main（int argc，char * argv []）  
{  
文件*外档;  
长我，j;  
无符号char rgb [3] [800] [800]，h  
我曾经做过一个科学计算，其中我想在编程语言c屏幕上制作800x800像素的颜色绘图，但我没有像DirectX或OpenGL这样的图形界面。然后我想出了立即将绘图写入位图图像文件的想法，通过查找位图文件的标题和添加像素值（RGB颜色值）。所以我立刻在BMP文件中，我可以在照片查看器中查看它。  
#include <stdio.h>  
#include <stdlib.h>  
int main（int argc，char * argv []）  
{  
文件*外档;  
长我，j;  
unsigned char rgb [3] [800] [800]，标题[54];  
for（i = 0; i <54; i ++）标题[i] = 0;  
标题[0] = 66;标题[1] = 77;标题[2] = 54;标题[3] = 76;  
标题[4] = 29;标题[10] = 54;标题[14] = 40;  
标题[18] = 32;标题[19] = 3; //图片宽度= 32 + 3 * 256 = 800像素  
标题[22] = 32;标题[23] = 3; //图片高度= 32 + 3 * 256 = 800像素  
标题[26] = 1;标题[28] = 24;标题[35] = 76;标题[36] = 29;  
Outfile = Fopen（BitMapplot1.BMP，WB）;  
for（i = 0; i <54; i ++）fputc（header [i]，outfile）; //写下图片标题= 24位位图  
......  
for（i = 0; i <800; i ++）（j = 0; j <800; j ++）  
{  
fputc（RGB [0] [i] [J]，Outfile）; fputc（RGB [1] [I] [J]，Outfile）; fputc（RGB [2] [I] [J]，Outfile）;  
fclose（外汇）;  
返回0;  
}  
