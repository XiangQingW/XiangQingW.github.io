<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？ 回答 1 在标准Perl 5的情况下，它只是解析字符串以将其转换为其内部字节码表示，并且
我很确定我通过使用eval（）在Perl中的运行时使用的函数使用的示例触发了这个问题。但是，eval对Perl不是唯一的。它于1958年回到了Lisp。
eval语句实际上处理在字符串或其他数据结构中保持的块的块，并执行它。它是一个用于将数据转换为代码的桥梁。
语言实现可以解释它，或者它可以在飞行中生成机器代码，或者两者的某种组合。
在标准Perl 5的情况下，它只解析了字符串以将其转换为内部字节码表示，并允许主解释器循环执行其内容。
FANCIER语言实现可以携带刚刚立即编译器，以便在运行时实际生成机器代码。
您还可以找到一个混合的语言实现，执行一些代码作为本机计算机代码，并解释其他代码。我在前一个链接讨论了一些混合动力。
回答 2 本机代码只是另一种类型的中间表示。程序员可以始终在软件中实际上实现一台机器，以将代码编译为自己或确实任何设计的中间表示。这些程序通常称为口译员或虚拟机。
没有原因无法编译本机代码，然后通过运行程序运行。常见的LISP编译器可以在运行时编译常见的LISP程序，即，从常见的LISP应用程序中运行，并在不停止主机应用程序的情况下运行它们。这个想法和山丘一样古老。
回答 3 这些天，如果语言没有编译为NATIV
一点都不。
原始基本实现根本没有编译程序。他们被解释并直接从源代码执行。今天，大量的语言仍然这样做，但它们往往是那些更专业的，在利基应用中使用。
读取源代码需要很长时间，解释它并执行它所说的。许多以后的基本解释器存储了以令授权的形式存储源代码。因此，而不是必须读取和识别每个打印的每个角色，只有一个字节识别。
如今，如果语言未编译到本机的机器语言，则它被编译成一个字节代码。您可以将一个字节代码视为作为不存在的计算机的机器代码。它涉及相同的低水平，但它旨在使该特定语言的运行程序。然后解释字节代码。就像在基本的旧时代一样，有一个名为解释器的程序，读取字节代码，识别它的意义并执行它指定的操作。
字节代码具有另一个大的优势。写一个字节代码解释器比写入全新编译器更容易。因此，如果使用字节代码，则更容易港口语言到新类型的计算机，而不是如果它们编译成本机代码。
很久以前，我的朋友正在尝试在BBC微型计算机上编写编译器。他发现6502个处理器可怕的编译。为了实现高级语言的常用功能，他必须重复代码，使其太大而无法适合内存，或者他必须继续编译过程调用常见例程，这使得它变得缓慢。因此，他实现了一个字节代码解释器，他尽可能多地优化。例如，他发现加载一个小常数非常常见，所以一半的操作码负载短常数，这是测试者测试的第一个OP-Code。因此，加载短常数实际上只有两种或三个本机指令。这样的东西：">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？" />
<meta property="og:description" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？ 回答 1 在标准Perl 5的情况下，它只是解析字符串以将其转换为其内部字节码表示，并且
我很确定我通过使用eval（）在Perl中的运行时使用的函数使用的示例触发了这个问题。但是，eval对Perl不是唯一的。它于1958年回到了Lisp。
eval语句实际上处理在字符串或其他数据结构中保持的块的块，并执行它。它是一个用于将数据转换为代码的桥梁。
语言实现可以解释它，或者它可以在飞行中生成机器代码，或者两者的某种组合。
在标准Perl 5的情况下，它只解析了字符串以将其转换为内部字节码表示，并允许主解释器循环执行其内容。
FANCIER语言实现可以携带刚刚立即编译器，以便在运行时实际生成机器代码。
您还可以找到一个混合的语言实现，执行一些代码作为本机计算机代码，并解释其他代码。我在前一个链接讨论了一些混合动力。
回答 2 本机代码只是另一种类型的中间表示。程序员可以始终在软件中实际上实现一台机器，以将代码编译为自己或确实任何设计的中间表示。这些程序通常称为口译员或虚拟机。
没有原因无法编译本机代码，然后通过运行程序运行。常见的LISP编译器可以在运行时编译常见的LISP程序，即，从常见的LISP应用程序中运行，并在不停止主机应用程序的情况下运行它们。这个想法和山丘一样古老。
回答 3 这些天，如果语言没有编译为NATIV
一点都不。
原始基本实现根本没有编译程序。他们被解释并直接从源代码执行。今天，大量的语言仍然这样做，但它们往往是那些更专业的，在利基应用中使用。
读取源代码需要很长时间，解释它并执行它所说的。许多以后的基本解释器存储了以令授权的形式存储源代码。因此，而不是必须读取和识别每个打印的每个角色，只有一个字节识别。
如今，如果语言未编译到本机的机器语言，则它被编译成一个字节代码。您可以将一个字节代码视为作为不存在的计算机的机器代码。它涉及相同的低水平，但它旨在使该特定语言的运行程序。然后解释字节代码。就像在基本的旧时代一样，有一个名为解释器的程序，读取字节代码，识别它的意义并执行它指定的操作。
字节代码具有另一个大的优势。写一个字节代码解释器比写入全新编译器更容易。因此，如果使用字节代码，则更容易港口语言到新类型的计算机，而不是如果它们编译成本机代码。
很久以前，我的朋友正在尝试在BBC微型计算机上编写编译器。他发现6502个处理器可怕的编译。为了实现高级语言的常用功能，他必须重复代码，使其太大而无法适合内存，或者他必须继续编译过程调用常见例程，这使得它变得缓慢。因此，他实现了一个字节代码解释器，他尽可能多地优化。例如，他发现加载一个小常数非常常见，所以一半的操作码负载短常数，这是测试者测试的第一个OP-Code。因此，加载短常数实际上只有两种或三个本机指令。这样的东西：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/what-does-it-mean-for-code-to-be-processed-at-runtime-doesnt-all-the-code-have-to-be-translated-into-machine-code-before-the-program-can-actually-run/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:15+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:15+08:00" />

<meta itemprop="name" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？">
<meta itemprop="description" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？ 回答 1 在标准Perl 5的情况下，它只是解析字符串以将其转换为其内部字节码表示，并且
我很确定我通过使用eval（）在Perl中的运行时使用的函数使用的示例触发了这个问题。但是，eval对Perl不是唯一的。它于1958年回到了Lisp。
eval语句实际上处理在字符串或其他数据结构中保持的块的块，并执行它。它是一个用于将数据转换为代码的桥梁。
语言实现可以解释它，或者它可以在飞行中生成机器代码，或者两者的某种组合。
在标准Perl 5的情况下，它只解析了字符串以将其转换为内部字节码表示，并允许主解释器循环执行其内容。
FANCIER语言实现可以携带刚刚立即编译器，以便在运行时实际生成机器代码。
您还可以找到一个混合的语言实现，执行一些代码作为本机计算机代码，并解释其他代码。我在前一个链接讨论了一些混合动力。
回答 2 本机代码只是另一种类型的中间表示。程序员可以始终在软件中实际上实现一台机器，以将代码编译为自己或确实任何设计的中间表示。这些程序通常称为口译员或虚拟机。
没有原因无法编译本机代码，然后通过运行程序运行。常见的LISP编译器可以在运行时编译常见的LISP程序，即，从常见的LISP应用程序中运行，并在不停止主机应用程序的情况下运行它们。这个想法和山丘一样古老。
回答 3 这些天，如果语言没有编译为NATIV
一点都不。
原始基本实现根本没有编译程序。他们被解释并直接从源代码执行。今天，大量的语言仍然这样做，但它们往往是那些更专业的，在利基应用中使用。
读取源代码需要很长时间，解释它并执行它所说的。许多以后的基本解释器存储了以令授权的形式存储源代码。因此，而不是必须读取和识别每个打印的每个角色，只有一个字节识别。
如今，如果语言未编译到本机的机器语言，则它被编译成一个字节代码。您可以将一个字节代码视为作为不存在的计算机的机器代码。它涉及相同的低水平，但它旨在使该特定语言的运行程序。然后解释字节代码。就像在基本的旧时代一样，有一个名为解释器的程序，读取字节代码，识别它的意义并执行它指定的操作。
字节代码具有另一个大的优势。写一个字节代码解释器比写入全新编译器更容易。因此，如果使用字节代码，则更容易港口语言到新类型的计算机，而不是如果它们编译成本机代码。
很久以前，我的朋友正在尝试在BBC微型计算机上编写编译器。他发现6502个处理器可怕的编译。为了实现高级语言的常用功能，他必须重复代码，使其太大而无法适合内存，或者他必须继续编译过程调用常见例程，这使得它变得缓慢。因此，他实现了一个字节代码解释器，他尽可能多地优化。例如，他发现加载一个小常数非常常见，所以一半的操作码负载短常数，这是测试者测试的第一个OP-Code。因此，加载短常数实际上只有两种或三个本机指令。这样的东西："><meta itemprop="datePublished" content="2022-01-23T22:08:15+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:15+08:00" />
<meta itemprop="wordCount" content="25">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？"/>
<meta name="twitter:description" content="在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？ 回答 1 在标准Perl 5的情况下，它只是解析字符串以将其转换为其内部字节码表示，并且
我很确定我通过使用eval（）在Perl中的运行时使用的函数使用的示例触发了这个问题。但是，eval对Perl不是唯一的。它于1958年回到了Lisp。
eval语句实际上处理在字符串或其他数据结构中保持的块的块，并执行它。它是一个用于将数据转换为代码的桥梁。
语言实现可以解释它，或者它可以在飞行中生成机器代码，或者两者的某种组合。
在标准Perl 5的情况下，它只解析了字符串以将其转换为内部字节码表示，并允许主解释器循环执行其内容。
FANCIER语言实现可以携带刚刚立即编译器，以便在运行时实际生成机器代码。
您还可以找到一个混合的语言实现，执行一些代码作为本机计算机代码，并解释其他代码。我在前一个链接讨论了一些混合动力。
回答 2 本机代码只是另一种类型的中间表示。程序员可以始终在软件中实际上实现一台机器，以将代码编译为自己或确实任何设计的中间表示。这些程序通常称为口译员或虚拟机。
没有原因无法编译本机代码，然后通过运行程序运行。常见的LISP编译器可以在运行时编译常见的LISP程序，即，从常见的LISP应用程序中运行，并在不停止主机应用程序的情况下运行它们。这个想法和山丘一样古老。
回答 3 这些天，如果语言没有编译为NATIV
一点都不。
原始基本实现根本没有编译程序。他们被解释并直接从源代码执行。今天，大量的语言仍然这样做，但它们往往是那些更专业的，在利基应用中使用。
读取源代码需要很长时间，解释它并执行它所说的。许多以后的基本解释器存储了以令授权的形式存储源代码。因此，而不是必须读取和识别每个打印的每个角色，只有一个字节识别。
如今，如果语言未编译到本机的机器语言，则它被编译成一个字节代码。您可以将一个字节代码视为作为不存在的计算机的机器代码。它涉及相同的低水平，但它旨在使该特定语言的运行程序。然后解释字节代码。就像在基本的旧时代一样，有一个名为解释器的程序，读取字节代码，识别它的意义并执行它指定的操作。
字节代码具有另一个大的优势。写一个字节代码解释器比写入全新编译器更容易。因此，如果使用字节代码，则更容易港口语言到新类型的计算机，而不是如果它们编译成本机代码。
很久以前，我的朋友正在尝试在BBC微型计算机上编写编译器。他发现6502个处理器可怕的编译。为了实现高级语言的常用功能，他必须重复代码，使其太大而无法适合内存，或者他必须继续编译过程调用常见例程，这使得它变得缓慢。因此，他实现了一个字节代码解释器，他尽可能多地优化。例如，他发现加载一个小常数非常常见，所以一半的操作码负载短常数，这是测试者测试的第一个OP-Code。因此，加载短常数实际上只有两种或三个本机指令。这样的东西："/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:15+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="在运行时处理代码是什么意思在程序实际运行之前必须将所有代码转换为机器代码">在运行时处理代码是什么意思？在程序实际运行之前，必须将所有代码转换为机器代码？</h2>
<h3 id="回答-1">回答 1</h3>
<p>在标准Perl 5的情况下，它只是解析字符串以将其转换为其内部字节码表示，并且<br>
我很确定我通过使用eval（）在Perl中的运行时使用的函数使用的示例触发了这个问题。但是，eval对Perl不是唯一的。它于1958年回到了Lisp。<br>
eval语句实际上处理在字符串或其他数据结构中保持的块的块，并执行它。它是一个用于将数据转换为代码的桥梁。<br>
语言实现可以解释它，或者它可以在飞行中生成机器代码，或者两者的某种组合。<br>
在标准Perl 5的情况下，它只解析了字符串以将其转换为内部字节码表示，并允许主解释器循环执行其内容。<br>
FANCIER语言实现可以携带刚刚立即编译器，以便在运行时实际生成机器代码。<br>
您还可以找到一个混合的语言实现，执行一些代码作为本机计算机代码，并解释其他代码。我在前一个链接讨论了一些混合动力。</p>
<h3 id="回答-2">回答 2</h3>
<p>本机代码只是另一种类型的中间表示。程序员可以始终在软件中实际上实现一台机器，以将代码编译为自己或确实任何设计的中间表示。这些程序通常称为口译员或虚拟机。<br>
没有原因无法编译本机代码，然后通过运行程序运行。常见的LISP编译器可以在运行时编译常见的LISP程序，即，从常见的LISP应用程序中运行，并在不停止主机应用程序的情况下运行它们。这个想法和山丘一样古老。</p>
<h3 id="回答-3">回答 3</h3>
<p>这些天，如果语言没有编译为NATIV<br>
一点都不。<br>
原始基本实现根本没有编译程序。他们被解释并直接从源代码执行。今天，大量的语言仍然这样做，但它们往往是那些更专业的，在利基应用中使用。<br>
读取源代码需要很长时间，解释它并执行它所说的。许多以后的基本解释器存储了以令授权的形式存储源代码。因此，而不是必须读取和识别每个打印的每个角色，只有一个字节识别。<br>
如今，如果语言未编译到本机的机器语言，则它被编译成一个字节代码。您可以将一个字节代码视为作为不存在的计算机的机器代码。它涉及相同的低水平，但它旨在使该特定语言的运行程序。然后解释字节代码。就像在基本的旧时代一样，有一个名为解释器的程序，读取字节代码，识别它的意义并执行它指定的操作。<br>
字节代码具有另一个大的优势。写一个字节代码解释器比写入全新编译器更容易。因此，如果使用字节代码，则更容易港口语言到新类型的计算机，而不是如果它们编译成本机代码。<br>
很久以前，我的朋友正在尝试在BBC微型计算机上编写编译器。他发现6502个处理器可怕的编译。为了实现高级语言的常用功能，他必须重复代码，使其太大而无法适合内存，或者他必须继续编译过程调用常见例程，这使得它变得缓慢。因此，他实现了一个字节代码解释器，他尽可能多地优化。例如，他发现加载一个小常数非常常见，所以一半的操作码负载短常数，这是测试者测试的第一个OP-Code。因此，加载短常数实际上只有两种或三个本机指令。这样的东西：</p>
<!-- raw HTML omitted -->
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
