<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？ 回答 1 输入新用户名时，它会在列表中间检查它。这个名字是
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
输入新用户名时，它会在列表中间检查它。那个名字就像是manwithamodem。它将用户名与此进行比较，并询问是相同的名称吗？如果是这样，拒绝。它可能是没有，所以那么它问这个新用户名在此用户名之前或之后按字母顺序排列吗？
如果之前，它就会知道所有400万&#43;在列表中的名称可能是一个匹配，所以它现在已经在单个比较中消除了400万&#43;可能性。如果它追求，那么它就知道所有400万&#43;在列表中的名字不能匹配。在任何一种情况下，我们只在一个比较之后排除了一半列表 - 以及我们排序清单！
接下来，我们采取我们没有消除的列表的剩余一半，查看该列表中间的用户名，并将其与我们的新用户名进行比较。再一次，如果它不是一个完美的匹配（即发现它已经在使用），我们可以判断匹配（如果存在）是否坐在排序列表中的那一点之前或之后。正如我们之前所做的那样，我们再次消除了整个剩余可能性的一半。
通过每次进行比较，通过将清单切成一半，我们可以快速浏览800万&#43;用户名的列表。太快了？
答案是您需要划分800万的次数，直到结果小于1？我们正试图将排序列表的段切成两半，直到事情足够小，以至于我们已经达到了两个彼此旁边的用户名，然后我们可以将新用户名与每个人进行比较，如果它匹配其中一个，那么用户名已经在使用中;如果没有，那么它是一个有效的新用户名。
好吧，这个问题的答案是23次。
就这样。由于我们将用户保存在一个排序的列表中，我们只需要做的23个比较，以验证新的提出的用户名是否存在。这很多，比800万比较快。
如果您想了解更多，您可以在此处阅读其他答案，该答案解释了该排序列表如何称为索引，并且这种类型的搜索和比较过程（或类似于它的类似物质）通常会在其中的数据库中提供用户名存储，加上其他细节。
回答 2 快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。
重复这一点，直到它找到用户名或两个用户名&hellip;
回答 3 任何现代平台都应该能够索引和缓存一个小varchar字段，以返回子秒内的简单存在评估。即使数亿用户也不会努力让这是努力的人只有800万。
回答 4 这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
&hellip;&hellip;
回答 5 为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？" />
<meta property="og:description" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？ 回答 1 输入新用户名时，它会在列表中间检查它。这个名字是
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
输入新用户名时，它会在列表中间检查它。那个名字就像是manwithamodem。它将用户名与此进行比较，并询问是相同的名称吗？如果是这样，拒绝。它可能是没有，所以那么它问这个新用户名在此用户名之前或之后按字母顺序排列吗？
如果之前，它就会知道所有400万&#43;在列表中的名称可能是一个匹配，所以它现在已经在单个比较中消除了400万&#43;可能性。如果它追求，那么它就知道所有400万&#43;在列表中的名字不能匹配。在任何一种情况下，我们只在一个比较之后排除了一半列表 - 以及我们排序清单！
接下来，我们采取我们没有消除的列表的剩余一半，查看该列表中间的用户名，并将其与我们的新用户名进行比较。再一次，如果它不是一个完美的匹配（即发现它已经在使用），我们可以判断匹配（如果存在）是否坐在排序列表中的那一点之前或之后。正如我们之前所做的那样，我们再次消除了整个剩余可能性的一半。
通过每次进行比较，通过将清单切成一半，我们可以快速浏览800万&#43;用户名的列表。太快了？
答案是您需要划分800万的次数，直到结果小于1？我们正试图将排序列表的段切成两半，直到事情足够小，以至于我们已经达到了两个彼此旁边的用户名，然后我们可以将新用户名与每个人进行比较，如果它匹配其中一个，那么用户名已经在使用中;如果没有，那么它是一个有效的新用户名。
好吧，这个问题的答案是23次。
就这样。由于我们将用户保存在一个排序的列表中，我们只需要做的23个比较，以验证新的提出的用户名是否存在。这很多，比800万比较快。
如果您想了解更多，您可以在此处阅读其他答案，该答案解释了该排序列表如何称为索引，并且这种类型的搜索和比较过程（或类似于它的类似物质）通常会在其中的数据库中提供用户名存储，加上其他细节。
回答 2 快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。
重复这一点，直到它找到用户名或两个用户名&hellip;
回答 3 任何现代平台都应该能够索引和缓存一个小varchar字段，以返回子秒内的简单存在评估。即使数亿用户也不会努力让这是努力的人只有800万。
回答 4 这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
&hellip;&hellip;
回答 5 为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/with-more-than-8-million-accounts-how-do-giant-sites-like-reddit-verify-so-quickly-that-a-username-isnt-taken/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:13+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:13+08:00" />

<meta itemprop="name" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？">
<meta itemprop="description" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？ 回答 1 输入新用户名时，它会在列表中间检查它。这个名字是
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
输入新用户名时，它会在列表中间检查它。那个名字就像是manwithamodem。它将用户名与此进行比较，并询问是相同的名称吗？如果是这样，拒绝。它可能是没有，所以那么它问这个新用户名在此用户名之前或之后按字母顺序排列吗？
如果之前，它就会知道所有400万&#43;在列表中的名称可能是一个匹配，所以它现在已经在单个比较中消除了400万&#43;可能性。如果它追求，那么它就知道所有400万&#43;在列表中的名字不能匹配。在任何一种情况下，我们只在一个比较之后排除了一半列表 - 以及我们排序清单！
接下来，我们采取我们没有消除的列表的剩余一半，查看该列表中间的用户名，并将其与我们的新用户名进行比较。再一次，如果它不是一个完美的匹配（即发现它已经在使用），我们可以判断匹配（如果存在）是否坐在排序列表中的那一点之前或之后。正如我们之前所做的那样，我们再次消除了整个剩余可能性的一半。
通过每次进行比较，通过将清单切成一半，我们可以快速浏览800万&#43;用户名的列表。太快了？
答案是您需要划分800万的次数，直到结果小于1？我们正试图将排序列表的段切成两半，直到事情足够小，以至于我们已经达到了两个彼此旁边的用户名，然后我们可以将新用户名与每个人进行比较，如果它匹配其中一个，那么用户名已经在使用中;如果没有，那么它是一个有效的新用户名。
好吧，这个问题的答案是23次。
就这样。由于我们将用户保存在一个排序的列表中，我们只需要做的23个比较，以验证新的提出的用户名是否存在。这很多，比800万比较快。
如果您想了解更多，您可以在此处阅读其他答案，该答案解释了该排序列表如何称为索引，并且这种类型的搜索和比较过程（或类似于它的类似物质）通常会在其中的数据库中提供用户名存储，加上其他细节。
回答 2 快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。
重复这一点，直到它找到用户名或两个用户名&hellip;
回答 3 任何现代平台都应该能够索引和缓存一个小varchar字段，以返回子秒内的简单存在评估。即使数亿用户也不会努力让这是努力的人只有800万。
回答 4 这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
&hellip;&hellip;
回答 5 为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。"><meta itemprop="datePublished" content="2022-01-23T22:08:13+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:13+08:00" />
<meta itemprop="wordCount" content="42">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？"/>
<meta name="twitter:description" content="凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？ 回答 1 输入新用户名时，它会在列表中间检查它。这个名字是
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
输入新用户名时，它会在列表中间检查它。那个名字就像是manwithamodem。它将用户名与此进行比较，并询问是相同的名称吗？如果是这样，拒绝。它可能是没有，所以那么它问这个新用户名在此用户名之前或之后按字母顺序排列吗？
如果之前，它就会知道所有400万&#43;在列表中的名称可能是一个匹配，所以它现在已经在单个比较中消除了400万&#43;可能性。如果它追求，那么它就知道所有400万&#43;在列表中的名字不能匹配。在任何一种情况下，我们只在一个比较之后排除了一半列表 - 以及我们排序清单！
接下来，我们采取我们没有消除的列表的剩余一半，查看该列表中间的用户名，并将其与我们的新用户名进行比较。再一次，如果它不是一个完美的匹配（即发现它已经在使用），我们可以判断匹配（如果存在）是否坐在排序列表中的那一点之前或之后。正如我们之前所做的那样，我们再次消除了整个剩余可能性的一半。
通过每次进行比较，通过将清单切成一半，我们可以快速浏览800万&#43;用户名的列表。太快了？
答案是您需要划分800万的次数，直到结果小于1？我们正试图将排序列表的段切成两半，直到事情足够小，以至于我们已经达到了两个彼此旁边的用户名，然后我们可以将新用户名与每个人进行比较，如果它匹配其中一个，那么用户名已经在使用中;如果没有，那么它是一个有效的新用户名。
好吧，这个问题的答案是23次。
就这样。由于我们将用户保存在一个排序的列表中，我们只需要做的23个比较，以验证新的提出的用户名是否存在。这很多，比800万比较快。
如果您想了解更多，您可以在此处阅读其他答案，该答案解释了该排序列表如何称为索引，并且这种类型的搜索和比较过程（或类似于它的类似物质）通常会在其中的数据库中提供用户名存储，加上其他细节。
回答 2 快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。
重复这一点，直到它找到用户名或两个用户名&hellip;
回答 3 任何现代平台都应该能够索引和缓存一个小varchar字段，以返回子秒内的简单存在评估。即使数亿用户也不会努力让这是努力的人只有800万。
回答 4 这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。
&hellip;&hellip;
回答 5 为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。"/>

      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-3W09QM57NF', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
	
  </head>

  <body class="ma0 avenir bg-near-white production">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:13+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="凭借超过800万个帐户如何快速验证像reddit这样的巨型网站是否已拍摄的用户名">凭借超过800万个帐户，如何快速验证像Reddit这样的巨型网站是否已拍摄的用户名？</h2>
<h3 id="回答-1">回答 1</h3>
<p>输入新用户名时，它会在列表中间检查它。这个名字是<br>
这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。<br>
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。<br>
输入新用户名时，它会在列表中间检查它。那个名字就像是manwithamodem。它将用户名与此进行比较，并询问是相同的名称吗？如果是这样，拒绝。它可能是没有，所以那么它问这个新用户名在此用户名之前或之后按字母顺序排列吗？<br>
如果之前，它就会知道所有400万+在列表中的名称可能是一个匹配，所以它现在已经在单个比较中消除了400万+可能性。如果它追求，那么它就知道所有400万+在列表中的名字不能匹配。在任何一种情况下，我们只在一个比较之后排除了一半列表 - 以及我们排序清单！<br>
接下来，我们采取我们没有消除的列表的剩余一半，查看该列表中间的用户名，并将其与我们的新用户名进行比较。再一次，如果它不是一个完美的匹配（即发现它已经在使用），我们可以判断匹配（如果存在）是否坐在排序列表中的那一点之前或之后。正如我们之前所做的那样，我们再次消除了整个剩余可能性的一半。<br>
通过每次进行比较，通过将清单切成一半，我们可以快速浏览800万+用户名的列表。太快了？<br>
答案是您需要划分800万的次数，直到结果小于1？我们正试图将排序列表的段切成两半，直到事情足够小，以至于我们已经达到了两个彼此旁边的用户名，然后我们可以将新用户名与每个人进行比较，如果它匹配其中一个，那么用户名已经在使用中;如果没有，那么它是一个有效的新用户名。<br>
好吧，这个问题的答案是23次。<br>
就这样。由于我们将用户保存在一个排序的列表中，我们只需要做的23个比较，以验证新的提出的用户名是否存在。这很多，比800万比较快。<br>
如果您想了解更多，您可以在此处阅读其他答案，该答案解释了该排序列表如何称为索引，并且这种类型的搜索和比较过程（或类似于它的类似物质）通常会在其中的数据库中提供用户名存储，加上其他细节。</p>
<h3 id="回答-2">回答 2</h3>
<p>快速搜索是可能的，因为数据库已创建用户名索引。该索引是用户名的排序列表。<br>
想一想这样的：首先，数据库将用户名与800万用户名中间的用户名进行比较。如果它大于用户名，那么它就重复了与过去一半的中间（400万的中间）的用户名的比较，或者上半年的比较。<br>
重复这一点，直到它找到用户名或两个用户名&hellip;</p>
<h3 id="回答-3">回答 3</h3>
<p>任何现代平台都应该能够索引和缓存一个小varchar字段，以返回子秒内的简单存在评估。即使数亿用户也不会努力让这是努力的人只有800万。</p>
<h3 id="回答-4">回答 4</h3>
<p>这里有很多好的答案。为了纪念Reddit，我将为后方提供高度简化的ELI5版本，而不引用编程或计算机科学概念。<br>
第一个关键诀窍是Reddit在排序，字母表中的列表中存储所有用户名。这意味着用户名列表看起来像A，AA，AAA，AAAB，&hellip; Xyzzyz，yishan，Zz，Zztop。它是一个大的用户名单，800万 - 一些长期。它在字母表中布置在字母表中，就像字典中的单词一样。<br>
&hellip;&hellip;</p>
<h3 id="回答-5">回答 5</h3>
<p>为了回应你的问题，我有好奇，并决定在现代硬件上测试这一点。<br>
我生成了一个带有800万行的文本文件，每行一个6-32个字符长字母数字字符串。这将表示我们的用户名。此文件大176 MB。<br>
现在，使用非常基本的Python代码，我决定搜索这个文件。我从列表结束时占用了一个用户名（但不是最后一个）。我正在2019年MacBook Pro上运行这件事。</p>
<!-- raw HTML omitted -->
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
