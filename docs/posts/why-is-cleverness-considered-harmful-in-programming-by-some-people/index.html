<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>为什么聪明的聪明被认为是有害的一些人的编程？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="为什么聪明的聪明被认为是有害的一些人的编程？ 回答 1 通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到超过7
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到每秒超过7,000多个连接。我切换回来，它返回到每秒39,000个连接下的前面的性能。
阅读评论很重要。
我的聪明赢得了我们的表现超过5.5倍。
因此，如果您认为聪明地被认为有害，请尝试在修改它之前学习在其他人代码中阅读评论，并尝试评论您自己的代码。
回答 2 它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要非常复杂和聪明的非常复杂的问题
它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要极其复杂的问题，需要极其复杂和聪明的解决方案，有时有需要更大的架构图片，需要前进。在那些时期之外，以最简单的方式遵循最佳做法通常是正确的答案。
一切都有例外（如果它是在使用情况下的第n个电源的情况下，有些1ns的改进可能值得疯狂复杂性），但通常，简单，可读，简单的代码将是大帮助。
维护。
一位曾经曾在她的研究中研究过软件开发生命周期的教授，一旦确定了80/20（或20/80）软件规则。在编写码的生命的20％，它的80％是维持的。
代码通常不会生活在真空中。有时我们完全有一个特定作业的孤立的代码，并且经过完全测试，并且永远不需要触及。但是，禁止越复杂，维护越难。
即使是那些碎片，如果触摸复杂的东西的代码被触摸，那么了解复杂性就会成为必要的，因为不引入更多的错误。如果可以使用简单和直截了当的东西，它可以节省大量的DEV，通常在其他地方花费更好。
回答 3 Kernighan的法律：
回答 4 调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。Brian Kernighan.
足以说，如果你像你写代码一样聪明一样聪明，你的代码可能太复杂了。始终争取简单性。
也就是说，优雅的简约很少出现在简单的思维中。你必须聪明地想出简单的代码，但你的代码不应该来交流&hellip;
代码&lt;/ span&gt;
回答 5 以下是两种优化定律：
代码是为一个大型项目编写的六个月，对小项目少得多。它可能会保持五年或十年。它是由一个人写的。它可能由三人或十个人维护，具体取决于公司。
计算机有大量的记忆力，节目花费99.9％的时间等待某事。几乎所有曾经写的代码没有任何空间或速度的限制。很少有需要小或快速的代码。即使他们这样做，也很罕见地知道我们何时编写它会影响程序所需的总空间或时间。
根据定义，聪明的代码很难理解，也很难理解，也很困境，要么在六个月的时间内才能理解。每次有人遇到那段代码时，他们将在未来十年内遇到困难。
具有巧妙代码的目标是在空间或速度下高效。如果程序所做的一千倍只等待用户单击鼠标，那么它很快就会快速毫无意义。如果它只会在带16GB的RAM上的计算机上保存几千字节，则毫无意义。
我花了很长时间编码了一个非常有限的项目，非常有限的空间有限。我没有访问任何普通库。我编写了一个多次泡沫，但我从未编码任何其他类型的排序。我从来没有必要;唯一一个我能负担得起的唯一案例都是我可能有十几个元素和充足的时间。泡沫排序更简单，有效。
有一个时间聪明，那就是你写了你的程序，它太大或太慢了。然后你经历它并找到所有低悬挂的水果。您发现通常足够调用的函数，以至于它们具有显着效果，或者找到占用大多数内存空间的数据结构。然后你优化那些。这为您提供最少量的努力，即未来十年。
当您编写代码时，巧妙的代码是坏代码;这是突然突然且难以维护。每一块聪明的代码都必须能够通过明确和有说服力的证据来证明其存在。
编辑：要回答几个异议评论，您不会在编写代码时忽略性能。您要记住，代码必须具有一定的性能。我已经在实时控制中度过了所有的生活，我从未有过严重的表现问题。如果您正在设计一个程序，并且存在多次搜索的数据结构，则您可以快速地进行代码。你没有把它放在数组中。要采取更荒谬的示例，您不会写入Python或JavaScript的应用程序。
但巧妙的代码不仅仅是快速，小的代码;它是快速的，小代码没有人乍一看。 （它可能是大的，慢的代码没有人理解，但那些显然是糟糕的。）你不需要聪明的代码，以便最优化，当然不是你第一次编写程序时可能包含的那种优化。使用AVL - 平衡树代替阵列不是巧妙的代码。使用c而不是python不是聪明的代码。">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="为什么聪明的聪明被认为是有害的一些人的编程？" />
<meta property="og:description" content="为什么聪明的聪明被认为是有害的一些人的编程？ 回答 1 通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到超过7
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到每秒超过7,000多个连接。我切换回来，它返回到每秒39,000个连接下的前面的性能。
阅读评论很重要。
我的聪明赢得了我们的表现超过5.5倍。
因此，如果您认为聪明地被认为有害，请尝试在修改它之前学习在其他人代码中阅读评论，并尝试评论您自己的代码。
回答 2 它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要非常复杂和聪明的非常复杂的问题
它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要极其复杂的问题，需要极其复杂和聪明的解决方案，有时有需要更大的架构图片，需要前进。在那些时期之外，以最简单的方式遵循最佳做法通常是正确的答案。
一切都有例外（如果它是在使用情况下的第n个电源的情况下，有些1ns的改进可能值得疯狂复杂性），但通常，简单，可读，简单的代码将是大帮助。
维护。
一位曾经曾在她的研究中研究过软件开发生命周期的教授，一旦确定了80/20（或20/80）软件规则。在编写码的生命的20％，它的80％是维持的。
代码通常不会生活在真空中。有时我们完全有一个特定作业的孤立的代码，并且经过完全测试，并且永远不需要触及。但是，禁止越复杂，维护越难。
即使是那些碎片，如果触摸复杂的东西的代码被触摸，那么了解复杂性就会成为必要的，因为不引入更多的错误。如果可以使用简单和直截了当的东西，它可以节省大量的DEV，通常在其他地方花费更好。
回答 3 Kernighan的法律：
回答 4 调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。Brian Kernighan.
足以说，如果你像你写代码一样聪明一样聪明，你的代码可能太复杂了。始终争取简单性。
也就是说，优雅的简约很少出现在简单的思维中。你必须聪明地想出简单的代码，但你的代码不应该来交流&hellip;
代码&lt;/ span&gt;
回答 5 以下是两种优化定律：
代码是为一个大型项目编写的六个月，对小项目少得多。它可能会保持五年或十年。它是由一个人写的。它可能由三人或十个人维护，具体取决于公司。
计算机有大量的记忆力，节目花费99.9％的时间等待某事。几乎所有曾经写的代码没有任何空间或速度的限制。很少有需要小或快速的代码。即使他们这样做，也很罕见地知道我们何时编写它会影响程序所需的总空间或时间。
根据定义，聪明的代码很难理解，也很难理解，也很困境，要么在六个月的时间内才能理解。每次有人遇到那段代码时，他们将在未来十年内遇到困难。
具有巧妙代码的目标是在空间或速度下高效。如果程序所做的一千倍只等待用户单击鼠标，那么它很快就会快速毫无意义。如果它只会在带16GB的RAM上的计算机上保存几千字节，则毫无意义。
我花了很长时间编码了一个非常有限的项目，非常有限的空间有限。我没有访问任何普通库。我编写了一个多次泡沫，但我从未编码任何其他类型的排序。我从来没有必要;唯一一个我能负担得起的唯一案例都是我可能有十几个元素和充足的时间。泡沫排序更简单，有效。
有一个时间聪明，那就是你写了你的程序，它太大或太慢了。然后你经历它并找到所有低悬挂的水果。您发现通常足够调用的函数，以至于它们具有显着效果，或者找到占用大多数内存空间的数据结构。然后你优化那些。这为您提供最少量的努力，即未来十年。
当您编写代码时，巧妙的代码是坏代码;这是突然突然且难以维护。每一块聪明的代码都必须能够通过明确和有说服力的证据来证明其存在。
编辑：要回答几个异议评论，您不会在编写代码时忽略性能。您要记住，代码必须具有一定的性能。我已经在实时控制中度过了所有的生活，我从未有过严重的表现问题。如果您正在设计一个程序，并且存在多次搜索的数据结构，则您可以快速地进行代码。你没有把它放在数组中。要采取更荒谬的示例，您不会写入Python或JavaScript的应用程序。
但巧妙的代码不仅仅是快速，小的代码;它是快速的，小代码没有人乍一看。 （它可能是大的，慢的代码没有人理解，但那些显然是糟糕的。）你不需要聪明的代码，以便最优化，当然不是你第一次编写程序时可能包含的那种优化。使用AVL - 平衡树代替阵列不是巧妙的代码。使用c而不是python不是聪明的代码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/why-is-cleverness-considered-harmful-in-programming-by-some-people/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:17+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:17+08:00" />

<meta itemprop="name" content="为什么聪明的聪明被认为是有害的一些人的编程？">
<meta itemprop="description" content="为什么聪明的聪明被认为是有害的一些人的编程？ 回答 1 通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到超过7
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到每秒超过7,000多个连接。我切换回来，它返回到每秒39,000个连接下的前面的性能。
阅读评论很重要。
我的聪明赢得了我们的表现超过5.5倍。
因此，如果您认为聪明地被认为有害，请尝试在修改它之前学习在其他人代码中阅读评论，并尝试评论您自己的代码。
回答 2 它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要非常复杂和聪明的非常复杂的问题
它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要极其复杂的问题，需要极其复杂和聪明的解决方案，有时有需要更大的架构图片，需要前进。在那些时期之外，以最简单的方式遵循最佳做法通常是正确的答案。
一切都有例外（如果它是在使用情况下的第n个电源的情况下，有些1ns的改进可能值得疯狂复杂性），但通常，简单，可读，简单的代码将是大帮助。
维护。
一位曾经曾在她的研究中研究过软件开发生命周期的教授，一旦确定了80/20（或20/80）软件规则。在编写码的生命的20％，它的80％是维持的。
代码通常不会生活在真空中。有时我们完全有一个特定作业的孤立的代码，并且经过完全测试，并且永远不需要触及。但是，禁止越复杂，维护越难。
即使是那些碎片，如果触摸复杂的东西的代码被触摸，那么了解复杂性就会成为必要的，因为不引入更多的错误。如果可以使用简单和直截了当的东西，它可以节省大量的DEV，通常在其他地方花费更好。
回答 3 Kernighan的法律：
回答 4 调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。Brian Kernighan.
足以说，如果你像你写代码一样聪明一样聪明，你的代码可能太复杂了。始终争取简单性。
也就是说，优雅的简约很少出现在简单的思维中。你必须聪明地想出简单的代码，但你的代码不应该来交流&hellip;
代码&lt;/ span&gt;
回答 5 以下是两种优化定律：
代码是为一个大型项目编写的六个月，对小项目少得多。它可能会保持五年或十年。它是由一个人写的。它可能由三人或十个人维护，具体取决于公司。
计算机有大量的记忆力，节目花费99.9％的时间等待某事。几乎所有曾经写的代码没有任何空间或速度的限制。很少有需要小或快速的代码。即使他们这样做，也很罕见地知道我们何时编写它会影响程序所需的总空间或时间。
根据定义，聪明的代码很难理解，也很难理解，也很困境，要么在六个月的时间内才能理解。每次有人遇到那段代码时，他们将在未来十年内遇到困难。
具有巧妙代码的目标是在空间或速度下高效。如果程序所做的一千倍只等待用户单击鼠标，那么它很快就会快速毫无意义。如果它只会在带16GB的RAM上的计算机上保存几千字节，则毫无意义。
我花了很长时间编码了一个非常有限的项目，非常有限的空间有限。我没有访问任何普通库。我编写了一个多次泡沫，但我从未编码任何其他类型的排序。我从来没有必要;唯一一个我能负担得起的唯一案例都是我可能有十几个元素和充足的时间。泡沫排序更简单，有效。
有一个时间聪明，那就是你写了你的程序，它太大或太慢了。然后你经历它并找到所有低悬挂的水果。您发现通常足够调用的函数，以至于它们具有显着效果，或者找到占用大多数内存空间的数据结构。然后你优化那些。这为您提供最少量的努力，即未来十年。
当您编写代码时，巧妙的代码是坏代码;这是突然突然且难以维护。每一块聪明的代码都必须能够通过明确和有说服力的证据来证明其存在。
编辑：要回答几个异议评论，您不会在编写代码时忽略性能。您要记住，代码必须具有一定的性能。我已经在实时控制中度过了所有的生活，我从未有过严重的表现问题。如果您正在设计一个程序，并且存在多次搜索的数据结构，则您可以快速地进行代码。你没有把它放在数组中。要采取更荒谬的示例，您不会写入Python或JavaScript的应用程序。
但巧妙的代码不仅仅是快速，小的代码;它是快速的，小代码没有人乍一看。 （它可能是大的，慢的代码没有人理解，但那些显然是糟糕的。）你不需要聪明的代码，以便最优化，当然不是你第一次编写程序时可能包含的那种优化。使用AVL - 平衡树代替阵列不是巧妙的代码。使用c而不是python不是聪明的代码。"><meta itemprop="datePublished" content="2022-01-23T22:08:17+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:17+08:00" />
<meta itemprop="wordCount" content="603">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="为什么聪明的聪明被认为是有害的一些人的编程？"/>
<meta name="twitter:description" content="为什么聪明的聪明被认为是有害的一些人的编程？ 回答 1 通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到超过7
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。
当你做一些聪明的事情时，你会评论它，以及为什么这样做。
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。
我们写的负载平衡器软件下降到每秒超过7,000多个连接。我切换回来，它返回到每秒39,000个连接下的前面的性能。
阅读评论很重要。
我的聪明赢得了我们的表现超过5.5倍。
因此，如果您认为聪明地被认为有害，请尝试在修改它之前学习在其他人代码中阅读评论，并尝试评论您自己的代码。
回答 2 它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要非常复杂和聪明的非常复杂的问题
它不是普遍的有害，但有时是有害的。
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。
第一年：
第二年：
第三年：
第五年：
第十年：
再次，信用肖恩。
可读性非常重要。
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。
有时，需要极其复杂的问题，需要极其复杂和聪明的解决方案，有时有需要更大的架构图片，需要前进。在那些时期之外，以最简单的方式遵循最佳做法通常是正确的答案。
一切都有例外（如果它是在使用情况下的第n个电源的情况下，有些1ns的改进可能值得疯狂复杂性），但通常，简单，可读，简单的代码将是大帮助。
维护。
一位曾经曾在她的研究中研究过软件开发生命周期的教授，一旦确定了80/20（或20/80）软件规则。在编写码的生命的20％，它的80％是维持的。
代码通常不会生活在真空中。有时我们完全有一个特定作业的孤立的代码，并且经过完全测试，并且永远不需要触及。但是，禁止越复杂，维护越难。
即使是那些碎片，如果触摸复杂的东西的代码被触摸，那么了解复杂性就会成为必要的，因为不引入更多的错误。如果可以使用简单和直截了当的东西，它可以节省大量的DEV，通常在其他地方花费更好。
回答 3 Kernighan的法律：
回答 4 调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。Brian Kernighan.
足以说，如果你像你写代码一样聪明一样聪明，你的代码可能太复杂了。始终争取简单性。
也就是说，优雅的简约很少出现在简单的思维中。你必须聪明地想出简单的代码，但你的代码不应该来交流&hellip;
代码&lt;/ span&gt;
回答 5 以下是两种优化定律：
代码是为一个大型项目编写的六个月，对小项目少得多。它可能会保持五年或十年。它是由一个人写的。它可能由三人或十个人维护，具体取决于公司。
计算机有大量的记忆力，节目花费99.9％的时间等待某事。几乎所有曾经写的代码没有任何空间或速度的限制。很少有需要小或快速的代码。即使他们这样做，也很罕见地知道我们何时编写它会影响程序所需的总空间或时间。
根据定义，聪明的代码很难理解，也很难理解，也很困境，要么在六个月的时间内才能理解。每次有人遇到那段代码时，他们将在未来十年内遇到困难。
具有巧妙代码的目标是在空间或速度下高效。如果程序所做的一千倍只等待用户单击鼠标，那么它很快就会快速毫无意义。如果它只会在带16GB的RAM上的计算机上保存几千字节，则毫无意义。
我花了很长时间编码了一个非常有限的项目，非常有限的空间有限。我没有访问任何普通库。我编写了一个多次泡沫，但我从未编码任何其他类型的排序。我从来没有必要;唯一一个我能负担得起的唯一案例都是我可能有十几个元素和充足的时间。泡沫排序更简单，有效。
有一个时间聪明，那就是你写了你的程序，它太大或太慢了。然后你经历它并找到所有低悬挂的水果。您发现通常足够调用的函数，以至于它们具有显着效果，或者找到占用大多数内存空间的数据结构。然后你优化那些。这为您提供最少量的努力，即未来十年。
当您编写代码时，巧妙的代码是坏代码;这是突然突然且难以维护。每一块聪明的代码都必须能够通过明确和有说服力的证据来证明其存在。
编辑：要回答几个异议评论，您不会在编写代码时忽略性能。您要记住，代码必须具有一定的性能。我已经在实时控制中度过了所有的生活，我从未有过严重的表现问题。如果您正在设计一个程序，并且存在多次搜索的数据结构，则您可以快速地进行代码。你没有把它放在数组中。要采取更荒谬的示例，您不会写入Python或JavaScript的应用程序。
但巧妙的代码不仅仅是快速，小的代码;它是快速的，小代码没有人乍一看。 （它可能是大的，慢的代码没有人理解，但那些显然是糟糕的。）你不需要聪明的代码，以便最优化，当然不是你第一次编写程序时可能包含的那种优化。使用AVL - 平衡树代替阵列不是巧妙的代码。使用c而不是python不是聪明的代码。"/>

      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-3W09QM57NF', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
	
  </head>

  <body class="ma0 avenir bg-near-white production">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">为什么聪明的聪明被认为是有害的一些人的编程？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:17+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="为什么聪明的聪明被认为是有害的一些人的编程">为什么聪明的聪明被认为是有害的一些人的编程？</h2>
<h3 id="回答-1">回答 1</h3>
<p>通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。<br>
当你做一些聪明的事情时，你会评论它，以及为什么这样做。<br>
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。<br>
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。<br>
我们写的负载平衡器软件下降到超过7<br>
通常，此投诉是由不评论其代码的人员制作，和/或不读取代码中的评论。<br>
当你做一些聪明的事情时，你会评论它，以及为什么这样做。<br>
例如，我做了聪明的事情，我评论了。我做了Lifo而不是FIFO队列排序，使下一个订单计划作为发动机的工作，所有页面都交换了。<br>
没有读取评论的人想要加载平衡发动机，并将其切换到FIFO，而不读取为什么它是Lifo的评论。<br>
我们写的负载平衡器软件下降到每秒超过7,000多个连接。我切换回来，它返回到每秒39,000个连接下的前面的性能。<br>
阅读评论很重要。<br>
我的聪明赢得了我们的表现超过5.5倍。<br>
因此，如果您认为聪明地被认为有害，请尝试在修改它之前学习在其他人代码中阅读评论，并尝试评论您自己的代码。</p>
<h3 id="回答-2">回答 2</h3>
<p>它不是普遍的有害，但有时是有害的。<br>
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。<br>
第一年：<br>
第二年：<br>
第三年：<br>
第五年：<br>
第十年：<br>
再次，信用肖恩。<br>
可读性非常重要。<br>
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。<br>
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。<br>
有时，需要非常复杂和聪明的非常复杂的问题<br>
它不是普遍的有害，但有时是有害的。<br>
我最喜欢的一个例子是由肖恩Hickey在这里创造的一个小笑话。<br>
第一年：<br>
第二年：<br>
第三年：<br>
第五年：<br>
第十年：<br>
再次，信用肖恩。<br>
可读性非常重要。<br>
这是保持简单的一个大益处，为什么可以看到聪明/可爱的东西可以被视为如此有害。<br>
这里有几个原则。首先，YAGNI，一个XP概念，字面上代表你不需要它，而且还要亲吻，保持简单，愚蠢。<br>
有时，需要极其复杂的问题，需要极其复杂和聪明的解决方案，有时有需要更大的架构图片，需要前进。在那些时期之外，以最简单的方式遵循最佳做法通常是正确的答案。<br>
一切都有例外（如果它是在使用情况下的第n个电源的情况下，有些1ns的改进可能值得疯狂复杂性），但通常，简单，可读，简单的代码将是大帮助。<br>
维护。<br>
一位曾经曾在她的研究中研究过软件开发生命周期的教授，一旦确定了80/20（或20/80）软件规则。在编写码的生命的20％，它的80％是维持的。<br>
代码通常不会生活在真空中。有时我们完全有一个特定作业的孤立的代码，并且经过完全测试，并且永远不需要触及。但是，禁止越复杂，维护越难。<br>
即使是那些碎片，如果触摸复杂的东西的代码被触摸，那么了解复杂性就会成为必要的，因为不引入更多的错误。如果可以使用简单和直截了当的东西，它可以节省大量的DEV，通常在其他地方花费更好。</p>
<h3 id="回答-3">回答 3</h3>
<p>Kernighan的法律：</p>
<h3 id="回答-4">回答 4</h3>
<p>调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。Brian Kernighan.<br>
足以说，如果你像你写代码一样聪明一样聪明，你的代码可能太复杂了。始终争取简单性。<br>
也就是说，优雅的简约很少出现在简单的思维中。你必须聪明地想出简单的代码，但你的代码不应该来交流&hellip;<br>
<!-- raw HTML omitted -->代码&lt;/ span&gt;</p>
<h3 id="回答-5">回答 5</h3>
<p>以下是两种优化定律：<br>
代码是为一个大型项目编写的六个月，对小项目少得多。它可能会保持五年或十年。它是由一个人写的。它可能由三人或十个人维护，具体取决于公司。<br>
计算机有大量的记忆力，节目花费99.9％的时间等待某事。几乎所有曾经写的代码没有任何空间或速度的限制。很少有需要小或快速的代码。即使他们这样做，也很罕见地知道我们何时编写它会影响程序所需的总空间或时间。<br>
根据定义，聪明的代码很难理解，也很难理解，也很困境，要么在六个月的时间内才能理解。每次有人遇到那段代码时，他们将在未来十年内遇到困难。<br>
具有巧妙代码的目标是在空间或速度下高效。如果程序所做的一千倍只等待用户单击鼠标，那么它很快就会快速毫无意义。如果它只会在带16GB的RAM上的计算机上保存几千字节，则毫无意义。<br>
我花了很长时间编码了一个非常有限的项目，非常有限的空间有限。我没有访问任何普通库。我编写了一个多次泡沫，但我从未编码任何其他类型的排序。我从来没有必要;唯一一个我能负担得起的唯一案例都是我可能有十几个元素和充足的时间。泡沫排序更简单，有效。<br>
有一个时间聪明，那就是你写了你的程序，它太大或太慢了。然后你经历它并找到所有低悬挂的水果。您发现通常足够调用的函数，以至于它们具有显着效果，或者找到占用大多数内存空间的数据结构。然后你优化那些。这为您提供最少量的努力，即未来十年。<br>
当您编写代码时，巧妙的代码是坏代码;这是突然突然且难以维护。每一块聪明的代码都必须能够通过明确和有说服力的证据来证明其存在。<br>
编辑：要回答几个异议评论，您不会在编写代码时忽略性能。您要记住，代码必须具有一定的性能。我已经在实时控制中度过了所有的生活，我从未有过严重的表现问题。如果您正在设计一个程序，并且存在多次搜索的数据结构，则您可以快速地进行代码。你没有把它放在数组中。要采取更荒谬的示例，您不会写入Python或JavaScript的应用程序。<br>
但巧妙的代码不仅仅是快速，小的代码;它是快速的，小代码没有人乍一看。 （它可能是大的，慢的代码没有人理解，但那些显然是糟糕的。）你不需要聪明的代码，以便最优化，当然不是你第一次编写程序时可能包含的那种优化。使用AVL  - 平衡树代替阵列不是巧妙的代码。使用c而不是python不是聪明的代码。<br>
当必须优化清除算法时，巧妙代码是合适的，并且没有明确的方法来做。然后，只有，只有，您可以选择使用不明确的算法。<br>
对于应用程序的功能完成，并且编程团队被撤销，为什么没有表现为要求规范？性能是一个特征;慢程未完成速度。</p>
<h3 id="回答-6">回答 6</h3>
<p>代码维持比写入更长的时间。其他程序员来了，他们可能不会像你一样聪明或聪明。重要的是他们理解代码，并且不会因其聪明而感到困惑。<br>
我已经足够长了，可以在z-80汇编代码中记住特定的技巧。一个非常常见的操作是加载寄存器，例如带0.汇编器操作码为：ld a，0<br>
但这需要2个字节的内存，并要求CPU从程序空间加载值0并将其移动到寄存器中。事实证明，您还可以执行本身的独占或操作，这也导致0：<br>
xor a，a<br>
这只需要1个字节，略微更快。现在，汇编程序员熟悉这个诀窍并知道它是什么。但是几年后，我偶然发现了这个C代码：<br>
计数器^ =计数器;<br>
^是C中的独占或运营商。所以这在C中基本上是相同的操作，加载值计数器0.程序员我正在使用那条线并询问我是否知道它是想做什么。我解释并编辑了符号= 0;<br>
我已经看到了许多情况，其中操作被分解为更小而更加简洁的代码，那里程序员必须真正思考，这确实是代码正在尝试的，然后检查它。如果原来的程序员必须思考它，那么下一个人就无法理解它。<br>
否则代码的清晰度比巧妙更重要，除非它是突然聪明的。</p>
<h3 id="回答-7">回答 7</h3>
<p>有时是必要的聪明，而且聪明的人更简单的聪明才智是天才的标志。每个人都记得e =mc²，即使我们几乎没有人（包括我）实际上没有理解它。 Tarjan的Union-Find算法是一个简单的东西的另一个例子，它有效地令人惊讶地做出了令人惊讶的事情，并且效率的推理是艰难的，但模式很简单。<br>
然而，很多聪明都不是那种形式。它没有简化的东西。它不会让他们容易地遵循其他人。并且，除非您纯粹为自己编码，否则其他人最终将维持您的代码。而且，如果您的聪明才难以理解（它几乎总是这样），有些人试图改变代码的人不会理解聪明，从而打破它。<br>
因此，巧妙的代码是脆弱的代码。你不想写脆弱的代码。有人会打破它。</p>
<h3 id="回答-8">回答 8</h3>
<p>对于这个问题，这个报价是完美的答案。<br>
调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。</p>
<ul>
<li>汉语W. Kernighan.<br>
编程并不总是关于您熟悉任何特定语言的数量。它是计算机和其他人可以理解的方式。<br>
假设您有一段代码可以做一些以非常复杂的方式编写的一些更改，那么您将如何感受？ wtf !!!弄清楚实际代码需要很长时间<br>
对于这个问题，这个报价是完美的答案。<br>
调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。</li>
<li>汉语W. Kernighan.<br>
编程并不总是关于您熟悉任何特定语言的数量。它是计算机和其他人可以理解的方式。<br>
假设您有一段代码可以做一些以非常复杂的方式编写的一些更改，那么您将如何感受？ wtf !!!弄清楚实际代码以及如何实施的事情需要很长时间。<br>
但是，同样地，如果您已经给出了简单而简洁的代码来编辑，那么您可以轻松理解所有关于的代码以及相应的更改。<br>
简单的解决方案对于长期维护更好。聪明的解决方案很棒，但通常最简单的直接解决方案是最好的。</li>
</ul>
<h3 id="回答-9">回答 9</h3>
<p>问：聪明的聪明被认为是有害的吗？<br>
答：聪明本身并不有害。<br>
但在源代码中揭示聪明而不是清晰度是编程的最高罪。</p>
<h3 id="回答-10">回答 10</h3>
<p>因为复杂和精彩不是最好在凌晨4点调试的最好的事情，之后是1小时的车程，在3:00接到电话后，修复崩溃的东西，现在需要修复。<br>
调试代码的人可能不会像写代码的那样聪明而聪明，即使是你。</p>
<h3 id="回答-11">回答 11</h3>
<p>编写代码时，人们应该努力生产最简单，最清晰，易于阅读符合所有要求的代码。<br>
如果您正在编写一个控制系统来定位ISS，那可能是非常诅咒的复杂性。如果您正在编写简单的CRUD休息服务，那应该非常简单而干净。<br>
人们在工程上与聪明 - 过度惩罚，周末随叫随到。<br>
我认为这更聪明地写下ISS控制系统，即新的CS GRAC可以维持它。</p>
<h3 id="回答-12">回答 12</h3>
<p>调试是首先编写代码的两倍。因此，如果您尽可能巧妙地编写代码，则根据定义，您是不智能的，足以调试它。<br>
-Kernighan的法律<br>
聪明并不总是一件坏事，但必须适度地完成。当您正在编写巧妙的代码时，您是根据您的能力的限制工作的定义，并且在您需要时会进一步延伸自己。通常情况下，巧妙的解决方案几乎是脆弱的行为变化，这可能只是直接代码中的语句可以额外的如果可以解开制造巧妙代码的关键假设之一，使得包含必要的行为更难改变。<br>
但适度不是永远不会。以下是一些指导方针：</p>
<h3 id="回答-13">回答 13</h3>
<p>聪明还可以。只要您可以清楚和可靠地记录它，就会找到一些聪明的聪明才智没有错。<br>
将多个项目缩小到一个命令中，这将需要一个非常专业的理解，以便能够解析或修复它，如果有任何错误，并且更糟糕的是没有提供其工作原因的任何文档，是最高的类别。<br>
代码需要清晰度 - 除非您希望成为该程序的使用寿命的任何内容的任何内容。<br>
胆量法 - 一个复杂的系统总是发现从工作的简单系统中发展。反向命题也似乎是真的：从头开始设计的复杂系统永远不会工作，无法工作。您必须重新开始，从工作简单系统开始。<br>
证实。验证，验证，验证。<br>
设计。制定计划，按照计划进行操作，只能确保完全调整。不要破解代码，除非您可以记录为什么需要以不寻常的方式执行某些事情。未能正确设计和文档代码具有导致未纵向产品的趋势。</p>
<h3 id="回答-14">回答 14</h3>
<p>它不是。有些人认为他们比他们更聪明，这是非常有害的。<br>
这些日子将善良与善良相同的人的数量是非常象征的问题。<br>
有很少的情况，要求您以一种方式编写代码，以便编程的人无法弄清楚很快，如果您编写代码，就像它一样，它不可思议的动机或无能。<br>
任何聪明的傻瓜都可以让事情变得更大，更复杂，更暴力。它需要一丝天才 - 朝着相反的方向移动很多勇气。〜例如舒马赫</p>
<h3 id="回答-15">回答 15</h3>
<p>这很容易。<br>
每个团队都有不同认知能力的人。反过来，你可能会发现认知能力较低的人是你。<br>
有一天，你可能会在半夜被称为，因为一些聪明的代码被打破了。也许依赖变化。也许添加了一个功能。你不知道。你现在正在看一些聪明的代码。你不知道它应该做什么，因为在改变的事情之前，它巧妙地正确地做了这件事。<br>
现在你必须弄清楚它巧妙地做了什么，你必须巧妙地使它在新环境中工作，假设改变了没有搞砸了聪明所基于的整个假设。<br>
向FDA的报告不会通过截止日期到达那里，或者工资单不会出去。<br>
我希望你感到聪明。</p>
<h3 id="回答-16">回答 16</h3>
<p>聪明的代码不是好的代码，如果有人必须拼图在一段代码上，因为它使用一些模糊的技巧来保存指令或两个，它不具有成本效益。<br>
现在，已经说过，很好的做法是使用适当的作业算法，如果您的团队中的一些不熟悉，这可能被视为聪明。我会说这是一个很好的代码，因为它以一种经典方式解决了问题，这往往可以通过可能或可能不具有稳健或可靠的临时方法可靠。</p>
<h3 id="回答-17">回答 17</h3>
<p>随着系统的复杂，你必须聪明。这不是我们指的聪明。<br>
这里的聪明才智是旨在复杂的代码，以证明他们有多聪明。这是一小竞争对手的自我吸收的智力主义。它不成熟。<br>
但如果你认为反智力主义是答案，你就像愚蠢一样。<br>
答案是将复杂性视为问题，并作为问题。复杂性很好地是编程，在界面，可用性方面的主要关注点，甚至在生活中。<br>
如果你是一个聪明的人，试图向世界证明你是多么聪明，你是德比特拉特<br>
随着系统的复杂，你必须聪明。这不是我们指的聪明。<br>
这里的聪明才智是旨在复杂的代码，以证明他们有多聪明。这是一小竞争对手的自我吸收的智力主义。它不成熟。<br>
但如果你认为反智力主义是答案，你就像愚蠢一样。<br>
答案是将复杂性视为问题，并作为问题。复杂性很好地是编程，在界面，可用性方面的主要关注点，甚至在生活中。<br>
如果您是一个Smartie，试图向世界证明您是多么聪明，您就是故意编写复杂的代码，使您的同事遭受遭受，软件难以理解。您的虚荣代码与您的自我乱丢，并随着您声称它是一个功能。它可能不是一个错误，但它是虫子的，而且你是错误的。这是有害的。<br>
相反，是聪明的。使复杂性消失。但简单性不仅适合你，特别是如果你没有难以理解你的梦幻般的混乱。<br>
简单是别人。这意味着简单，需要同理心。这就是你加倍努力的原因。这就是为什么最终结果是神奇的。<br>
你看到了这项工作，你看它是为你完成的。<br>
这让你微笑。<br>
但是，不需要从这个随机Quora答案中接受它。这个讲道的人并使他的生命工作创造了历史上最有价值的公司。</p>
<h3 id="回答-18">回答 18</h3>
<p>它不是 - 程序员必须聪明，以便完成工作。<br>
但正如其他人所说，有太聪明，有时程序员太聪明，那么那个代码难以调试和弥漫者来维护：这意味着它是脆弱的。<br>
脆弱的代码并不聪明，它是代码和整个应用程序的大规模风险。</p>
<h3 id="回答-19">回答 19</h3>
<p>编程中的巧妙通常意味着代码不太可读和/或更少维护而不是等效的非聪明方法。在维护阶段，在其寿命期间的软件成本80％或更多。所以，你做的任何事情都会增加那种成本是一件坏事。<br>
故意写作混淆的代码是聪明的缩影。使用的技术可以让一个人避开一个可能的东西，但代码永远不会在真正的wo中存活代码审查&hellip;&hellip;</p>
<h3 id="回答-20">回答 20</h3>
<p>代码意味着愚蠢的机器和由聪明人维护。因此，必须经常被人类读取。代码设计中的清晰度是卓越方案的一部分，因为它很容易读取。因此，明确的代码是理想的，并且棘手，巧妙代码不是。</p>
<h3 id="回答-21">回答 21</h3>
<p>我认为编写代码时有多种熟悉的聪明才智。新秀和专家之间的水平是那些更常常进入智能性陷阱的水平。<br>
在第一个级别，您可以编写编写它应该做的代码的代码。它有时看起来笨拙，当一名高级向你展示如何解决这个问题时，你会感到有点愚蠢。<br>
当您继续您了解有关您的工具（AKA编程语言）的更多信息，并发现一些工作的花哨的东西。有时你觉得在你的生产代码中表明，大部分时间都没有通过这样做来回答复杂，而是开始让事情变得复杂。这是TJE水平，不必要的智能性出现。<br>
当你继续进一步时，你意识到编码有点像讲故事。首先，你告诉你的stoey（如何解决问题）给编译器，但当然你也告诉这个故事，每个其他程序员都必须使用你的代码。所以保持简单愚蠢（亲吻原则，虽然有些人在没有AND的情况下引用它）。别忘了，当你的头已经占用其他问题时，你可能必须在某个时候修复这个确切的代码。并相信我会感谢，如果你很容易阅读，你就会理解背后的故事，而不必深入推理。<br>
当然，总会有代码看起来如此聪明，你不容易理解它.. Carmacks反向尊严的根源在这里来到我的脑海中，但是这个代码看起来是因为潜在的问题，而不是因为Carmack是一个想要的聪明语炫耀（也许他有时候，但不是在这里）。我需要纠正自己的自我，它是John Carmack，而他似乎经常常见的算法已经老了<br>
良好的教训是查看源代码的生成的汇编代码。您会注意到，通常情况下明确的简明代码将为您提供与您的SideeEffects非常聪明的使用相同的汇编代码。所以没有必要炫耀，我们的编译器过于聪明的时间。并记住刚刚优化Sonething而不知道它将真正有必要变为过早的优化，这是根据Knuth在计算机科学中所有邪恶的根源之一。</p>
<h3 id="回答-22">回答 22</h3>
<p>真正聪明的代码要么很容易使用，要么是ge所需的东西<br>
聪明的聪明可以为一个问题产生工作解决方案，然后只是为了聪明而聪明。太经常，软件开发人员，特别是那些有足够经验的人危险，但不足以理理解危险;他们认为他们正在做前者，当他们实际上正在做后者时。<br>
此类解决方案的结果是，当他们可以工作时，它们是一个噩梦，当事情来解决问题时，更改操作，甚至添加新功能。<br>
真正聪明的代码要么是真的很容易使用，要么是完成工作所必需的。在后一种情况下，应该仔细记录它，以便下一个需要工作的人可以理解它足以能够适当地维护它。即使是你，那个代码首先写了代码，如果你在任何延长的时间内离开它，将来会有困难的理解。</p>
<h3 id="回答-23">回答 23</h3>
<p>在编程风格的元素中，第2版，Brian Kernighan写道<br>
每个人都知道，调试是首先写作课程的两倍。所以，如果你是聪明的那样，当你写它时，你将如何调试它？<br>
这不是禁止聪明的编程，但这对所有程序员来说是谨慎的。并记住你可能不想成为唯一可以调试代码的人。编程管理人员不喜欢编写任何其他人可以合作的代码的人。<br>
有时，聪明的代码可以为性能做出奇迹，或者在这是重要的时候保存大量代码。但大多数代码不需要那种聪明。并为聪明而写的聪明代码不会让你成为一个更有价值的程序员。事实上，就是相反的。<br>
您的写入中总有两种类型的受众。当然，第一个是代码的编译器或解释器。您的代码必须工作。它必须做你需要的事情。<br>
但第二个受众也很重要：将来必须与您的代码合作的人。人们不是编制者。他们需要能够理解您的代码正在做什么以及为什么。<br>
如果您的代码很难用于普通节目（在域中）来理解，那么您的代码不是好的代码。</p>
<h3 id="回答-24">回答 24</h3>
<p>通常必须修改或更新代码。<br>
我曾经在物理实验室工作过。我们在恐惧方面具有由计算机科学毕业生撰写的程序，因为他们做了聪明的事情（或者也许只是最先进的计算机行业标准），然后离开。<br>
物理毕业生更容易使用 - 至少当他们离开时我们可以理解并修复他们的代码。</p>
<h3 id="回答-25">回答 25</h3>
<p>因为一些人 - 特别是缺乏经验的人 - 思考鲁布戈德伯格机器是聪明的解决方案。<br>
聪明 - 真正的聪明 - 降低复杂性并提高理解。聪明的解决方案往往非常无聊来看待。它们确实如此应该做的事情，而且更多或更少。他们雇用尽可能少，而且没有少。当他们是直观的时候，它们伴随着清晰的文件来解释为什么使用这种方法。<br>
聪明的解决方案需要见解和清晰度。必须有足够的了解问题，以确切地知道需要做些什么。必须有足够的了解系统来制作必须进行的修改。必须有足够清晰的思想来解决这个问题，以便在没有提问的情况下可以阅读和理解。<br>
聪明的解决方案使编程看起来很容易 - 特别是在解决问题时很难。他们是一个人可以读和惊呼那样简单的解决方案，我不敢相信我没有想到它！<br>
因此，巧妙的解决方案通常会从系统中删除代码，并使系统更加复杂。它们可以提高代码的质量而不会降低产品的质量。<br>
Rube Goldberg程序员的人造巧妙性确切地恰恰相反。<br>
写作代码，如下一个人阅读它是一个具有均值条纹和较差的脉冲控制的实习生。陶醉于简单。</p>
<h3 id="回答-26">回答 26</h3>
<p>因为程序员的其余部分会告诉你我不了解你的代码。你的老板可能会告诉你改变它，所以它更加理解。<br>
无论代码有多好或与正常废话相比如何效率。<br>
即使你所做的一行代码并做不同的时间也需要20。他们不在乎。<br>
就个人而言，我认为它让他们感到愚蠢，没有老板或同事那样。但事实是，很多地方都与规则一起工作，让我们尽可能容易。而不是如果你不明白它会学到它。<br>
这是一种思考的第一种方法<br>
因为程序员的其余部分会告诉你我不了解你的代码。你的老板可能会告诉你改变它，所以它更加理解。<br>
无论代码有多好或与正常废话相比如何效率。<br>
即使你所做的一行代码并做不同的时间也需要20。他们不在乎。<br>
就个人而言，我认为它让他们感到愚蠢，没有老板或同事那样。但事实是，很多地方都与规则一起工作，让我们尽可能容易。而不是如果你不明白它会学到它。<br>
这是一种戏剧性，一种思维方式却在很多思考。<br>
这只是一个例外，主要是核心编程。在那里它必须真正快速，在那个他们几乎任何东西都原谅了你。<br>
此外，我不是在谈论难以故意理解的代码或使用不正确的语法，只是谈论使用语言或一些非常聪明的数学函数（而不是20个IFS）。</p>
<h3 id="回答-27">回答 27</h3>
<p>因为有些人叫做聪明，其他人称之为幼稚。看！看！我想出了一个不可思议的解决方案，但它比旧解决方案快10％！<br>
不，这是不可理解的和不可能的。我宁愿该计划飙升10％，并且可以通过任何称职的程序员了解。<br>
或者SIRI，当我说取消时，问我做了什么来冒犯你？到那个点，什么都没有。但是一个聪明的程序员认为这将是可爱的。我不希望在电脑中可爱。我希望它跟随我的订单。</p>
<h3 id="回答-28">回答 28</h3>
<p>只要聪明记录良好，巧妙是非常需要的。同一个人不会在该代码的寿命上维护代码。因此，人们将从其他人继承代码。在我工作的每个地方，我已经看到非常聪明的代码，有效地处理了99.99％的病例。当涂层患者跨越0.01％案例时，会发生问题。如果该代码记录得很好并且写得很好，良好的工程师可以进入并理解代码，并且通常会提出一个解决方案，该解决方案将解决0.01％的情况而不会导致新问题。但是，我已经看到了一位工程师的一些代码，这是一个非常聪明的，但是尽可能地将代码写成了密码，没有文档解释了聪明的算法。最终，经常，代码无法解密和修复。因此，智能代码通常被删除并被效率的代码替换，并解决问题而不会导致新问题。所需的另一个步骤是校正被良好的校正。文档必须与当前实现相匹配。否则，无法维护代码。</p>
<h3 id="回答-29">回答 29</h3>
<p>我认为我们都有不同的聪明定义。聪明，对我来说，在不需要的情况下，在那里使用一衬队，特别是当它不清楚代码的意图是什么时候。<br>
另一个例子是当标准函数工作时的正则表达式。正则表达式看起来很酷，直到您需要调试它。<br>
另一个例子是使用宏和其他技术为您编写代码。如果没有打破代码的大部分，您将捕获您无法更改的世界。<br>
有一点Quip如何讲述某人的体验级别：<br>
初学者的代码很简单，没有什么比幻<br>
我认为我们都有不同的聪明定义。聪明，对我来说，在不需要的情况下，在那里使用一衬队，特别是当它不清楚代码的意图是什么时候。<br>
另一个例子是当标准函数工作时的正则表达式。正则表达式看起来很酷，直到您需要调试它。<br>
另一个例子是使用宏和其他技术为您编写代码。如果没有打破代码的大部分，您将捕获您无法更改的世界。<br>
有一点Quip如何讲述某人的体验级别：<br>
初学者的代码很简单，没有任何花哨的东西，也许使用比需要更多的单词。<br>
新手程序员更具探索性，采用独特的功能和其他技术，揭示她渴望学习。<br>
中级程序员展示了她一起编织事物的能力。她也开始从谷歌找到不寻常的代码，愿意下拉图书馆，并将跳过箍来写小号。<br>
一个高级程序员写入简单，没有什么比较的代码，也许使用更多单词而不是需要。</p>
<h3 id="回答-30">回答 30</h3>
<p>它过于聪明，嗯，非常复杂，在制定问题的解决方案时。<br>
有时解决方案确实必须非常复杂，以解决问题。但是，这意味着照顾它，调试它并在需要时调整它是更加困难的。另外，尝试查看您在六个月后创建的复杂解决方案。不那么容易。<br>
我做了几次，真的希望我没有。<br>
过于聪明的人有时可以是代码高尔夫，尽可能在最短的代码中尽可能多地进行。非常适合竞争，但是任何人都会读到的隐秘。<br>
对我来说，我是<br>
它过于聪明，嗯，非常复杂，在制定问题的解决方案时。<br>
有时解决方案确实必须非常复杂，以解决问题。但是，这意味着照顾它，调试它并在需要时调整它是更加困难的。另外，尝试查看您在六个月后创建的复杂解决方案。不那么容易。<br>
我做了几次，真的希望我没有。<br>
过于聪明的人有时可以是代码高尔夫，尽可能在最短的代码中尽可能多地进行。非常适合竞争，但是任何人都会读到的隐秘。<br>
对我来说，我相信许多编码者为工作做到这一点，你希望最简单的足够解决方案涵盖所有重要观点。<br>
我的老板喜欢编写描述业务流程的长程序。渴望我。读取功能的我应该不到十行。<br>
对于简单的功能来说，这不是一个糟糕的指标，但它不是一个金色的锤子。<br>
我召回重构一个长期进程到一堆较小的功能。几年后，我不得不再次在该代码上工作。现在我的原始代码有效，我正在另一个部分工作。然而，我惊讶地发现自己在很大程度上，我发现自己保持了他所拥有的长程序格式。<br>
遵循更容易，因为我理解业务流程，发现该过程反映了它。<br>
我之前的邻近进程的重构不一定更容易处理和调试。如实，它需要更多的工作。<br>
在我自己的工作中，我确实有代码生成代码 - 它是我喜欢某些任务的东西。我最早的例子使用了反射和表达树和泛型来尝试并制作一种特定的数据库表比较工具。它确实令人惊讶地工作，对于有问题的相当基本的数据库，但很难理解。 id编码了大约一年，对此感到骄傲。<br>
当我想到它是什么时，它是复杂的。现在我可以用简单的SQL语句完成工作。我只是使用十几个表格的两个小型数据库，每个小型表每个，并且需要一个居民需要更改其主键，并且更改通过依赖表反映。<br>
现在ID只需根据需要添加真正的主键（NIC号码，SSC等）和更新。<br>
与真正要求的情况完全一样聪明，复杂，但瞄准尽可能简单，但没有更简单。<br>
有时你真的需要一些代码生成，条件表达树创建和所有的休息（提示，这很罕见！）。<br>
大多数时候你可以直接将实际代码写入情况，也许甚至可能是，震惊和恐怖，扔掉它 - 剪掉副本以便将来参考:)。<br>
我完成了奇妙的卷积定向代码，使代码可重用，因此我不必修复许多地方的错误。<br>
在少数情况下，这是完美的（单一数据库保存例程，如果它破坏了一次，它到处都是如此易于修复）。在其他情况下，没有收益的工作大规模复杂。我确实更好地重复了处理所需三种不同情况所需的温和变化。<br>
为了将解决方案降低到最简单的形式，这是简单的维护，预测和再现，是真正的聪明。</p>
<h3 id="回答-31">回答 31</h3>
<p>嗨Shailendra！<br>
为什么聪明的聪明被认为是有害的一些人的编程？<br>
诚实地？正确记录的代码会删除该类型的任何问题。<br>
我认为这是一个问题，因为这些人认为太多了，关于可能是多么努力。 =）在所有严重性中，有些人倾向于超越编程，生活，政治，以及其他一切。<br>
当您将其打破到更简单的步骤时，问题并不复杂。如果那些太难了，你将它们打败到仍然更简单的步骤，直到你到达你可以管理的东西。<br>
这是这样的<br>
嗨Shailendra！<br>
为什么聪明的聪明被认为是有害的一些人的编程？<br>
诚实地？正确记录的代码会删除该类型的任何问题。<br>
我认为这是一个问题，因为这些人认为太多了，关于可能是多么努力。 =）在所有严重性中，有些人倾向于超越编程，生活，政治，以及其他一切。<br>
当您将其打破到更简单的步骤时，问题并不复杂。如果那些太难了，你将它们打败到仍然更简单的步骤，直到你到达你可以管理的东西。<br>
这是在编程中的方式，这是这种生活方式。</p>
<h3 id="回答-32">回答 32</h3>
<p>什么是聪明的？你无法客观地定义聪明，可能这就是为什么有些人认为是聪明的原因是有害的人有害。在给定时间的每个项目都有一个宗旨，在初步阶段，规模和稳定性的时候，在它需要削减底线并生成金钱时，在越来越多的阶段，规模和稳定性。<br>
我可能是通过聪明的聪明语来获得你的意思，它是1.开发者快捷方式或者也许是2.更加表达的编程技巧。两者都略有不同，因为在捷径中，通常只是糟糕的导管录制到市场，稳定性和可扩展性[因为它的坏和未优化]和表现力的编程振动器可维护性[因为代码不会被写入的开发者读取，开发人员进出团队]。<br>
在我看来基本上聪明的是以一种与软件项目的目标对齐的方式编写代码。这增加了项目成功歧管的可能性。为什么要使您的努力并在一个具有较低概率的项目中写出您最优雅的代码。使它工作，使其缩放，然后使其优雅是我的想法。</p>
<h3 id="回答-33">回答 33</h3>
<p>如果该计划需要长时间工作，并且其他人被其他人被理解，而不是最初创造它的人&hellip;&hellip;<br>
然后，有责任在创造该计划的人的情况下，谁将有责任保持其工作的责任做了一些难以理解的事情。</p>
<h3 id="回答-34">回答 34</h3>
<p>取决于你的意思&rsquo;聪明'。巧妙地以一种愚蠢的方式做一些简单的任务，这不仅仅是你对一些模糊语言特征或Quirk的掌握，或者在当前情况下没有真正保证的一些技术显然将被弃用。<br>
写清洁，简单，轻松维护代码。通常，绝大多数时间，这意味着做到这一点普通的古老简单愚蠢的明显方式。<br>
当然，当你需要更多的东西时，那么你应该是聪明的！问题只是给予聪明的人真正平凡的工作要做，那就低于他们的技能水平，可能会导致这种过度聪明的问题。</p>
<h3 id="回答-35">回答 35</h3>
<p>由于计划交付并进入了持久的寿命，他们得到了不同的团队和最后一件事的支持是有害和有害的，他们所有人都需要使用十六进制面具的异国情调和细微的孪形曲线超级代表。把他们的才能满足程序员需要它变成了一个没有的块&hellip;&hellip;现在不受支持的代码。保持简单明确，自由地洒在有用的评论中</p>
<h3 id="回答-36">回答 36</h3>
<p>如何<br>
巧妙的自行缘故，或者以误导的尝试优化代码是有害的，因为它降低了没有偏移增益的可读性。<br>
然而，所有聪明都没有有害。如果必须聪明地完成项目目标，或者如果有助于代码的结构，那么它可能会受益于项目而不是伤害它。<br>
这也取决于你在做什么。如果您正在编写Web服务器或其他简单的前端，性能很少是一个问题。当它是，选择适当的算法通常超过足以满足项目的需求。<br>
但是，如果您正在编写API，或构建库，数据库，编译器，设备驱动程序等，那么通常可以挤出的每一位性能都是可取的。如果您的图书馆比竞争对手显着慢，那么用户将倾向于更快的产品。与其他所有相同，例如正确性是可靠性。<br>
但是，不要指望开始通过高度经验丰富和有才华的开发人员轻松快速地阅读代码。他们仍然有很多学习。经验丰富的开发人员可能会写入x + x而不是2 * x或x &laquo; 2而不是4 * x而无需思考。而经验丰富的装配开发人员可能会编写（x &laquo; 2）+ x而不是5 * x，因为它转换为单个，快速，指令与乘法相比。有几十个特殊位操作，在需要时非常有用。但是，再次，在代码中很少需要那些，即开始开发人员或基本应用程序的开发人员可能需要。那些是聪明人有害的时候。<br>
通常，代码应该是一个简单的 - 但必要的复杂。经验丰富的发展（希望）知道差异。一个开始的开发人员没有。一个应用程序开发人员通常在简单方面错误，而一种想要展示他聪明的开发者在复杂性方面会错误。<br>
在某些情况下，过度表现可能是有害的。例如，在我的第一份工作中，我为IBM 360/30和稍后的IBM 370/30写了频道控制程序（设备驱动程序）。其中一个是打印机。打印机被评为每分钟1,100行。我的司机驾驶它，不停，每分钟1,100行。当服务工程师发现他很沮丧时 - 因为每分钟的1,100行的评级是最大，爆发速度。没有人认为有可能以这种速度不停地驱动它。幸运的是，这是一个坚实的产品，永不抱怨。<br>
另一个时间，我正在编写操作系统和早期微处理器的相关设备驱动程序。软盘控制器可以在每条轨道8 ms的轨道之间逐步逐步，而每一步为12 ms，而软盘驱动器每步以10 ms指定。但是，我可以通过在过渡时冲浪然后检查最终位置并在需要时发出固定步骤来踩到8毫秒。这使我们的产品更具竞争力。但是，一些软盘驱动器无法跟上。所以，我们公司刻录了驱动器。糟糕的驱动器会在一周左右烧坏。良好的驱动器会没有问题处理。这不是特定的，而是特定的品牌和型号。因此，如果该驱动程序已经在没有测试的情况下实施，则更高的性能将损坏客户的机器。</p>
<h3 id="回答-37">回答 37</h3>
<p>聪明的典型常被表现为混淆，故意或无意中。无论哪种方式，除非需要一些令人信服的安全目的，否则这在严重的软件项目中是不可接受的。对于可能需要在以后可能需要处理它的原件以外的程序员，软件需要可理解和可培养。<br>
查看此页面以查看最重要的代码的一个名称的30岁的代码示例，但永远不会在任何自尊的软件开发组织中出门或进入生产。是的，它确实完美地编译并运行。</p>
<h3 id="回答-38">回答 38</h3>
<p>我的经验是聪明的人在IT项目团队中令人沮丧，因为他们不想混淆其他程序员，他们将不得不维护代码。聪明的是非常规。它可能是，有些程序员读取和理解是难以读取的。这是思考。</p>
<h3 id="回答-39">回答 39</h3>
<p>本身的聪明并不认为是有害的。<br>
在说话或写作时，它有用大词。使用大词来使用大字 - 而且损害了实际理解的人 - 是一种聪明的人，即甚至在计算圈子之外的人皱眉，因为它是自我吸收的假装，忽略了其他人。<br>
但是那个完美的词，捕捉到你的意思，并且每个人都能理解并承认你设法的事情 - 这是你想要的那种聪明才智。<br>
人们去的那种哇！而不是wtf？</p>
<h3 id="回答-40">回答 40</h3>
<p>A2A。<br>
软件度量标准表明，在应用程序的使用寿命中，高达90％的代码开发成本在维护中。<br>
如果这是真的，那么我们在初始开发中所做的一切都必须在那里汇编维护任务。<br>
一个无证的&rsquo;聪明&rsquo;代码可能难以遵循 - 特别是如果他们不那么高度训练或（敢说）智能为原作者。<br>
我经常发现我在“聪明”的代码上，我写了1,3,5,10或20年前的代码只是因为我并不是新的问题并看到整个代码身体<br>
A2A。<br>
软件度量标准表明，在应用程序的使用寿命中，高达90％的代码开发成本在维护中。<br>
如果这是真的，那么我们在初始开发中所做的一切都必须在那里汇编维护任务。<br>
一个无证的&rsquo;聪明&rsquo;代码可能难以遵循 - 特别是如果他们不那么高度训练或（敢说）智能为原作者。<br>
我经常发现我在“聪明”的代码上，我写了1,3,5,10或20年前的代码，只是因为我不发布到这个问题并看到整个代码身体，就像我在开发时一样，但只有需要改变的分数。</p>
<h3 id="回答-41">回答 41</h3>
<p>代码巧妙与代码的可维护性之间存在成反比的关系。因此，除非存在一些极端的性能要求，除非在3或4个步骤中可以更好地为用户拼写到用户的情况下发生了什么，这可能在一步中可以巧妙地完成，在一起，您无法想到它究竟完成了什么。最好的代码是读数几乎像英语的代码，然后远离你得到的东西，难以解释&hellip;&hellip;</p>
<h3 id="回答-42">回答 42</h3>
<p>因为在团队项目中，最重要的因素是可维护性（易于变化） - 有时甚至不仅仅是正确性。如果软件不在任何合格开发人员可以跳入并维护项目的状态，那么聪明的开发人员失败了。</p>
<h3 id="回答-43">回答 43</h3>
<p>编程是一种沟通行为。首先到计算机本身：您基本上给了计算机指示要做什么。但也向其他人提供：您正在描述如何为计算机提供指示。在任何软件开发中，除了快速休息以完成某些事情，您随时与其他人沟通，即使该人是您未来的自我，谁试图弄清楚一年前所做的事情。<br>
想象一下，别人写了芬内纳的醒目的程序相当。每个语句都有多种含义与计算机基于上下文和情绪执行它。这将是非常聪明的。所有要求他读者所要求的所有乔伊斯都是他们花了一辈子致力于他的作品。程序员预计将设置一个下巴。 （嗯，好的，除非他们是Haskell程序员:)）<br>
这并不是说没有你应该聪明的地方。像KNUTH-MORRIS-PRATT算法一样聪明的东西。作为将非确定性有限状态自动机转换为确定性版本的算法 - 人们在使用正则表达式时每天使用的东西。但是聪明的比特需要明确定义和记录，以便其他人可以理解它们或只是将其视为黑匣子。</p>
<h3 id="回答-44">回答 44</h3>
<p>我同意一些其他响应者，很容易得到聪明，只有模糊。良好的编程重点阐述了清晰度和简单性，我争辩说，可以将清晰度和简单性与良好的问题解决的人确实非常聪明。</p>
<h3 id="回答-45">回答 45</h3>
<p>聪明的是一个问题是一个清晰的问题。看看国际混淆C代码比赛获奖者。所有这些都是非常聪明的节目，但是对于大多数情况下，信噪比的信号偏差为噪声</p>
<h3 id="回答-46">回答 46</h3>
<p>聪明（或思考一个是聪明）可以引导开发人员编写难以理解的代码。那是一个罪恶。</p>
<h3 id="回答-47">回答 47</h3>
<p>我会同意其他答案，如果它也可以明确解释，而不是某种内幕开玩笑，那么聪明的答案很好。<br>
但是，我遇到了大量的经理人和愿意的经理，他们认为如果他们保持任何聪明的事情，他们就会聪明。<br>
他们得到了，我这么聪明的家伙看着他们的脸，然后他们开始摧毁任何可能成为一个好工具或移动信封的东西。脸上的外观是街头聪明。它基本上转换为，我没有你在谈论的内容，所以我会让你在每个人面前看起来很愚蠢，你永远不会得到那件事。我不会让你因为这是我是老板，这让你看起来太聪明了。<br>
所以，这就是当你在几个时几分钟内完成一些简单的节目时，人们在几个月的房间做出真正愚蠢的事情时，那就是当你的房间做出真正愚蠢的事情的时候。经理人拿到老板没有任何钱用来支付更多的钱 - 非常聪明的确！<br>
确实，某些程序变得不可读。但是，问题是如果可以治愈。在使用更加不懈的情况下，如异步重流，现在很常见，可能很难掌握。但是，Asynchronicity会在某种意义上拯救能源账单。然而，聪明的经理宁愿燃烧能量以避免异步。所以，聪明就在编写这些东西的程序员上放一个靴子。但是，如果你经过过去，有些人写顽皮的东西都会有各种美妙的间接广告，而有些人让它变得如此可读，你几乎没有得到棘手的事情。<br>
例如:(这不像我总是遇到的工作危机）C ++有模板，它是语言的一部分。用它来组织你的代码，非常酷。当你第一次进入模板的时候，它似乎很棘手，但并不是真的。所以，我有工作人员真的害怕使用模板。 （???）但我在这个地方做了。因此，我忽视了项​​目在手机上领先，谈论模板说出标题文件几乎是不可理解的。但是，幸运的是（实际上罕见），较高的询问应用程序代码看起来像什么。真的很简单 - 真的很容易阅读，易于维护。大奖是在使用模板时，因为它非常好地清理了所有商业代码。但是，直到我开展该谈话的解决方案，我以为我将被展示。 （它已经发生在这些东西上。而且，是的，这是高中辍学，他们去使用棘手的代码解雇。）<br>
所以，通常，评估某些东西太聪明了来自真正愚蠢的人。然而，可以（非常少数）的人做出完全不可理解的代码，没有任何好处，但窃笑本身就是厌恶的家伙。</p>
<h3 id="回答-48">回答 48</h3>
<p>因为由聪明的程序员写的聪明程序可能必须被一些无法理解的慢速欺骗调试。</p>
<h3 id="回答-49">回答 49</h3>
<p>它就像建造一座桥梁而不是遵循设计，而是引入一些聪明的想法。整个项目和所有正在进行数百任务的所有分包商都准备好并期望桥梁遵循建筑师的计划，虽然您对设计的变化是聪明的，但它抛出整个项目，因为现在没有人在同一页上。<br>
我曾经飞到德国来指导一个编程团队。其中一个程序员认为他很聪明，并在伟大的地方做了一些聪明的事情。然而，他们稍后造成了一百万行代码的问题，因为他没有参与这个项目的那部分，他不知道他的聪明的编程会导致线路的问题。</p>
<h3 id="回答-50">回答 50</h3>
<p>我工作了一段时间，伴随着一个非常聪明的舞台，称为迈克支持金融系统。他不得不写一份报告，每年运行一次，为制度中的每个政策发表声明，并在发表声明的日期后的所有正确的财务价值。<br>
现在这是一个简单的方法是在报告运行时获取或计算所需的所有值。<br>
这对迈克来说太​​简单而无聊。他决定提前动态地计算所需的所有值，并将其存储在表中。以这种方式报告运行时，它应该必须从该表中获取值。<br>
这非常聪明。但它意味着他的业务规则编码正在进行这些计算在系统上一直在射击。每年一年中的任何时候都会在政策上发生任何事情，他的规则会发现他报告计划是否需要的任何价值观。<br>
这是一个绝对的噩梦。在他的规则中为一个月或多个错误导致系统的每个单个部分都引起了失败。是的，即使是聪明的程序员也会产生错误。当你以一种方式开发你的编码在各种不可预测的情况下火灾时，你将比正常的错误变得更远。</p>
<h3 id="回答-51">回答 51</h3>
<p>因为向导程序员经常使用快捷方式来实现其目标，但这种快捷方式基本上是对坏（低安全性）编程的例子。</p>
<h3 id="回答-52">回答 52</h3>
<p>当你说聪明有害的时候，你是正确的，因为聪明的不是聪明的，聪明就像沉闷试图欺骗或偷窃并用它来造成伤害。<br>
这就是为什么聪明的程序员想到安全，安全是背骨，使聪明的程序员无法破解我们的代码或系统。<br>
谢谢</p>
<h3 id="回答-53">回答 53</h3>
<p>我不明白为什么聪明的人对自己的编程有害。<br>
就像沃伦自助餐曾经说过，如果你要雇用人，你想要他们聪明，努力工作和诚实。如果他们错过了这个属性中的一个或两个，你将会有问题（聪明但懒惰和/或不诚实只是麻烦，例如麻烦）<br>
另外，请记住，有些人在各行各业中考虑聪明才有害&hellip;&hellip;</p>
<h3 id="回答-54">回答 54</h3>
<p>有很多方法可以聪明地制作难以阅读和难以维护的代码，但我的个人宠物Peeve是在表达式中遗漏括号。<br>
聪明的程序员认为我知道所有关于运营商优先级规则，所以生病了释放括号，然后只有像我这样的聪明人会理解这一点。<br>
采取一个简单的例子：<br>
x = a + b * c<br>
他是否意味着一个+（b * c），并且通过允许优先的规则来实现这一目标是聪明的？<br>
或者他的意思是（a + b）* c？也许他决定例如缩放所需的总和，并将* C添加为事后的事后。现在他是<br>
有很多方法可以聪明地制作难以阅读和难以维护的代码，但我的个人宠物Peeve是在表达式中遗漏括号。<br>
聪明的程序员认为我知道所有关于运营商优先级规则，所以生病了释放括号，然后只有像我这样的聪明人会理解这一点。<br>
采取一个简单的例子：<br>
x = a + b * c<br>
他是否意味着一个+（b * c），并且通过允许优先的规则来实现这一目标是聪明的？<br>
或者他的意思是（a + b）* c？也许他决定例如缩放所需的总和，并将* C添加为事后的事后。现在他试图找到这个错误。<br>
在逻辑表达式中，它甚至更糟糕：<br>
if（a &amp;&amp; b || c &amp;&amp;！d &amp;&amp; e == f | g）<br>
你如何阅读它并知道会发生什么？更糟糕的是，如果这些条款是职能，那么哪些叫做和在什么条件下？ （那是最终的'|&lsquo;意味着||？）<br>
现在，有各种原因永远不会在第一位置编写代码，但试图聪明，省略括号只是复杂愚蠢。<br>
它的微不足道添加必要的括号来使您的意图清除，所以这样做。</p>
<h3 id="回答-55">回答 55</h3>
<p>在某些情况下，此声明绝对是真实的，而不是在某些情况下。让我告诉你怎么做。<br>
有害聪明：<br>
以上是一些有害聪明的例子，您使用循环/阵列/列表看起来聪明，但是有哈里米有自己的代码和编码技巧。<br>
有用的聪明才智：<br>
希望我已经回答了你的问题。<br>
Swayam。</p>
<h3 id="回答-56">回答 56</h3>
<p>在编程中的谚语：为了调试某人ELSES代码，您需要与它们一样聪明的两倍。因此，如果您尽可能聪明，您将永远不会调试<em>自己的</em>代码。<br>
虽然格言最初是为了鼓励彻底的文件，但也适用于聪明。首先写入清晰，简洁，易于理解代码，以可维护性最重要。如果需要，聪明（AKA优化）可以稍后来。</p>
<h3 id="回答-57">回答 57</h3>
<p>聪明和可读性都在争论中。在一个组织中，只有一个人了解某些软件如何工作时，这是糟糕的。</p>
<h3 id="回答-58">回答 58</h3>
<p>几年后，我已经看到人们无法阅读自己的聪明代码。您的代码应该是其他人最可读和可维护的。</p>
<h3 id="回答-59">回答 59</h3>
<p>每个人都知道，调试是首先写作课程的两倍。所以，如果你是聪明的那样，当你写它时，你将如何调试它？<br>
Brian Kernighan，编程风格的元素，第2版，第2章<br>
这就是为什么高级程序员在你的聪明代码中拍打你的头部（隐喻），这是因为有更实用的聪明风险。正如我所说，史蒂文·欧伦斯答案要努力调试两倍，就像写作代码一样？，当你编写代码时，你知道你打算什么，但是当你打算调试代码时，根据定义，代码不做你想要的东西。如果您正在调试其他人的代码，您可能不知道他们打算是什么。<br>
聪明本身不是一个目标，聪明就是你用来追求其他目标的工具。如果您将您的聪明才智指向清晰可理解的代码，这是一个有用的聪明才智。如果您将聪明才智引导为聪明的魅力，这是屁股的痛苦。<br>
经验丰富的软件开发人员经常被聪明咬伤 - 他们自己或其他人 - 对它的持态度持怀疑态度。<br>
聪明和优雅之间存在显着差异，或者可能更准确地说，大多数聪明都不优雅，但优雅的节目可能非常聪明，而且是由熟练和经验丰富的程序员崇拜的聪明才智。<br>
在编程中，优雅是程序员从数学借用或继承的术语。它与Occam的Razor的原始版本有些相关，实体不是不必要的，或者更简单的措辞，不要让事情复杂化，没有充分的理由。或者作为着名的爱因斯坦说（由Composer Roger Sessions引用或释放），一切都应该像它一样简单，但并不简单。<br>
在编程中，优雅意味着特定排序的巧妙，这会降低复杂性。弗雷德布鲁克斯，在他的经典书中，讨论了必要的复杂性和意外复杂之间的差异。优雅的代码在不引入意外复杂性的情况下实现必要的复杂性。<br>
这是一种在摘要中解释的困难概念;这是程序员经常争辩的事情。通常优雅的代码是在一种不一定是明显的方式的方式接近问题的代码，但荒谬并不意味着复杂。当您理解它时，您实现它会产生正确的（和通常复杂的）结果，通常通过更简单的元素的相互作用。<br>
UNIX操作系统的设计是这一原则最持久的例子之一，尽管这变得如此普遍，即这可能很难注意到它，这几天。 Git的内部是另一个例子，尽管Git的用户界面困难通常会掩盖其基础优雅。如果人们想要在与其他示例中的评论中颂扬，我将在此添加它们。<br>
引用自己，在另一个答案中：<br>
非程序员理解的最困难的事情之一是简单性更加困难，并且需要更多的工作。但它会退缩，因为代码设计中的优雅简单降低了在代码上工作的认知开销量。这导致更快，更有效的编程，更少的时间浪费在制作因不必要的复杂性引起的调试问题方面的变化或更糟糕的时间。<br>
Steven J Owenss回答John Byrd说好的程序员编写了良好的代码。伟大的程序员没有写代码。 Zen程序员删除代码？什么是禅宗编程？</p>
<h3 id="回答-60">回答 60</h3>
<p>良好软件的第一个规则：它必须是可读的。<br>
如果聪明的是可读性，这是一件好事。如果它困扰，那就太好了。有一个宽的中间地面，需要一些工作来了解事情的工作，但是当你得到的照片时，你会非常清楚地看到它。<br>
摘要：一如既往，它取决于。</p>
<h3 id="回答-61">回答 61</h3>
<p>这可以根据您的观察方式以多种方式解释。所以让我们在伪代码中采取一些例子。第一个例子是关于看错的事情并在错误的细节中ingrosse。有时人会优化某种东西难，只有意识到他们优化他们不需要做的事情开始才能开始。此时我可以将i-can-do-it hubris回来咬你.Consider这个作业：我需要你建立一个课程持有一堆票。每票都有优先级，我需要你给我一个在任何给定时间都有最高优先级的票。如果多个票价具有相同的最高优先级，则任何一个票证都很好。你可能会说，好的，我可以做到这一点。事实上有几种方法可以做到这一点.Let表示我们不是想成为聪明的人，但我们不知道我们的数据结构。所以我们认为我们将估计是一个很多插入和删除，我们不关心获取项目＃12或者。所以我们使用一组。（有一个数据stru更好的，我们会到达那样的。）这样的东西：</p>
<!-- raw HTML omitted -->
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
