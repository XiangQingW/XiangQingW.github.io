<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>生锈将在谷歌替换C &#43;&#43;吗？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="生锈将在谷歌替换C &#43;&#43;吗？ 回答 1 简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。旋转大学＆c
简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。通过旋转的大学和计算机专家组，C &#43;&#43;已成为，仍然是演变语言。结果是一种非专有，但快速，但可维护的语言，具有巨大的粉丝底座和经过验证的结果。
回答 2 而我是AG
此讨论似乎每年都有几年为什么X语言需要替换C / C &#43;&#43;，这次参数符合内存安全性。没有人愿意承认，在不安全内存中使用的每种情况下，都是程序员部分的编程错误。溢出，重新使用释放指针和索引是错误，它们被称为绑定检查器的最重要的工具所捕获。
此外，它不像假设的内存安全语言没有自己的安全问题，所有这些都是由同样的程序主错误发出的。
虽然我同意生锈是一种伟大的语言，可以提供以前吹捧的内存安全语言，如Java，Python或Ruby，C / C &#43;&#43;无法替换的速度缺乏缺乏。在编译的字节码时需要速度和效率，如操作系统，存在某些区域。
如果我在谷歌趋势上比较生锈与C &#43;&#43;，这就是我得到的。 C &#43;&#43;击败了死亡。每个C &#43;&#43;的槽都像匕首穿过锈，把它钉在地板上！ C &#43;&#43;似乎拥有它自己的UPS和Downs，但在过去的5年里，它保持了一个非常稳定的趋势。
rust是一种伟大的语言，但主要问题是世界上的大部分行业和公司都不喜欢重写他们的代码，正如你可以看到的tiobe - 软件质量公司c &#43;&#43;即将到来第四位，这次从顶部到位！ ！而且锈病甚至不是十大。
虽然Rust很棒，但我不喜欢在我的项目中使用它，因为大多数伟大的图书馆仍在使用C / C &#43;&#43;开发，以及通过Rust包装C / C &#43;&#43;代码的点。
IM游戏引擎开发人员，我真的很想将发动机转发生锈，但我必须在大多数C / C &#43;&#43;代码中写一个包装器!!!不幸的是Rust太年轻了。
在C &#43;&#43;中，您将类写入抽象内存访问。在编码这些类时，请在这些类上依赖于每次呼叫步骤中的内存。它与Rust - Youd将您的工具包装到一个安全API中的所有不安全的用法，仍会收获借阅的所有优势。
所以，是的，我认为生锈对这些领域有益。它始终难以编写低级别代码，而RERRES让您将更多的复杂器卸载到编译器。所有不安全的代码都将是本地化的，而您使用测试和文档以证明不变。
C &#43;&#43;是一种很好的语言，您可以获得很棒的性能，可以使用丰富的功能库构建超快速应用程序。您可以从GUI应用程序构建各种应用程序到3D图形，游戏，桌面应用以及硬核心计算机视觉应用程序。
另一方面，Rust也很快。它可以在任何地方使用C &#43;&#43;可以使用它。它有一个卓越的社区，大多数人都是内存安全！ Rust的并发能力通常被誉为优于C &#43;&#43;，而开发人员则渴望抓住此功能的生锈！这就是为什么生锈是赢家。
回答 3 截至2015年，谷歌在约20亿行代码中。[1]其中许多我假设是用C &#43;&#43;写的。">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="生锈将在谷歌替换C &#43;&#43;吗？" />
<meta property="og:description" content="生锈将在谷歌替换C &#43;&#43;吗？ 回答 1 简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。旋转大学＆c
简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。通过旋转的大学和计算机专家组，C &#43;&#43;已成为，仍然是演变语言。结果是一种非专有，但快速，但可维护的语言，具有巨大的粉丝底座和经过验证的结果。
回答 2 而我是AG
此讨论似乎每年都有几年为什么X语言需要替换C / C &#43;&#43;，这次参数符合内存安全性。没有人愿意承认，在不安全内存中使用的每种情况下，都是程序员部分的编程错误。溢出，重新使用释放指针和索引是错误，它们被称为绑定检查器的最重要的工具所捕获。
此外，它不像假设的内存安全语言没有自己的安全问题，所有这些都是由同样的程序主错误发出的。
虽然我同意生锈是一种伟大的语言，可以提供以前吹捧的内存安全语言，如Java，Python或Ruby，C / C &#43;&#43;无法替换的速度缺乏缺乏。在编译的字节码时需要速度和效率，如操作系统，存在某些区域。
如果我在谷歌趋势上比较生锈与C &#43;&#43;，这就是我得到的。 C &#43;&#43;击败了死亡。每个C &#43;&#43;的槽都像匕首穿过锈，把它钉在地板上！ C &#43;&#43;似乎拥有它自己的UPS和Downs，但在过去的5年里，它保持了一个非常稳定的趋势。
rust是一种伟大的语言，但主要问题是世界上的大部分行业和公司都不喜欢重写他们的代码，正如你可以看到的tiobe - 软件质量公司c &#43;&#43;即将到来第四位，这次从顶部到位！ ！而且锈病甚至不是十大。
虽然Rust很棒，但我不喜欢在我的项目中使用它，因为大多数伟大的图书馆仍在使用C / C &#43;&#43;开发，以及通过Rust包装C / C &#43;&#43;代码的点。
IM游戏引擎开发人员，我真的很想将发动机转发生锈，但我必须在大多数C / C &#43;&#43;代码中写一个包装器!!!不幸的是Rust太年轻了。
在C &#43;&#43;中，您将类写入抽象内存访问。在编码这些类时，请在这些类上依赖于每次呼叫步骤中的内存。它与Rust - Youd将您的工具包装到一个安全API中的所有不安全的用法，仍会收获借阅的所有优势。
所以，是的，我认为生锈对这些领域有益。它始终难以编写低级别代码，而RERRES让您将更多的复杂器卸载到编译器。所有不安全的代码都将是本地化的，而您使用测试和文档以证明不变。
C &#43;&#43;是一种很好的语言，您可以获得很棒的性能，可以使用丰富的功能库构建超快速应用程序。您可以从GUI应用程序构建各种应用程序到3D图形，游戏，桌面应用以及硬核心计算机视觉应用程序。
另一方面，Rust也很快。它可以在任何地方使用C &#43;&#43;可以使用它。它有一个卓越的社区，大多数人都是内存安全！ Rust的并发能力通常被誉为优于C &#43;&#43;，而开发人员则渴望抓住此功能的生锈！这就是为什么生锈是赢家。
回答 3 截至2015年，谷歌在约20亿行代码中。[1]其中许多我假设是用C &#43;&#43;写的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/will-rust-replace-c-in-google/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:02+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:02+08:00" />

<meta itemprop="name" content="生锈将在谷歌替换C &#43;&#43;吗？">
<meta itemprop="description" content="生锈将在谷歌替换C &#43;&#43;吗？ 回答 1 简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。旋转大学＆c
简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。通过旋转的大学和计算机专家组，C &#43;&#43;已成为，仍然是演变语言。结果是一种非专有，但快速，但可维护的语言，具有巨大的粉丝底座和经过验证的结果。
回答 2 而我是AG
此讨论似乎每年都有几年为什么X语言需要替换C / C &#43;&#43;，这次参数符合内存安全性。没有人愿意承认，在不安全内存中使用的每种情况下，都是程序员部分的编程错误。溢出，重新使用释放指针和索引是错误，它们被称为绑定检查器的最重要的工具所捕获。
此外，它不像假设的内存安全语言没有自己的安全问题，所有这些都是由同样的程序主错误发出的。
虽然我同意生锈是一种伟大的语言，可以提供以前吹捧的内存安全语言，如Java，Python或Ruby，C / C &#43;&#43;无法替换的速度缺乏缺乏。在编译的字节码时需要速度和效率，如操作系统，存在某些区域。
如果我在谷歌趋势上比较生锈与C &#43;&#43;，这就是我得到的。 C &#43;&#43;击败了死亡。每个C &#43;&#43;的槽都像匕首穿过锈，把它钉在地板上！ C &#43;&#43;似乎拥有它自己的UPS和Downs，但在过去的5年里，它保持了一个非常稳定的趋势。
rust是一种伟大的语言，但主要问题是世界上的大部分行业和公司都不喜欢重写他们的代码，正如你可以看到的tiobe - 软件质量公司c &#43;&#43;即将到来第四位，这次从顶部到位！ ！而且锈病甚至不是十大。
虽然Rust很棒，但我不喜欢在我的项目中使用它，因为大多数伟大的图书馆仍在使用C / C &#43;&#43;开发，以及通过Rust包装C / C &#43;&#43;代码的点。
IM游戏引擎开发人员，我真的很想将发动机转发生锈，但我必须在大多数C / C &#43;&#43;代码中写一个包装器!!!不幸的是Rust太年轻了。
在C &#43;&#43;中，您将类写入抽象内存访问。在编码这些类时，请在这些类上依赖于每次呼叫步骤中的内存。它与Rust - Youd将您的工具包装到一个安全API中的所有不安全的用法，仍会收获借阅的所有优势。
所以，是的，我认为生锈对这些领域有益。它始终难以编写低级别代码，而RERRES让您将更多的复杂器卸载到编译器。所有不安全的代码都将是本地化的，而您使用测试和文档以证明不变。
C &#43;&#43;是一种很好的语言，您可以获得很棒的性能，可以使用丰富的功能库构建超快速应用程序。您可以从GUI应用程序构建各种应用程序到3D图形，游戏，桌面应用以及硬核心计算机视觉应用程序。
另一方面，Rust也很快。它可以在任何地方使用C &#43;&#43;可以使用它。它有一个卓越的社区，大多数人都是内存安全！ Rust的并发能力通常被誉为优于C &#43;&#43;，而开发人员则渴望抓住此功能的生锈！这就是为什么生锈是赢家。
回答 3 截至2015年，谷歌在约20亿行代码中。[1]其中许多我假设是用C &#43;&#43;写的。"><meta itemprop="datePublished" content="2022-01-23T22:08:02+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:02+08:00" />
<meta itemprop="wordCount" content="437">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="生锈将在谷歌替换C &#43;&#43;吗？"/>
<meta name="twitter:description" content="生锈将在谷歌替换C &#43;&#43;吗？ 回答 1 简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。旋转大学＆c
简单的答案，不，它不生锈，甚至没有任何威胁c &#43;&#43;的语言，这只是几个原因
还有很多其他原因，让我们下次保持:)
快乐的c &#43;&#43; ing
编辑1：
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。通过旋转的大学和计算机专家组，C &#43;&#43;已成为，仍然是演变语言。结果是一种非专有，但快速，但可维护的语言，具有巨大的粉丝底座和经过验证的结果。
回答 2 而我是AG
此讨论似乎每年都有几年为什么X语言需要替换C / C &#43;&#43;，这次参数符合内存安全性。没有人愿意承认，在不安全内存中使用的每种情况下，都是程序员部分的编程错误。溢出，重新使用释放指针和索引是错误，它们被称为绑定检查器的最重要的工具所捕获。
此外，它不像假设的内存安全语言没有自己的安全问题，所有这些都是由同样的程序主错误发出的。
虽然我同意生锈是一种伟大的语言，可以提供以前吹捧的内存安全语言，如Java，Python或Ruby，C / C &#43;&#43;无法替换的速度缺乏缺乏。在编译的字节码时需要速度和效率，如操作系统，存在某些区域。
如果我在谷歌趋势上比较生锈与C &#43;&#43;，这就是我得到的。 C &#43;&#43;击败了死亡。每个C &#43;&#43;的槽都像匕首穿过锈，把它钉在地板上！ C &#43;&#43;似乎拥有它自己的UPS和Downs，但在过去的5年里，它保持了一个非常稳定的趋势。
rust是一种伟大的语言，但主要问题是世界上的大部分行业和公司都不喜欢重写他们的代码，正如你可以看到的tiobe - 软件质量公司c &#43;&#43;即将到来第四位，这次从顶部到位！ ！而且锈病甚至不是十大。
虽然Rust很棒，但我不喜欢在我的项目中使用它，因为大多数伟大的图书馆仍在使用C / C &#43;&#43;开发，以及通过Rust包装C / C &#43;&#43;代码的点。
IM游戏引擎开发人员，我真的很想将发动机转发生锈，但我必须在大多数C / C &#43;&#43;代码中写一个包装器!!!不幸的是Rust太年轻了。
在C &#43;&#43;中，您将类写入抽象内存访问。在编码这些类时，请在这些类上依赖于每次呼叫步骤中的内存。它与Rust - Youd将您的工具包装到一个安全API中的所有不安全的用法，仍会收获借阅的所有优势。
所以，是的，我认为生锈对这些领域有益。它始终难以编写低级别代码，而RERRES让您将更多的复杂器卸载到编译器。所有不安全的代码都将是本地化的，而您使用测试和文档以证明不变。
C &#43;&#43;是一种很好的语言，您可以获得很棒的性能，可以使用丰富的功能库构建超快速应用程序。您可以从GUI应用程序构建各种应用程序到3D图形，游戏，桌面应用以及硬核心计算机视觉应用程序。
另一方面，Rust也很快。它可以在任何地方使用C &#43;&#43;可以使用它。它有一个卓越的社区，大多数人都是内存安全！ Rust的并发能力通常被誉为优于C &#43;&#43;，而开发人员则渴望抓住此功能的生锈！这就是为什么生锈是赢家。
回答 3 截至2015年，谷歌在约20亿行代码中。[1]其中许多我假设是用C &#43;&#43;写的。"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">生锈将在谷歌替换C &#43;&#43;吗？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:02+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="生锈将在谷歌替换c-吗">生锈将在谷歌替换C ++吗？</h2>
<h3 id="回答-1">回答 1</h3>
<p>简单的答案，不，它不生锈，甚至没有任何威胁c ++的语言，这只是几个原因<br>
还有很多其他原因，让我们下次保持:)<br>
快乐的c ++ ing<br>
编辑1：<br>
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。旋转大学＆c<br>
简单的答案，不，它不生锈，甚至没有任何威胁c ++的语言，这只是几个原因<br>
还有很多其他原因，让我们下次保持:)<br>
快乐的c ++ ing<br>
编辑1：<br>
谢谢罗伯特格伦蒂斯特建议一个非常强大的原因：因为它是ISO标准。通过旋转的大学和计算机专家组，C ++已成为，仍然是演变语言。结果是一种非专有，但快速，但可维护的语言，具有巨大的粉丝底座和经过验证的结果。</p>
<h3 id="回答-2">回答 2</h3>
<p>而我是AG<br>
此讨论似乎每年都有几年为什么X语言需要替换C / C ++，这次参数符合内存安全性。没有人愿意承认，在不安全内存中使用的每种情况下，都是程序员部分的编程错误。溢出，重新使用释放指针和索引是错误，它们被称为绑定检查器的最重要的工具所捕获。<br>
此外，它不像假设的内存安全语言没有自己的安全问题，所有这些都是由同样的程序主错误发出的。<br>
虽然我同意生锈是一种伟大的语言，可以提供以前吹捧的内存安全语言，如Java，Python或Ruby，C / C ++无法替换的速度缺乏缺乏。在编译的字节码时需要速度和效率，如操作系统，存在某些区域。<br>
如果我在谷歌趋势上比较生锈与C ++，这就是我得到的。 C ++击败了死亡。每个C ++的槽都像匕首穿过锈，把它钉在地板上！ C ++似乎拥有它自己的UPS和Downs，但在过去的5年里，它保持了一个非常稳定的趋势。<br>
rust是一种伟大的语言，但主要问题是世界上的大部分行业和公司都不喜欢重写他们的代码，正如你可以看到的tiobe  - 软件质量公司c ++即将到来第四位，这次从顶部到位！ ！而且锈病甚至不是十大。<br>
虽然Rust很棒，但我不喜欢在我的项目中使用它，因为大多数伟大的图书馆仍在使用C / C ++开发，以及通过Rust包装C / C ++代码的点。<br>
IM游戏引擎开发人员，我真的很想将发动机转发生锈，但我必须在大多数C / C ++代码中写一个包装器!!!不幸的是Rust太年轻了。<br>
在C ++中，您将类写入抽象内存访问。在编码这些类时，请在这些类上依赖于每次呼叫步骤中的内存。它与Rust  -  Youd将您的工具包装到一个安全API中的所有不安全的用法，仍会收获借阅的所有优势。<br>
所以，是的，我认为生锈对这些领域有益。它始终难以编写低级别代码，而RERRES让您将更多的复杂器卸载到编译器。所有不安全的代码都将是本地化的，而您使用测试和文档以证明不变。<br>
C ++是一种很好的语言，您可以获得很棒的性能，可以使用丰富的功能库构建超快速应用程序。您可以从GUI应用程序构建各种应用程序到3D图形，游戏，桌面应用以及硬核心计算机视觉应用程序。<br>
另一方面，Rust也很快。它可以在任何地方使用C ++可以使用它。它有一个卓越的社区，大多数人都是内存安全！ Rust的并发能力通常被誉为优于C ++，而开发人员则渴望抓住此功能的生锈！这就是为什么生锈是赢家。</p>
<h3 id="回答-3">回答 3</h3>
<p>截至2015年，谷歌在约20亿行代码中。[1]其中许多我假设是用C ++写的。<br>
<!-- raw HTML omitted --> [1] <!-- raw HTML omitted --><br>
仅谷歌Chrome拥有450万行代码，其中160万被编写在C ++。[2] （2012年的数据）。<br>
<!-- raw HTML omitted --> [2] <!-- raw HTML omitted --><br>
我没有看到任何Rational Person试图替换所有这些，因为块中有一种新的语言。<br>
已经说过这一点，显然在开发人员社区中得到了很好的收益。根据堆栈溢出2017调查，Rust排名第一是最爱的语言。[3]<br>
<!-- raw HTML omitted --> [3] <!-- raw HTML omitted --><br>
也许Google更频繁地使用RUDER更频繁地用于现有的新项目或新功能<br>
脚注<br>
截至2015年，谷歌在约20亿行代码中。[1]其中许多我假设是用C ++写的。<br>
<!-- raw HTML omitted --> [1] <!-- raw HTML omitted --><br>
仅谷歌Chrome拥有450万行代码，其中160万被编写在C ++。[2] （2012年的数据）。<br>
<!-- raw HTML omitted --> [2] <!-- raw HTML omitted --><br>
我没有看到任何Rational Person试图替换所有这些，因为块中有一种新的语言。<br>
已经说过这一点，显然在开发人员社区中得到了很好的收益。根据堆栈溢出2017调查，Rust排名第一是最爱的语言。[3]<br>
<!-- raw HTML omitted --> [3] <!-- raw HTML omitted --><br>
也许谷歌开始使用Rust更频繁地用于现有产品的新项目或新功能，或者也许他们会喜欢去。<br>
编辑：请记住，今天仍然使用COBOL和FORTRAN。语言很少死。<br>
脚注</p>
<h3 id="回答-4">回答 4</h3>
<p>不，谷歌拥有自己的神圣牛 - 这首语言是由计划的第9和Iferfnoos的人开发的。 （它主要是一个笑话 - 问题在于营销，封闭的商业发展模式和缺乏庞大的应付社区）。<br>
我看到关于C ++的一些评论永远不会被替换。同样的几年前关于C ++与Java相同。我认识一些讨厌C ++的人，如果一些更友好的语言会给他们相同的可链接，便携式，快速和资源有效的代码，那么就会讨厌C ++的人。如果每个C ++开发人员为雇主耗费两倍，那么在另一种有效语言中的开发人员都会成为一个开发人员，他将在那里爱C ++。无论如何，有大量的代码用C ++编写，因此它将留在没有任何变体的遗留恐龙。 ISO标准是一个空的参数：Prolog也是ISO标准。你在任何地方看到它吗？<br>
关于生锈，它已经有很大的潜力，但它太年轻了。因此，我们可以看到明年的战斗将在宠物项目中首先是宠物项目，也许在一些初创公司中，这些初创公司没有足够的资源来支付Java拥有成本和昂贵的С++合格开发人员。</p>
<h3 id="回答-5">回答 5</h3>
<p>不，此外，隐藏在这个问题中的真正讽刺自然是从大多数语言的编译器和口译员包括生锈，几乎总是使用C或C ++写写。因此，您真的不能轻易地逃脱说，如果有可能使用用于为替换这些语言中的任何一种的新语言编写非常编译的编译器，那么新的语言将替换C或C ++。<br>
看到真实但是循环推理在这里？只要C和C ++ Bootstrap解释器和编译器用于新语言，它们永远不会消失。<br>
***还要注意任何语言，如果它被编译成独立的可执行文件或者只是实时解释，都会被写入汇编语言，编程语言的第一个和最基本的语言，它位于纯金属机代码上方，但是然后，该装配本身将被编译为纯二进制零，然后打开和关闭开关的基本代码，准确地说，所有计算机如何在门阵列和晶体管的级别运行。</p>
<h3 id="回答-6">回答 6</h3>
<p>谷歌创建了许多语言的兴趣但未完成替换旧的语言。要为实际开发创建新的语言，更重要的是创建一种用于测试新功能的语言</p>
<h3 id="回答-7">回答 7</h3>
<p>谷歌正在积极调查铬中的生锈。他们承认，替换它的全部都有如此多的C ++，但它们也没有看到一个可以让C ++安全的路径足够安全，以修复他们的主要内存安全漏洞。<br>
所以答案似乎是：Rust可能在某些情况下开始替换C ++，并且随着时间的推移，对于暴露于攻击的任何代码（例如，所有的铬，用于启动者）。</p>
<h3 id="回答-8">回答 8</h3>
<p>亚马逊和微软希望在某些情况下使用RUDER在某些方面的关键管弦乐集库中使用。我会想象有想要1ms开始调度退出时间的库（如Docker Tools）。我亲自寻找rust for aws lambda（同样的快速/快速/复杂库功能），所以我想象其他人会看到成本/益处权衡。<br>
对于谷歌，以及我记得的内容，有3个主要支持语言具有明显的所有权区域.C ++，Python，Java。如果需要用内存紧密或快速运行复杂的逻辑，并且具有快速启动;使用C ++。如果需要快速启动/关闭时间或被编辑并存储在DB：Python中。如果它是复杂的业务逻辑，主要只是手动保存其他服务：Java。<br>
后来他们添加了golang和dart。 Dart似乎是GUI的重点（扑腾十字平台原产地，等）。当需要紧凑的内存和快速启动时，Golang正在慢慢替换Java。这两种也似乎对Oracle / Sun诉讼W.r.t.的反应。 Java（谷歌害怕依赖它，而C＃对谷歌的使用情况并不是可行的）<br>
虽然我个人可以编写一个30分参数，为什么Rust优于较低级别的C ++，我发现很难看出，为什么Google会将RUDE作为任何区域的谷歌工程师的目标建立。<br>
这不是一个最佳的GUI框架。<br>
它不是比C ++更快或更多的内存紧凑<br>
Frore的编译时期使得难以替换Golang的Google的Java的使用情况（它的主要竞争对手是我看来的Golang）。唯一的唯一情况，Rust明显优于Golang在GC暂停情况（每个基准测试中，我看到的生锈有一个更稳定的5ms任务执行时间V.S. Go的定期1.0第二任务执行时间）。因此，除非“GO”谷歌 - 工程团队有一个GC停滞问题，否则我无法看到它们切换出锈蚀 - 并将编译时间转换为“咖啡休息时间”。<br>
它与Android / Embedded Google-Home-opmiances中使用的一系列链接C ++可执行文件并不小/轻量级。对于系统上的单个可执行文件和系统上没有LibStdc ++的IOT，RURD较小，但如果您有一个整个操作系统的库，则不是那么多。<br>
谷歌是一个工程公司，项目经理在建造的内容中有一个强烈的说法，为什么。少于Microsoft拥有许多研发部门或亚马逊，使用HTTP + JSON Interexchange（在Amazon，没有两个项目甚至闻到类似的项目），而在谷歌上有一个常见的谷歌感觉。</p>
<h3 id="回答-9">回答 9</h3>
<p>我不知道为什么以不同的方式对我来说出现同样的问题。无论如何，答案是一样的：<br>
Rust永远不会替换C ++。 rust和其他语言声称杀死/替换C ++的语言，已经死了。<br>
让我解释一下：在计算中，制作干净的板岩是不可能的，完全不可接受！无论您是哪些新想法，您都包含（安全，效率，清晰，容易，成本，智力等），不可能留下一切并重新开始。世界不这样做，就像那样简单。<br>
当世界开始代码时，一切都是福特兰。那时，它根本不可能离开Fortran。它创造了几个天才，这是一种具有优势的语言，即非常容易将Fortran代码转换为C. C的另一个优势是其编译器非常简单，因此其在新机器中的实施很容易。因此，许多机器出现了C，但没有Fortran。还创建了UNIX操作系统，这一切都在C.所有这一切导致慢世界迁移到C.<br>
但是还有更多：Simula，Smalltalk，其他人有一个非常重要的编程范式，无法忘记：面向对象的编程。无论如何，一如既往地，当时这是不可能从头开始。有必要以新的C语言进行小而逐步的变化，而是纳入OOP范式。通过另一个天才，Bjarne Stroustrup与对象（今天的C ++）创建了这一点。这个想法（构建未来，保持过去）允许缓慢过渡到新语言。只有这种转变才是可能的，因为C ++与C完全兼容，它纳入了信息学完全新的大进步：面向对象的编程和通用编程。即使在今天，40年后，这种过渡是非常困难和缓慢的。 C ++没有完全取代C，可能永远不会。但重要的一点是：要进入一种新语言，唯一可能的替代方案是使它始终慢慢地支持，一直是过去。任何暴力过渡都是不可能的。<br>
如今，C ++是对未来的连续转换：CFRONT，C ++ 98，C ++ 03，C ++ 11，C ++ 14，C ++ 17，C ++ 20，C ++ 23和承诺C ++ 26;所有这些都保持完全兼容过去。这是唯一的，是在信息学中发展的独特替代方案：非常缓慢和自适应的转换。<br>
如果1980年不可能的暴力转型，今天有数十亿个计算机线计划，数百万程序员，数以千计的教师，数百名免费图书馆，数百个网络页面信息，几个免费的C ++免费优化编译器（适用于所有机器）和一个永久性地发展语言的活动C ++委员会;根本无法制作一个清洁的板岩假装重新开始零。<br>
为什么生锈和其他人出生死了？因为这些语言在计算机技术进步方面没有代表足够的重要步骤，他们与过去兼容，而且旨在将来暴力地改变。这根本是不可能的。对不起，但它的成功概率正好零。<br>
我的建议：忘记生锈和其他C ++杀手，不要浪费你的时间和金钱。如果您有任何新的和有趣的想法，请不要写新语言，转到C ++委员会并提出加法。<br>
问候。<br>
如果这个答案很有帮助，请覆盖并考虑追随ME-MARIO GALINDO Queralt。</p>
<h3 id="回答-10">回答 10</h3>
<p>你的意思是替换，因为在C ++中写的所有代码中将被锈病写的东西替换？<br>
不。<br>
不是机会。<br>
已经使用C ++创建了太多软件，需要支持，维护，向后兼容et.c.<br>
或许你的意思是专门替换为新项目的选择？这是可能的。但我真的怀疑也是如此。C ++是成熟的。它有很多和许多图书馆。在整个行业中，它是选择的语言。我怀疑生锈可以同样接近硬件。</p>
<h3 id="回答-11">回答 11</h3>
<p>谷歌会留下戈兰并继续生锈，因为铁锈更安全，更快？<br>
几年前，这个问题与新的波浪系统语言销售时，几年前是相关的。从那时起，成为一个网络语言，而RUDR仍然是系统语言，而是一个增加了安全性（和复杂性）。<br>
截至目前，这两种语言都坚定地抓住了他们的地面。<br>
为了回答原始问题 - 谷歌可能永远不会打算以安全和快速的语言创建，而是一种简单而快速的语言，也很快就可以编译。所以他们不会用铁锈取代它，因为他们以某种意想不到的方式达到他们的原始目标。</p>
<h3 id="回答-12">回答 12</h3>
<p>起初我发现这个f<br>
在每天在C / C ++中编程后，我一直在rust中编程rust for tear积极的。<br>
我发现Rust迫使我在C / C ++中学习我慢慢学习的许多事情，然后才能编译我的代码。而不是通过尝试解决赛格虚拟物，而不是学习，调试我的指针混乱等，Rust告诉我在编译时为什么我想做什么可能不是明智的选择。<br>
首先，我发现这种感觉非常严格和尴尬，然而，95％的时间我最终发现编译器完全正确，只是阻止了我在不知不觉中鞭打了一顿饭/线程意大利面食。在我能够在借点击中击球手围绕着我的脑袋之前，我至少花了很多很好的几个月。这些天我发现我很少打击我无法立即解决的编译器错误。当我回到C / C ++时，我也会感到非常自信，因为所有的艰难学习的一对一课程，我回到C / C ++时。<br>
我认为这很可能看到只有只浸入脚趾的人们才能看到很多令人沮丧的评论。我想强调锈病，你可以在几天内学到的那种语言，只是处理硬/技术/好的语言 - 稍后争取的东西。您将被迫立即学习严格的安全性，并且起初可能会感到不舒服。然而，在我自己的经历中，这让我感觉像编译我的代码实际上对我来说意味着什么。我不再畏缩到像我曾经习惯的运行时 - 如果它编译，它就可以了。我曾经没有用过run-time调试器进行锈。<br>
除了安全之外，这里还有一些其他特色IADE坠入爱河： - 代数数据类型 - 模式匹配型推理 - 默认情况下更加功能和富有表现力的风格 - 无标题文件（无奇怪链接错误） - 模块系统导致模块系统 - 模块系统在非常干净的名称空间中 - 一个很棒的标准包管理器，使其非常容易处理依赖性，并在几秒钟内分享自己的libs&ndash;其中一个普通的互联网社区遇到（如果您的开始，请访问Mozillas #rust或/ R / Rust出来并需要任何指针）</p>
<h3 id="回答-13">回答 13</h3>
<p>假设C ++和Rust中的平等竞争力，我似乎​​更容易编写了正确的多线程/并发代码，这些代码是正确的，并在C ++中生锈的不确定行为。从这个意义上讲，它更容易。在试图学习的意义上，不，它更加困难。换句话说，Rust更容易，因为它更难以使某些群体非常困难地发现和讨厌它的错误。所以 - 它更容易，因为做错了东西更难。它更加困难，因为它根本更难，特别是如果你带上你应该完成某事的先入为主的概念，并试图将这些先入为主归咎于你在锈症中的工作方式。<br>
它更容易，因为它更难！</p>
<h3 id="回答-14">回答 14</h3>
<p>首先，出于各种原因生锈<br>
大部分答案都是2017年;我认为比仅使用的更好的答案应该在2021年度所应得的。那些说Rust对大型软件项目仅适用于困惑（或讨论）。<br>
一些嵌入式系统将基于微小的处理器，因为它的生锈没有良好的工具支持，以及那些，我同意 - 只使用C.但是如果您的嵌入式系统使用ARM，则情况可能不同。当然，确保您了解您需要的工具，但如果您可以使用RUDE，则会使用rust更好的原因而不是C.<br>
首先，由于各种原因，Rust是更好的使用。如果您习惯于C而不是生锈，您当然会对此进行对象，因为您与C巨大惯性。但RUDE肯定比C.它具有更好的类型系统。和货物，生锈的构建工具/依赖经理，这是一个更好的经验，而不是在C中使用的任何东西。<br>
在进行嵌入式系统工作时具有良好的宏系统很好，而RUDR的宏观系统远远超过CPP的脑外替代，这被广泛理解为脚踏实地射击自己的好方法。<br>
当然记忆安全是关键创新锈迹带来了主流，为什么对嵌入式系统来说是重要的？想象一百万单位的产品，在未来几个月的电话开始，开始冻结或做错事。召回是多么昂贵，你觉得吗？如果它伤害或杀死某人，怎么办？<br>
这些天（大多数？）嵌入式系统都有多核CPU，Rust有设施，让您轻松地利用它们，并达到它（例如，在安全生锈中无法进行数据比赛）。在C中，你是自己的并发 - 祝你好运，非常小心！<br>
使用Rust，您仍然获得C的小占地面积，并且对如何使用内存的精细控制。您甚至可以获得C级性能，包括在执行过滤/地图/折叠/ etc时。在迭代器上，结果往往比具有许多可变状态的循环更易读，并且易于易于忽略您将在C中写入C.<br>
同样，RURD不支持每个处理器。但在未来十年中，我认为我们将看到牛群的变薄 -  RISC-V和ARM将处于绝大多数嵌入式系统的核心，以及那些人可能会很好的锈。<br>
我在日常工作中使用锈，98％的我所做的。如果在那里有工具支持，我当然会选择嵌入式系统的c（多年来使用的几年）。</p>
<h3 id="回答-15">回答 15</h3>
<p>我们无法对未来编写准确的答案，但我们可以想象如果这可能发生并且如何！<br>
可以生锈替换为OS开发的C或C ++吗？ - →是的，可以<br>
生锈替换为OS开发的C或C ++吗？ - →可能（imho：27％，我会告诉你为什么27％，这不是一个魔法百分比！，我有原因）<br>
如何？<br>
如果发生这种情况，它将是7个阶段过程<br>
（1）许多开发人员了解语言（是）<br>
（2）许多开发商喜欢这种语言（是）<br>
（3）许多开发人员正在使用实际项目中的语言（是）<br>
（4）使用语言开发操作系统（正在进行）<br>
（5）<br>
我们无法对未来编写准确的答案，但我们可以想象如果这可能发生并且如何！<br>
可以生锈替换为OS开发的C或C ++吗？ - →是的，可以<br>
生锈替换为OS开发的C或C ++吗？ - →可能（imho：27％，我会告诉你为什么27％，这不是一个魔法百分比！，我有原因）<br>
如何？<br>
如果发生这种情况，它将是7个阶段过程<br>
（1）许多开发人员了解语言（是）<br>
（2）许多开发商喜欢这种语言（是）<br>
（3）许多开发人员正在使用实际项目中的语言（是）<br>
（4）使用语言开发操作系统（正在进行）<br>
（5）用语言编写的流行操作系统（尚未）<br>
（6）这个领域的大玩家（微软，苹果，谷歌等）切换到语言（尚未成为最困难的步骤）<br>
（7）该语言成为操作系统开发的标准（当您在大学中学到而不是C而不是C，并在此域中找到有关使用它的很多书）。<br>
每个点都获得分数，有些点可以并行！<br>
点（1）得分：5％ -  RUTR评分：3％<br>
点（2）得分：5％ -  RUTR评分：4％<br>
点（3）得分：10％ -  RUTR评分：10％<br>
点（4）得分：20％ - 生锈分数：10％<br>
点（5）得分：20％ -  RUTR评分：0％<br>
点（6）得分：20％ -  RUTR评分：0％<br>
点（7）得分：20％ -  RUTR评分：0％<br>
最后，我想说一些关于铁锈的东西，安全很重要，非常重要，我使用了很多年，写了很多C代码，当你是一个智能程序员，你会带上先进的想法，你会使用语言的高级功能，最后您将获得更高级的错误！<br>
关于编程的常见想法是使用简单的方法来做事，因为在调试代码时需要更聪明，可能是几个月或几年！<br>
但是，我们实际上并不总是做什么，因为生活很短，我们需要利用我们的工具（编程语言）和我们的人类大脑（智能想法）的力量来快速做事！<br>
通过这样做，我花了一些糟糕的日子在现实生活中有很难存在的问题！<br>
像生锈一样的安全语言是一些像我这样的人的重要语言！<br>
但安全不是一切！同时保持良好的表现是不够的！具有高水平的灵活性是不够的！<br>
在编程语言中，我们需要的东西超过这些一般目标<br>
我们需要一个独特，干净而神奇的精神，告诉您您必须为您的下一个项目使用我，或者您正在做一个大错误！</p>
<h3 id="回答-16">回答 16</h3>
<p>如果你有渴望教你C ++的教授，那就抓住这个机会！<br>
C / C ++是大多数其他语言的语言。通过了解C ++的工作原理，您将理解其他更高级别的语言如何在引擎盖下工作。一旦您与C ++相当，每种语言都会更容易学习和使用。即使您没有专业编程，C ++也将强迫您与计算机和编程语言的基本概念开发舒适性。<br>
C / C ++还使用明确的程序员控制内存管理。您必须分配内存，在其中移动，并正确发布（在变量的生命中的正确点）。这是宝贵的知识。<br>
C / C ++使用显式指针。指针通常以更高级别的语言模糊，但它们仍在幕后使用。许多语言怪癖归结为指针。 （Python有几个这样的getchyas）。通过学习C ++，您将免受这些Getchyas的免疫力。他们会给你杜莎。<br>
C ++也是仍然使用“真实”课程的最低级别语言之一。您将在内存管理方面学习OOP / Data Structures。<br>
锈病很酷，但Mozilla声称它被设计为内存更安全 - 这在现实世界中是伟大的（程序员的一半不知道如何参加指针），但是当你学习时，起飞训练轮并在比特中下降和脏污。除了！您也可以在C ++中进行线程或多流程编程！如果您知道C / C ++，则锈将容易拾取，但相反的顺序将不那么容易。</p>
<h3 id="回答-17">回答 17</h3>
<p>C ++是有史以来最薄弱的语言之一。考虑一下你可能会这样做的一切。这可以分为两个进一步的子集那些你想做的事情以及你不想做的事情。 （当然，您可以进一步符合您可能偶尔想要做的事情以及您从未想要发生的事情。）<br>
许多人陷入陷阱，即一种让您尽情尽情的语言必须强大（而且他们仍然是C ++守护员，每当有人考虑一个替代或敢于指出什么是乱七八糟的东西）。但它是因为它允许你（或更糟糕的是）做你不想要的事情，使C ++真的很弱。这是当今计算 - 安全性最大问题的基础。密切相关是正确的。 C和C ++选择忽略20世纪60年代的进展，因为他们没有被视为重要的是（您可以完全控制主要用于科学目的，或主要统治的专用业务目的IBM）。<br>
我们知道系统与其约束的产品以及权限可能性。人们错误地将基于约束的系统视为限制性和更糟糕的“反自由”。事实上，它是考虑你可以看到更多的限制，因为你可以看到不应该在那里的无效约束。在较弱的系统中，这种无效的约束通常隐含地内置，而不是考虑。我们现在需要这种复杂的思考，而不是以往任何时候，而不是天真，只是让每个人都做任何想法。<br>
在一个低系统级别，您偶尔需要做的事情，就像实现自动内存管理和垃圾收集，或将代码段加载到内存中，从而将内存视为平坦的阵列，而不是应用视图作为结构化对象的图形。结构界限的非结构化交叉（指针给您）是破坏系统的基础（意外地和故意）。 C和C ++可怕地混淆这些观点。某些系统级操作只能在OS中的单个位置进行，并且从未允许在其他地方允许。支持更高级别的结构应内置于最低架构级别中，而不是顶部的软件层（无论如何都要效率低）。 （Bob Barton建造了世界看法，进入了他令人惊叹的休止架构。）<br>
问题是C，C ++的注意力很少被给予逻辑上一致的系统 - 因此正确和安全。 C，特别是C ++是这种不安的系统和应用程序编程混合。有一次单一语言做一切，所以你只需要学习一种语言似乎是一个好主意。但它已成为历史上最糟糕的想法之一。<br>
也许Rust在某种程度上解决了这些问题，但它仍然具有非常古老的基于C的语法。我们现在应该通过设计基于文本和编辑器在系统中显而易见的编辑结构的语言来更好地完成。 RUDE仍然具有公开实现细节的丑陋（）呼叫运算符（您真的不需要知道某些东西是否是计算结果或存储的结果，并且区分除去灵活性）。<br>
我们在21世纪所需要的是21世纪的思维，而不是由20世纪60年代的古代语言限制在概念和实践中。<br>
<a href="http://ianjoyner.name/c++.html">http://ianjoyner.name/c++.html</a>.</p>
<h3 id="回答-18">回答 18</h3>
<p>因此，这些模型不一定会给你任何优势来写入生锈，因为算法本身是非常简单的<br>
对于大多数零件自动驾驶汽车铰接在机器 - 学习衍生模型的质量上，这是基于训练数据的（以大大超薄）结晶的响应，类似于您自己的电机反射如何根据您的经验结晶学习虽然它们可以通过更多数据逐步更新，但它们不会立即适应此刻&hellip;&hellip;您输入了您所拥有的反射的情况，而不是您想要的。<br>
因此，这些模型不一定会给你一个有利的东西，因为算法本身非常简单，如果他们在铁锈的方式搞砸了，那么模型可能不会完成训练，所以它可能不会完成培训不会真的存在吗？您仍然可以在rust中编写贫困的算法，使用错误的数学，错误地解释数据，或者绘制错误的结论，介意，由于人为错误，它们只会没有空指针错误和其他内存访问问题。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
