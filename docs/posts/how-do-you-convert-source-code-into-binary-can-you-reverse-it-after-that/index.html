<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>如何将源代码转换为二进制文件？在那之后，你能反转吗？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？ 回答 1 您运行编译器以生成二进制代码。此过程无损，因此您可以轻松地更改为源文件并再次尝试
回答 2 您使用翻译器将源转换为二进制（目标）。翻译是计算中的一个主要话题。基础是，所有的“图灵完整”语言都具有相同的能力和可以计算的限制。这是计算的最终，超越我们必须具有智能计算机的智能。
鉴于没有任何语言或计算机可以做的并且没有魔法指导或语言构造，我们可以在理论上从任何东西转化为其他任何东西。这意味着当我们从源转移到目标时，我们应该能够反转它。在实践中，这不是那么简单。
源程序意味着人类可读。我们将源代码转换为二进制翻译编译器。程序员选择呈现的名称和ID。计算机不关心，所以名称被删除，也许用更加神秘的东西如1美元，2美元（这就是为什么ID中的标志的语言如此糟糕），或者它们被绝对或相对地址所取代（相对地址给出了一个系统灵活性，因为程序未固定到位置）。
如果我们想逆转翻译，我们已经丢失了有意义的名称，并且机械（程序）翻译将无法恢复。即使是一个读取这样的逆向的人也会发现很难猜测意图是什么。
现在一些翻译系统可能包括目标中的原始名称，以便像调试和程序转储一样。
在高级语言之间翻译也难以保存语义，因为它们都有不同的范式。即使他们基于类似的概念，它们仍然难以翻译。我曾经在艾菲尔赛到Java翻译（不是我的想法）上工作过，但结果真的并不令人满意（因为Java没有Mi，也许Java到埃菲尔可能会更容易，但是埃菲尔不允许一些东西的东西像xf：= ，它是可怜的oo和打破封装）。
这就是为什么低级机器具有非常一般但非常小的步骤，以便高级语言可以很容易地转换为二进制。
回答 3 你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要数月才能改变
你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要几个月的时间来反转它足以可以理解一个复杂的程序可能不值得，除了核心部分。甚至所以曾经尝试过它必须是某种天才甚至尝试。
回答 4 如果您使用编译编程语言，通常称为编译，则将源代码转换为二进制文件。编译由一个名为Compiler的程序完成。
较低级别的编程语言通常称为汇编语言，并用汇编语言编写的文本通常由一个名为ASSEmbler的代码处理，该代码产生二进制代码。
与John Thorton的答案相反，我会说这个过程绝对是破坏性的，即，你不能从二进制获取原始源代码 - 无论如何。这甚至适用于汇编代码。让我通过比喻的比喻来解释这一点。 2 * 3 &#43; 8-0 = 142 * 3 &#43; 8-0 = 14您是否可以根据以下两个事实重新构建原始方程式？
如果您尝试重新构建原始公式，您最终可以使用：2 * 1 &#43; 26-14 = 142 * 1 &#43; 26-14 = 14。你看到了挑战吗？编译失去了像变量名称（除非您有一些外部/全球可访问的变量），代码逻辑流（因为代码和注册优化，折叠和折叠循环等） - 它基本上挂钩了您的代码。
所以没有，你无法扭转编译过程。 （除非您具有非常具体的情况和非常简单的未优化代码。）
回答 5 一般而言，您将代码打破到解析树中&hellip;&hellip;例如：
a = 2 * b &#43; c;">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？" />
<meta property="og:description" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？ 回答 1 您运行编译器以生成二进制代码。此过程无损，因此您可以轻松地更改为源文件并再次尝试
回答 2 您使用翻译器将源转换为二进制（目标）。翻译是计算中的一个主要话题。基础是，所有的“图灵完整”语言都具有相同的能力和可以计算的限制。这是计算的最终，超越我们必须具有智能计算机的智能。
鉴于没有任何语言或计算机可以做的并且没有魔法指导或语言构造，我们可以在理论上从任何东西转化为其他任何东西。这意味着当我们从源转移到目标时，我们应该能够反转它。在实践中，这不是那么简单。
源程序意味着人类可读。我们将源代码转换为二进制翻译编译器。程序员选择呈现的名称和ID。计算机不关心，所以名称被删除，也许用更加神秘的东西如1美元，2美元（这就是为什么ID中的标志的语言如此糟糕），或者它们被绝对或相对地址所取代（相对地址给出了一个系统灵活性，因为程序未固定到位置）。
如果我们想逆转翻译，我们已经丢失了有意义的名称，并且机械（程序）翻译将无法恢复。即使是一个读取这样的逆向的人也会发现很难猜测意图是什么。
现在一些翻译系统可能包括目标中的原始名称，以便像调试和程序转储一样。
在高级语言之间翻译也难以保存语义，因为它们都有不同的范式。即使他们基于类似的概念，它们仍然难以翻译。我曾经在艾菲尔赛到Java翻译（不是我的想法）上工作过，但结果真的并不令人满意（因为Java没有Mi，也许Java到埃菲尔可能会更容易，但是埃菲尔不允许一些东西的东西像xf：= ，它是可怜的oo和打破封装）。
这就是为什么低级机器具有非常一般但非常小的步骤，以便高级语言可以很容易地转换为二进制。
回答 3 你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要数月才能改变
你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要几个月的时间来反转它足以可以理解一个复杂的程序可能不值得，除了核心部分。甚至所以曾经尝试过它必须是某种天才甚至尝试。
回答 4 如果您使用编译编程语言，通常称为编译，则将源代码转换为二进制文件。编译由一个名为Compiler的程序完成。
较低级别的编程语言通常称为汇编语言，并用汇编语言编写的文本通常由一个名为ASSEmbler的代码处理，该代码产生二进制代码。
与John Thorton的答案相反，我会说这个过程绝对是破坏性的，即，你不能从二进制获取原始源代码 - 无论如何。这甚至适用于汇编代码。让我通过比喻的比喻来解释这一点。 2 * 3 &#43; 8-0 = 142 * 3 &#43; 8-0 = 14您是否可以根据以下两个事实重新构建原始方程式？
如果您尝试重新构建原始公式，您最终可以使用：2 * 1 &#43; 26-14 = 142 * 1 &#43; 26-14 = 14。你看到了挑战吗？编译失去了像变量名称（除非您有一些外部/全球可访问的变量），代码逻辑流（因为代码和注册优化，折叠和折叠循环等） - 它基本上挂钩了您的代码。
所以没有，你无法扭转编译过程。 （除非您具有非常具体的情况和非常简单的未优化代码。）
回答 5 一般而言，您将代码打破到解析树中&hellip;&hellip;例如：
a = 2 * b &#43; c;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/how-do-you-convert-source-code-into-binary-can-you-reverse-it-after-that/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:22+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:22+08:00" />

<meta itemprop="name" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？">
<meta itemprop="description" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？ 回答 1 您运行编译器以生成二进制代码。此过程无损，因此您可以轻松地更改为源文件并再次尝试
回答 2 您使用翻译器将源转换为二进制（目标）。翻译是计算中的一个主要话题。基础是，所有的“图灵完整”语言都具有相同的能力和可以计算的限制。这是计算的最终，超越我们必须具有智能计算机的智能。
鉴于没有任何语言或计算机可以做的并且没有魔法指导或语言构造，我们可以在理论上从任何东西转化为其他任何东西。这意味着当我们从源转移到目标时，我们应该能够反转它。在实践中，这不是那么简单。
源程序意味着人类可读。我们将源代码转换为二进制翻译编译器。程序员选择呈现的名称和ID。计算机不关心，所以名称被删除，也许用更加神秘的东西如1美元，2美元（这就是为什么ID中的标志的语言如此糟糕），或者它们被绝对或相对地址所取代（相对地址给出了一个系统灵活性，因为程序未固定到位置）。
如果我们想逆转翻译，我们已经丢失了有意义的名称，并且机械（程序）翻译将无法恢复。即使是一个读取这样的逆向的人也会发现很难猜测意图是什么。
现在一些翻译系统可能包括目标中的原始名称，以便像调试和程序转储一样。
在高级语言之间翻译也难以保存语义，因为它们都有不同的范式。即使他们基于类似的概念，它们仍然难以翻译。我曾经在艾菲尔赛到Java翻译（不是我的想法）上工作过，但结果真的并不令人满意（因为Java没有Mi，也许Java到埃菲尔可能会更容易，但是埃菲尔不允许一些东西的东西像xf：= ，它是可怜的oo和打破封装）。
这就是为什么低级机器具有非常一般但非常小的步骤，以便高级语言可以很容易地转换为二进制。
回答 3 你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要数月才能改变
你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要几个月的时间来反转它足以可以理解一个复杂的程序可能不值得，除了核心部分。甚至所以曾经尝试过它必须是某种天才甚至尝试。
回答 4 如果您使用编译编程语言，通常称为编译，则将源代码转换为二进制文件。编译由一个名为Compiler的程序完成。
较低级别的编程语言通常称为汇编语言，并用汇编语言编写的文本通常由一个名为ASSEmbler的代码处理，该代码产生二进制代码。
与John Thorton的答案相反，我会说这个过程绝对是破坏性的，即，你不能从二进制获取原始源代码 - 无论如何。这甚至适用于汇编代码。让我通过比喻的比喻来解释这一点。 2 * 3 &#43; 8-0 = 142 * 3 &#43; 8-0 = 14您是否可以根据以下两个事实重新构建原始方程式？
如果您尝试重新构建原始公式，您最终可以使用：2 * 1 &#43; 26-14 = 142 * 1 &#43; 26-14 = 14。你看到了挑战吗？编译失去了像变量名称（除非您有一些外部/全球可访问的变量），代码逻辑流（因为代码和注册优化，折叠和折叠循环等） - 它基本上挂钩了您的代码。
所以没有，你无法扭转编译过程。 （除非您具有非常具体的情况和非常简单的未优化代码。）
回答 5 一般而言，您将代码打破到解析树中&hellip;&hellip;例如：
a = 2 * b &#43; c;"><meta itemprop="datePublished" content="2022-01-23T22:08:22+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:22+08:00" />
<meta itemprop="wordCount" content="77">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？"/>
<meta name="twitter:description" content="如何将源代码转换为二进制文件？在那之后，你能反转吗？ 回答 1 您运行编译器以生成二进制代码。此过程无损，因此您可以轻松地更改为源文件并再次尝试
回答 2 您使用翻译器将源转换为二进制（目标）。翻译是计算中的一个主要话题。基础是，所有的“图灵完整”语言都具有相同的能力和可以计算的限制。这是计算的最终，超越我们必须具有智能计算机的智能。
鉴于没有任何语言或计算机可以做的并且没有魔法指导或语言构造，我们可以在理论上从任何东西转化为其他任何东西。这意味着当我们从源转移到目标时，我们应该能够反转它。在实践中，这不是那么简单。
源程序意味着人类可读。我们将源代码转换为二进制翻译编译器。程序员选择呈现的名称和ID。计算机不关心，所以名称被删除，也许用更加神秘的东西如1美元，2美元（这就是为什么ID中的标志的语言如此糟糕），或者它们被绝对或相对地址所取代（相对地址给出了一个系统灵活性，因为程序未固定到位置）。
如果我们想逆转翻译，我们已经丢失了有意义的名称，并且机械（程序）翻译将无法恢复。即使是一个读取这样的逆向的人也会发现很难猜测意图是什么。
现在一些翻译系统可能包括目标中的原始名称，以便像调试和程序转储一样。
在高级语言之间翻译也难以保存语义，因为它们都有不同的范式。即使他们基于类似的概念，它们仍然难以翻译。我曾经在艾菲尔赛到Java翻译（不是我的想法）上工作过，但结果真的并不令人满意（因为Java没有Mi，也许Java到埃菲尔可能会更容易，但是埃菲尔不允许一些东西的东西像xf：= ，它是可怜的oo和打破封装）。
这就是为什么低级机器具有非常一般但非常小的步骤，以便高级语言可以很容易地转换为二进制。
回答 3 你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要数月才能改变
你问的第一个只是编译成二进制（有几个步骤）。
但第二个不能完成。
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。
一个简单的程序（非常简单）可能需要几个月的时间来反转它足以可以理解一个复杂的程序可能不值得，除了核心部分。甚至所以曾经尝试过它必须是某种天才甚至尝试。
回答 4 如果您使用编译编程语言，通常称为编译，则将源代码转换为二进制文件。编译由一个名为Compiler的程序完成。
较低级别的编程语言通常称为汇编语言，并用汇编语言编写的文本通常由一个名为ASSEmbler的代码处理，该代码产生二进制代码。
与John Thorton的答案相反，我会说这个过程绝对是破坏性的，即，你不能从二进制获取原始源代码 - 无论如何。这甚至适用于汇编代码。让我通过比喻的比喻来解释这一点。 2 * 3 &#43; 8-0 = 142 * 3 &#43; 8-0 = 14您是否可以根据以下两个事实重新构建原始方程式？
如果您尝试重新构建原始公式，您最终可以使用：2 * 1 &#43; 26-14 = 142 * 1 &#43; 26-14 = 14。你看到了挑战吗？编译失去了像变量名称（除非您有一些外部/全球可访问的变量），代码逻辑流（因为代码和注册优化，折叠和折叠循环等） - 它基本上挂钩了您的代码。
所以没有，你无法扭转编译过程。 （除非您具有非常具体的情况和非常简单的未优化代码。）
回答 5 一般而言，您将代码打破到解析树中&hellip;&hellip;例如：
a = 2 * b &#43; c;"/>

      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-3W09QM57NF', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
	
  </head>

  <body class="ma0 avenir bg-near-white production">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">如何将源代码转换为二进制文件？在那之后，你能反转吗？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:22+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="如何将源代码转换为二进制文件在那之后你能反转吗">如何将源代码转换为二进制文件？在那之后，你能反转吗？</h2>
<h3 id="回答-1">回答 1</h3>
<p>您运行编译器以生成二进制代码。此过程无损，因此您可以轻松地更改为源文件并再次尝试</p>
<h3 id="回答-2">回答 2</h3>
<p>您使用翻译器将源转换为二进制（目标）。翻译是计算中的一个主要话题。基础是，所有的“图灵完整”语言都具有相同的能力和可以计算的限制。这是计算的最终，超越我们必须具有智能计算机的智能。<br>
鉴于没有任何语言或计算机可以做的并且没有魔法指导或语言构造，我们可以在理论上从任何东西转化为其他任何东西。这意味着当我们从源转移到目标时，我们应该能够反转它。在实践中，这不是那么简单。<br>
源程序意味着人类可读。我们将源代码转换为二进制翻译编译器。程序员选择呈现的名称和ID。计算机不关心，所以名称被删除，也许用更加神秘的东西如1美元，2美元（这就是为什么ID中的标志的语言如此糟糕），或者它们被绝对或相对地址所取代（相对地址给出了一个系统灵活性，因为程序未固定到位置）。<br>
如果我们想逆转翻译，我们已经丢失了有意义的名称，并且机械（程序）翻译将无法恢复。即使是一个读取这样的逆向的人也会发现很难猜测意图是什么。<br>
现在一些翻译系统可能包括目标中的原始名称，以便像调试和程序转储一样。<br>
在高级语言之间翻译也难以保存语义，因为它们都有不同的范式。即使他们基于类似的概念，它们仍然难以翻译。我曾经在艾菲尔赛到Java翻译（不是我的想法）上工作过，但结果真的并不令人满意（因为Java没有Mi，也许Java到埃菲尔可能会更容易，但是埃菲尔不允许一些东西的东西像xf：= <!-- raw HTML omitted -->，它是可怜的oo和打破封装）。<br>
这就是为什么低级机器具有非常一般但非常小的步骤，以便高级语言可以很容易地转换为二进制。</p>
<h3 id="回答-3">回答 3</h3>
<p>你问的第一个只是编译成二进制（有几个步骤）。<br>
但第二个不能完成。<br>
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。<br>
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。<br>
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。<br>
一个简单的程序（非常简单）可能需要数月才能改变<br>
你问的第一个只是编译成二进制（有几个步骤）。<br>
但第二个不能完成。<br>
当您编写它的东西时，它可以像切割三个并用它制作日志，你就不能重新制止三个。<br>
您可能会获得一般的想法，但即使您制作类似于原始程序的内容，所有变量名称和其他事情将会丢失。<br>
因此，如果该程序有几个抽象，几乎不可能理解，因为除了所有奇怪的部分，你都不知道什么是什么。<br>
一个简单的程序（非常简单）可能需要几个月的时间来反转它足以可以理解一个复杂的程序可能不值得，除了核心部分。甚至所以曾经尝试过它必须是某种天才甚至尝试。</p>
<h3 id="回答-4">回答 4</h3>
<p>如果您使用编译编程语言，通常称为编译，则将源代码转换为二进制文件。编译由一个名为Compiler的程序完成。<br>
较低级别的编程语言通常称为汇编语言，并用汇编语言编写的文本通常由一个名为ASSEmbler的代码处理，该代码产生二进制代码。<br>
与John Thorton的答案相反，我会说这个过程绝对是破坏性的，即，你不能从二进制获取原始源代码 - 无论如何。这甚至适用于汇编代码。让我通过比喻的比喻来解释这一点。 2 * 3 + 8-0 = 142 * 3 + 8-0 = 14您是否可以根据以下两个事实重新构建原始方程式？<br>
如果您尝试重新构建原始公式，您最终可以使用：2 * 1 + 26-14 = 142 * 1 + 26-14 = 14。你看到了挑战吗？编译失去了像变量名称（除非您有一些外部/全球可访问的变量），代码逻辑流（因为代码和注册优化，折叠和折叠循环等） - 它基本上挂钩了您的代码。<br>
所以没有，你无法扭转编译过程。 （除非您具有非常具体的情况和非常简单的未优化代码。）</p>
<h3 id="回答-5">回答 5</h3>
<p>一般而言，您将代码打破到解析树中&hellip;&hellip;例如：<br>
a = 2 * b + c;<br>
成为：</p>
<!-- raw HTML omitted -->
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
