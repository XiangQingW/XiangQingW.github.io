<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？ 回答 1 我假设你在谈论比特币。
您可以将256位散列作为数字解释。通过要求下一个块具有低于一定值的散列来调整当前难度。较小的数字在其前导数字中有更多的零。
所以，例如，如果我说将我的名字命名为1000，然后将其表示为32位整数，它将有很多初始零。就是这样，他们并不意味着什么比这更重要。
如果您尝试发出一个不会遵守所有规则的块（包括查找与当前难度不一致的散列），那么另一个节点将拒绝它。
回答 2 散列用于创建文档或其他数据块的代表性摘要，该块是固定大小的，并且如果在原始数据中更改了任何位或比特的组合，则会更改（急剧！）。这用于（例如示例）用于在网络上发送数据包的校验和，以确保它们以其剩余的相同内容到达。
一个加密保护的哈希标志着，第三方希望恶意改变数据，以这样的方式仍然是相同的;这很重要，因为加密签名基本上是用公钥加密加密的哈希，所以如果您可以保留哈希，则可以声称您在发起者或公平的证人签署了一份文件，当实际上是一个不同的文件一个签名。
对哈希的攻击的严重程度取决于您如何强迫碰撞。最严重的是您可以创建一个您希望匹配的哈希的任意文档。第二个最严重的是您可以生成两个将提供相同哈希的文档，但无法提前确定哈希将是什么（即，您必须并行改变两个文件以实现这一目标）
在后一种情况下，您必须说服受害者签署其中一个文件，而无需以任何方式更改它，因此您可以申请第二个文件是实际签名的文件。
回答 3 哈希基本上是一种单向功能，在其中输入可变长度的输入并获得固定长度的唯一输出。并且随机数基本上意味着一次使用的数字，现在在比特币区块链中是一个值，它是您在块前面添加的值，以匹配比特币中的当前难度是块的哈希散列开始时的一定数量的零。所以你收集你的数据并获得一个固定的哈希现在，您必须添加一个annce值，直到您等于或更接近难度级别。
在Ethereum中，Nonce是从给定地址发送的事务数。随着该地址的交易数量增加，与地址相关的随机值增加。
回答 4 作为领先的零的难度是一种错误的过度过度简化，对难度如何工作，我在这里的其他答案中解释了这一点。
但是，是的，如果一个块超出难度要求，它被接受。困难只是所需的最低质量。
回答 5 什么是区块链散列？
哈希是由散列算法产生的数据的独特指纹。就像每个人都有一个独特的指纹一样，每一条数据都有自己独特的哈希。
当事务被提交到区块链时，使用散列算法散列。然后使用得到的散列来验证交易是否有效。如果哈希不符合BlockChain协议指定的标准，则交易将被拒绝。
哈希以一定数量的零点开始的要求被称为零字节规则。大多数区块链要求哈希以一定数量的零点开始，以确保它们有效。但是，这并不总是如此，并且取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的前导零数量的变化。
这是一个常见的误解，碉堡哈希需要从17个零点开始。这源于在使用SHA-256哈希函数的比特币中，有效事务将使其Merkle Root算法逐出到低于或等于当前目标阈值的值。这意味着，这意味着平均一半的尝试必须成功，并且在此过程中，它们将产生大约34个零字节的字符串。
散列的最大可能数量为80，因此在参考目标哈希的开头时，它将描述为需要18个零点的比特币协议规则。实际上，在验证时，领先的17很重要，最后一个是序列的简单延续。
实际上，在那个零中开始一个区块链条是不必要的，这取决于实现的需要程度。散列中所需的零点越多，任何给定交易的哈希成本就越大。如果有5个Zeroes而不是17，那么所有尝试都会失败，这意味着只需尝试一半的哈希，而且反过来将需要两倍，只需计算两倍，每次尝试都需要散列硬件的四倍由于每次尝试都会产生两倍的碰撞（或“非唯一”结果）。
比特币网络自动调整其目标阈值，以确保每10分钟大约挖掘新块。它以17 zeroes开头的原因是，因为这种值会在每4年结合挖掘奖励的减半时导致正确的平均块时间。如果哈希所需的零数是改变，则目标阈值也会如此，因此平均块时间也会发生变化。
为了使事情保持一致，即使可以改变底层算法，哈希开始时的零点的数量需要保持静止。这就是为什么以非散列算法（SHA-3）而不是比特币的为什么，仍然需要它的哈希以20个零点开始。其他算法可能需要不同数量的前导零，以便产生具有特定数量的零字节的散列。
BlockChain哈希以一定数量的零点开始的要求不仅仅是散列算法的函数，还不仅仅是散列数据的函数。使用多个散列算法可以进一步复杂化东西，因为每个算法可能具有对前导零的自己的要求。例如，Etereum使用的Keccak算法要求哈希以至少6个零开始。
因此，虽然大多数区块链确实需要哈希以一定数量的零点开始，但情况并非总是如此。这取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的零数量的变化。
回答 6 它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图何时何
它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图操纵数据（重写历史记录）。这种机制使块状不变。
回答 7 限制参数：0 ^ 0的限制参数都不是valivarguments。在点PIS处采用函数F的限制的唯一时间是在P处连续时计算f（p）的有效方法。 functionf（x，y）= x ^ y在p点p =（0,0）中不连续.thus，限制参数没有0 ^ 0的轴承，这是来自这些论点的一个取消的唯一一个，就是作者忽略或不了解限制与连续性之间的关系。
对于那些认为限制争论的人是建立牵引的唯一方法，请记住，在19世纪起源之前，在这些局限性起来之前已经是1的0 ^ 0。有许多有效的方法（无限制）以确定0 ^ 0的值。在最简单的形式写入时，该值直接从定义中。它可以通过坚持符合符合符合的一致性来导出，或者可以源自广泛接受的数学定理，例如二项式定理等。人们经历不必要的麻烦以避免定义0 ^ 0。例如，递归定义从x ^ 1 = x而不是从x ^ 0开始的唯一原因= 1是毫无根据的恐惧。同样，唯一的原因给出递归定义（而不是更短的： x ^ n是x的n拷贝的乘积，再次努力避免0 ^ 0。最终，这些努力是徒劳的，因为仍然有许多定理通过裂缝，即，仍然意味着0 ^ 0 = 1。当然，这种感知的问题不是一个实际问题，因为数学是非常一致的，这意味着每个暗示0 ^ 0的值的每个定理和每个一致的参数将始终意味着相同的值。">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？" />
<meta property="og:description" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？ 回答 1 我假设你在谈论比特币。
您可以将256位散列作为数字解释。通过要求下一个块具有低于一定值的散列来调整当前难度。较小的数字在其前导数字中有更多的零。
所以，例如，如果我说将我的名字命名为1000，然后将其表示为32位整数，它将有很多初始零。就是这样，他们并不意味着什么比这更重要。
如果您尝试发出一个不会遵守所有规则的块（包括查找与当前难度不一致的散列），那么另一个节点将拒绝它。
回答 2 散列用于创建文档或其他数据块的代表性摘要，该块是固定大小的，并且如果在原始数据中更改了任何位或比特的组合，则会更改（急剧！）。这用于（例如示例）用于在网络上发送数据包的校验和，以确保它们以其剩余的相同内容到达。
一个加密保护的哈希标志着，第三方希望恶意改变数据，以这样的方式仍然是相同的;这很重要，因为加密签名基本上是用公钥加密加密的哈希，所以如果您可以保留哈希，则可以声称您在发起者或公平的证人签署了一份文件，当实际上是一个不同的文件一个签名。
对哈希的攻击的严重程度取决于您如何强迫碰撞。最严重的是您可以创建一个您希望匹配的哈希的任意文档。第二个最严重的是您可以生成两个将提供相同哈希的文档，但无法提前确定哈希将是什么（即，您必须并行改变两个文件以实现这一目标）
在后一种情况下，您必须说服受害者签署其中一个文件，而无需以任何方式更改它，因此您可以申请第二个文件是实际签名的文件。
回答 3 哈希基本上是一种单向功能，在其中输入可变长度的输入并获得固定长度的唯一输出。并且随机数基本上意味着一次使用的数字，现在在比特币区块链中是一个值，它是您在块前面添加的值，以匹配比特币中的当前难度是块的哈希散列开始时的一定数量的零。所以你收集你的数据并获得一个固定的哈希现在，您必须添加一个annce值，直到您等于或更接近难度级别。
在Ethereum中，Nonce是从给定地址发送的事务数。随着该地址的交易数量增加，与地址相关的随机值增加。
回答 4 作为领先的零的难度是一种错误的过度过度简化，对难度如何工作，我在这里的其他答案中解释了这一点。
但是，是的，如果一个块超出难度要求，它被接受。困难只是所需的最低质量。
回答 5 什么是区块链散列？
哈希是由散列算法产生的数据的独特指纹。就像每个人都有一个独特的指纹一样，每一条数据都有自己独特的哈希。
当事务被提交到区块链时，使用散列算法散列。然后使用得到的散列来验证交易是否有效。如果哈希不符合BlockChain协议指定的标准，则交易将被拒绝。
哈希以一定数量的零点开始的要求被称为零字节规则。大多数区块链要求哈希以一定数量的零点开始，以确保它们有效。但是，这并不总是如此，并且取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的前导零数量的变化。
这是一个常见的误解，碉堡哈希需要从17个零点开始。这源于在使用SHA-256哈希函数的比特币中，有效事务将使其Merkle Root算法逐出到低于或等于当前目标阈值的值。这意味着，这意味着平均一半的尝试必须成功，并且在此过程中，它们将产生大约34个零字节的字符串。
散列的最大可能数量为80，因此在参考目标哈希的开头时，它将描述为需要18个零点的比特币协议规则。实际上，在验证时，领先的17很重要，最后一个是序列的简单延续。
实际上，在那个零中开始一个区块链条是不必要的，这取决于实现的需要程度。散列中所需的零点越多，任何给定交易的哈希成本就越大。如果有5个Zeroes而不是17，那么所有尝试都会失败，这意味着只需尝试一半的哈希，而且反过来将需要两倍，只需计算两倍，每次尝试都需要散列硬件的四倍由于每次尝试都会产生两倍的碰撞（或“非唯一”结果）。
比特币网络自动调整其目标阈值，以确保每10分钟大约挖掘新块。它以17 zeroes开头的原因是，因为这种值会在每4年结合挖掘奖励的减半时导致正确的平均块时间。如果哈希所需的零数是改变，则目标阈值也会如此，因此平均块时间也会发生变化。
为了使事情保持一致，即使可以改变底层算法，哈希开始时的零点的数量需要保持静止。这就是为什么以非散列算法（SHA-3）而不是比特币的为什么，仍然需要它的哈希以20个零点开始。其他算法可能需要不同数量的前导零，以便产生具有特定数量的零字节的散列。
BlockChain哈希以一定数量的零点开始的要求不仅仅是散列算法的函数，还不仅仅是散列数据的函数。使用多个散列算法可以进一步复杂化东西，因为每个算法可能具有对前导零的自己的要求。例如，Etereum使用的Keccak算法要求哈希以至少6个零开始。
因此，虽然大多数区块链确实需要哈希以一定数量的零点开始，但情况并非总是如此。这取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的零数量的变化。
回答 6 它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图何时何
它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图操纵数据（重写历史记录）。这种机制使块状不变。
回答 7 限制参数：0 ^ 0的限制参数都不是valivarguments。在点PIS处采用函数F的限制的唯一时间是在P处连续时计算f（p）的有效方法。 functionf（x，y）= x ^ y在p点p =（0,0）中不连续.thus，限制参数没有0 ^ 0的轴承，这是来自这些论点的一个取消的唯一一个，就是作者忽略或不了解限制与连续性之间的关系。
对于那些认为限制争论的人是建立牵引的唯一方法，请记住，在19世纪起源之前，在这些局限性起来之前已经是1的0 ^ 0。有许多有效的方法（无限制）以确定0 ^ 0的值。在最简单的形式写入时，该值直接从定义中。它可以通过坚持符合符合符合的一致性来导出，或者可以源自广泛接受的数学定理，例如二项式定理等。人们经历不必要的麻烦以避免定义0 ^ 0。例如，递归定义从x ^ 1 = x而不是从x ^ 0开始的唯一原因= 1是毫无根据的恐惧。同样，唯一的原因给出递归定义（而不是更短的： x ^ n是x的n拷贝的乘积，再次努力避免0 ^ 0。最终，这些努力是徒劳的，因为仍然有许多定理通过裂缝，即，仍然意味着0 ^ 0 = 1。当然，这种感知的问题不是一个实际问题，因为数学是非常一致的，这意味着每个暗示0 ^ 0的值的每个定理和每个一致的参数将始终意味着相同的值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/why-does-the-block-hash-have-to-be-started-with-lots-of-zero-to-be-verified-what-does-those-zero-mean/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:28+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:28+08:00" />

<meta itemprop="name" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？">
<meta itemprop="description" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？ 回答 1 我假设你在谈论比特币。
您可以将256位散列作为数字解释。通过要求下一个块具有低于一定值的散列来调整当前难度。较小的数字在其前导数字中有更多的零。
所以，例如，如果我说将我的名字命名为1000，然后将其表示为32位整数，它将有很多初始零。就是这样，他们并不意味着什么比这更重要。
如果您尝试发出一个不会遵守所有规则的块（包括查找与当前难度不一致的散列），那么另一个节点将拒绝它。
回答 2 散列用于创建文档或其他数据块的代表性摘要，该块是固定大小的，并且如果在原始数据中更改了任何位或比特的组合，则会更改（急剧！）。这用于（例如示例）用于在网络上发送数据包的校验和，以确保它们以其剩余的相同内容到达。
一个加密保护的哈希标志着，第三方希望恶意改变数据，以这样的方式仍然是相同的;这很重要，因为加密签名基本上是用公钥加密加密的哈希，所以如果您可以保留哈希，则可以声称您在发起者或公平的证人签署了一份文件，当实际上是一个不同的文件一个签名。
对哈希的攻击的严重程度取决于您如何强迫碰撞。最严重的是您可以创建一个您希望匹配的哈希的任意文档。第二个最严重的是您可以生成两个将提供相同哈希的文档，但无法提前确定哈希将是什么（即，您必须并行改变两个文件以实现这一目标）
在后一种情况下，您必须说服受害者签署其中一个文件，而无需以任何方式更改它，因此您可以申请第二个文件是实际签名的文件。
回答 3 哈希基本上是一种单向功能，在其中输入可变长度的输入并获得固定长度的唯一输出。并且随机数基本上意味着一次使用的数字，现在在比特币区块链中是一个值，它是您在块前面添加的值，以匹配比特币中的当前难度是块的哈希散列开始时的一定数量的零。所以你收集你的数据并获得一个固定的哈希现在，您必须添加一个annce值，直到您等于或更接近难度级别。
在Ethereum中，Nonce是从给定地址发送的事务数。随着该地址的交易数量增加，与地址相关的随机值增加。
回答 4 作为领先的零的难度是一种错误的过度过度简化，对难度如何工作，我在这里的其他答案中解释了这一点。
但是，是的，如果一个块超出难度要求，它被接受。困难只是所需的最低质量。
回答 5 什么是区块链散列？
哈希是由散列算法产生的数据的独特指纹。就像每个人都有一个独特的指纹一样，每一条数据都有自己独特的哈希。
当事务被提交到区块链时，使用散列算法散列。然后使用得到的散列来验证交易是否有效。如果哈希不符合BlockChain协议指定的标准，则交易将被拒绝。
哈希以一定数量的零点开始的要求被称为零字节规则。大多数区块链要求哈希以一定数量的零点开始，以确保它们有效。但是，这并不总是如此，并且取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的前导零数量的变化。
这是一个常见的误解，碉堡哈希需要从17个零点开始。这源于在使用SHA-256哈希函数的比特币中，有效事务将使其Merkle Root算法逐出到低于或等于当前目标阈值的值。这意味着，这意味着平均一半的尝试必须成功，并且在此过程中，它们将产生大约34个零字节的字符串。
散列的最大可能数量为80，因此在参考目标哈希的开头时，它将描述为需要18个零点的比特币协议规则。实际上，在验证时，领先的17很重要，最后一个是序列的简单延续。
实际上，在那个零中开始一个区块链条是不必要的，这取决于实现的需要程度。散列中所需的零点越多，任何给定交易的哈希成本就越大。如果有5个Zeroes而不是17，那么所有尝试都会失败，这意味着只需尝试一半的哈希，而且反过来将需要两倍，只需计算两倍，每次尝试都需要散列硬件的四倍由于每次尝试都会产生两倍的碰撞（或“非唯一”结果）。
比特币网络自动调整其目标阈值，以确保每10分钟大约挖掘新块。它以17 zeroes开头的原因是，因为这种值会在每4年结合挖掘奖励的减半时导致正确的平均块时间。如果哈希所需的零数是改变，则目标阈值也会如此，因此平均块时间也会发生变化。
为了使事情保持一致，即使可以改变底层算法，哈希开始时的零点的数量需要保持静止。这就是为什么以非散列算法（SHA-3）而不是比特币的为什么，仍然需要它的哈希以20个零点开始。其他算法可能需要不同数量的前导零，以便产生具有特定数量的零字节的散列。
BlockChain哈希以一定数量的零点开始的要求不仅仅是散列算法的函数，还不仅仅是散列数据的函数。使用多个散列算法可以进一步复杂化东西，因为每个算法可能具有对前导零的自己的要求。例如，Etereum使用的Keccak算法要求哈希以至少6个零开始。
因此，虽然大多数区块链确实需要哈希以一定数量的零点开始，但情况并非总是如此。这取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的零数量的变化。
回答 6 它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图何时何
它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图操纵数据（重写历史记录）。这种机制使块状不变。
回答 7 限制参数：0 ^ 0的限制参数都不是valivarguments。在点PIS处采用函数F的限制的唯一时间是在P处连续时计算f（p）的有效方法。 functionf（x，y）= x ^ y在p点p =（0,0）中不连续.thus，限制参数没有0 ^ 0的轴承，这是来自这些论点的一个取消的唯一一个，就是作者忽略或不了解限制与连续性之间的关系。
对于那些认为限制争论的人是建立牵引的唯一方法，请记住，在19世纪起源之前，在这些局限性起来之前已经是1的0 ^ 0。有许多有效的方法（无限制）以确定0 ^ 0的值。在最简单的形式写入时，该值直接从定义中。它可以通过坚持符合符合符合的一致性来导出，或者可以源自广泛接受的数学定理，例如二项式定理等。人们经历不必要的麻烦以避免定义0 ^ 0。例如，递归定义从x ^ 1 = x而不是从x ^ 0开始的唯一原因= 1是毫无根据的恐惧。同样，唯一的原因给出递归定义（而不是更短的： x ^ n是x的n拷贝的乘积，再次努力避免0 ^ 0。最终，这些努力是徒劳的，因为仍然有许多定理通过裂缝，即，仍然意味着0 ^ 0 = 1。当然，这种感知的问题不是一个实际问题，因为数学是非常一致的，这意味着每个暗示0 ^ 0的值的每个定理和每个一致的参数将始终意味着相同的值。"><meta itemprop="datePublished" content="2022-01-23T22:08:28+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:28+08:00" />
<meta itemprop="wordCount" content="133">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？"/>
<meta name="twitter:description" content="为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？ 回答 1 我假设你在谈论比特币。
您可以将256位散列作为数字解释。通过要求下一个块具有低于一定值的散列来调整当前难度。较小的数字在其前导数字中有更多的零。
所以，例如，如果我说将我的名字命名为1000，然后将其表示为32位整数，它将有很多初始零。就是这样，他们并不意味着什么比这更重要。
如果您尝试发出一个不会遵守所有规则的块（包括查找与当前难度不一致的散列），那么另一个节点将拒绝它。
回答 2 散列用于创建文档或其他数据块的代表性摘要，该块是固定大小的，并且如果在原始数据中更改了任何位或比特的组合，则会更改（急剧！）。这用于（例如示例）用于在网络上发送数据包的校验和，以确保它们以其剩余的相同内容到达。
一个加密保护的哈希标志着，第三方希望恶意改变数据，以这样的方式仍然是相同的;这很重要，因为加密签名基本上是用公钥加密加密的哈希，所以如果您可以保留哈希，则可以声称您在发起者或公平的证人签署了一份文件，当实际上是一个不同的文件一个签名。
对哈希的攻击的严重程度取决于您如何强迫碰撞。最严重的是您可以创建一个您希望匹配的哈希的任意文档。第二个最严重的是您可以生成两个将提供相同哈希的文档，但无法提前确定哈希将是什么（即，您必须并行改变两个文件以实现这一目标）
在后一种情况下，您必须说服受害者签署其中一个文件，而无需以任何方式更改它，因此您可以申请第二个文件是实际签名的文件。
回答 3 哈希基本上是一种单向功能，在其中输入可变长度的输入并获得固定长度的唯一输出。并且随机数基本上意味着一次使用的数字，现在在比特币区块链中是一个值，它是您在块前面添加的值，以匹配比特币中的当前难度是块的哈希散列开始时的一定数量的零。所以你收集你的数据并获得一个固定的哈希现在，您必须添加一个annce值，直到您等于或更接近难度级别。
在Ethereum中，Nonce是从给定地址发送的事务数。随着该地址的交易数量增加，与地址相关的随机值增加。
回答 4 作为领先的零的难度是一种错误的过度过度简化，对难度如何工作，我在这里的其他答案中解释了这一点。
但是，是的，如果一个块超出难度要求，它被接受。困难只是所需的最低质量。
回答 5 什么是区块链散列？
哈希是由散列算法产生的数据的独特指纹。就像每个人都有一个独特的指纹一样，每一条数据都有自己独特的哈希。
当事务被提交到区块链时，使用散列算法散列。然后使用得到的散列来验证交易是否有效。如果哈希不符合BlockChain协议指定的标准，则交易将被拒绝。
哈希以一定数量的零点开始的要求被称为零字节规则。大多数区块链要求哈希以一定数量的零点开始，以确保它们有效。但是，这并不总是如此，并且取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的前导零数量的变化。
这是一个常见的误解，碉堡哈希需要从17个零点开始。这源于在使用SHA-256哈希函数的比特币中，有效事务将使其Merkle Root算法逐出到低于或等于当前目标阈值的值。这意味着，这意味着平均一半的尝试必须成功，并且在此过程中，它们将产生大约34个零字节的字符串。
散列的最大可能数量为80，因此在参考目标哈希的开头时，它将描述为需要18个零点的比特币协议规则。实际上，在验证时，领先的17很重要，最后一个是序列的简单延续。
实际上，在那个零中开始一个区块链条是不必要的，这取决于实现的需要程度。散列中所需的零点越多，任何给定交易的哈希成本就越大。如果有5个Zeroes而不是17，那么所有尝试都会失败，这意味着只需尝试一半的哈希，而且反过来将需要两倍，只需计算两倍，每次尝试都需要散列硬件的四倍由于每次尝试都会产生两倍的碰撞（或“非唯一”结果）。
比特币网络自动调整其目标阈值，以确保每10分钟大约挖掘新块。它以17 zeroes开头的原因是，因为这种值会在每4年结合挖掘奖励的减半时导致正确的平均块时间。如果哈希所需的零数是改变，则目标阈值也会如此，因此平均块时间也会发生变化。
为了使事情保持一致，即使可以改变底层算法，哈希开始时的零点的数量需要保持静止。这就是为什么以非散列算法（SHA-3）而不是比特币的为什么，仍然需要它的哈希以20个零点开始。其他算法可能需要不同数量的前导零，以便产生具有特定数量的零字节的散列。
BlockChain哈希以一定数量的零点开始的要求不仅仅是散列算法的函数，还不仅仅是散列数据的函数。使用多个散列算法可以进一步复杂化东西，因为每个算法可能具有对前导零的自己的要求。例如，Etereum使用的Keccak算法要求哈希以至少6个零开始。
因此，虽然大多数区块链确实需要哈希以一定数量的零点开始，但情况并非总是如此。这取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的零数量的变化。
回答 6 它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图何时何
它的东西往往会混淆程序员。
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。
这就是你如何判断有人试图操纵数据（重写历史记录）。这种机制使块状不变。
回答 7 限制参数：0 ^ 0的限制参数都不是valivarguments。在点PIS处采用函数F的限制的唯一时间是在P处连续时计算f（p）的有效方法。 functionf（x，y）= x ^ y在p点p =（0,0）中不连续.thus，限制参数没有0 ^ 0的轴承，这是来自这些论点的一个取消的唯一一个，就是作者忽略或不了解限制与连续性之间的关系。
对于那些认为限制争论的人是建立牵引的唯一方法，请记住，在19世纪起源之前，在这些局限性起来之前已经是1的0 ^ 0。有许多有效的方法（无限制）以确定0 ^ 0的值。在最简单的形式写入时，该值直接从定义中。它可以通过坚持符合符合符合的一致性来导出，或者可以源自广泛接受的数学定理，例如二项式定理等。人们经历不必要的麻烦以避免定义0 ^ 0。例如，递归定义从x ^ 1 = x而不是从x ^ 0开始的唯一原因= 1是毫无根据的恐惧。同样，唯一的原因给出递归定义（而不是更短的： x ^ n是x的n拷贝的乘积，再次努力避免0 ^ 0。最终，这些努力是徒劳的，因为仍然有许多定理通过裂缝，即，仍然意味着0 ^ 0 = 1。当然，这种感知的问题不是一个实际问题，因为数学是非常一致的，这意味着每个暗示0 ^ 0的值的每个定理和每个一致的参数将始终意味着相同的值。"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:28+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="为什么块哈希必须验证很多零点才能验证吗那些零意味着什么">为什么块哈希必须验证很多零点才能验证吗？那些零意味着什么？</h2>
<h3 id="回答-1">回答 1</h3>
<p>我假设你在谈论比特币。<br>
您可以将256位散列作为数字解释。通过要求下一个块具有低于一定值的散列来调整当前难度。较小的数字在其前导数字中有更多的零。<br>
所以，例如，如果我说将我的名字命名为1000，然后将其表示为32位整数，它将有很多初始零。就是这样，他们并不意味着什么比这更重要。<br>
如果您尝试发出一个不会遵守所有规则的块（包括查找与当前难度不一致的散列），那么另一个节点将拒绝它。</p>
<h3 id="回答-2">回答 2</h3>
<p>散列用于创建文档或其他数据块的代表性摘要，该块是固定大小的，并且如果在原始数据中更改了任何位或比特的组合，则会更改（急剧！）。这用于（例如示例）用于在网络上发送数据包的校验和，以确保它们以其剩余的相同内容到达。<br>
一个加密保护的哈希标志着，第三方希望恶意改变数据，以这样的方式仍然是相同的;这很重要，因为加密签名基本上是用公钥加密加密的哈希，所以如果您可以保留哈希，则可以声称您在发起者或公平的证人签署了一份文件，当实际上是一个不同的文件一个签名。<br>
对哈希的攻击的严重程度取决于您如何强迫碰撞。最严重的是您可以创建一个您希望匹配的哈希的任意文档。第二个最严重的是您可以生成两个将提供相同哈希的文档，但无法提前确定哈希将是什么（即，您必须并行改变两个文件以实现这一目标）<br>
在后一种情况下，您必须说服受害者签署其中一个文件，而无需以任何方式更改它，因此您可以申请第二个文件是实际签名的文件。</p>
<h3 id="回答-3">回答 3</h3>
<p>哈希基本上是一种单向功能，在其中输入可变长度的输入并获得固定长度的唯一输出。并且随机数基本上意味着一次使用的数字，现在在比特币区块链中是一个值，它是您在块前面添加的值，以匹配比特币中的当前难度是块的哈希散列开始时的一定数量的零。所以你收集你的数据并获得一个固定的哈希现在，您必须添加一个annce值，直到您等于或更接近难度级别。<br>
在Ethereum中，Nonce是从给定地址发送的事务数。随着该地址的交易数量增加，与地址相关的随机值增加。</p>
<h3 id="回答-4">回答 4</h3>
<p>作为领先的零的难度是一种错误的过度过度简化，对难度如何工作，我在这里的其他答案中解释了这一点。<br>
但是，是的，如果一个块超出难度要求，它被接受。困难只是所需的最低质量。</p>
<h3 id="回答-5">回答 5</h3>
<p>什么是区块链散列？<br>
哈希是由散列算法产生的数据的独特指纹。就像每个人都有一个独特的指纹一样，每一条数据都有自己独特的哈希。<br>
当事务被提交到区块链时，使用散列算法散列。然后使用得到的散列来验证交易是否有效。如果哈希不符合BlockChain协议指定的标准，则交易将被拒绝。<br>
哈希以一定数量的零点开始的要求被称为零字节规则。大多数区块链要求哈希以一定数量的零点开始，以确保它们有效。但是，这并不总是如此，并且取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的前导零数量的变化。<br>
这是一个常见的误解，碉堡哈希需要从17个零点开始。这源于在使用SHA-256哈希函数的比特币中，有效事务将使其Merkle Root算法逐出到低于或等于当前目标阈值的值。这意味着，这意味着平均一半的尝试必须成功，并且在此过程中，它们将产生大约34个零字节的字符串。<br>
散列的最大可能数量为80，因此在参考目标哈希的开头时，它将描述为需要18个零点的比特币协议规则。实际上，在验证时，领先的17很重要，最后一个是序列的简单延续。<br>
实际上，在那个零中开始一个区块链条是不必要的，这取决于实现的需要程度。散列中所需的零点越多，任何给定交易的哈希成本就越大。如果有5个Zeroes而不是17，那么所有尝试都会失败，这意味着只需尝试一半的哈希，而且反过来将需要两倍，只需计算两倍，每次尝试都需要散列硬件的四倍由于每次尝试都会产生两倍的碰撞（或“非唯一”结果）。<br>
比特币网络自动调整其目标阈值，以确保每10分钟大约挖掘新块。它以17 zeroes开头的原因是，因为这种值会在每4年结合挖掘奖励的减半时导致正确的平均块时间。如果哈希所需的零数是改变，则目标阈值也会如此，因此平均块时间也会发生变化。<br>
为了使事情保持一致，即使可以改变底层算法，哈希开始时的零点的数量需要保持静止。这就是为什么以非散列算法（SHA-3）而不是比特币的为什么，仍然需要它的哈希以20个零点开始。其他算法可能需要不同数量的前导零，以便产生具有特定数量的零字节的散列。<br>
BlockChain哈希以一定数量的零点开始的要求不仅仅是散列算法的函数，还不仅仅是散列数据的函数。使用多个散列算法可以进一步复杂化东西，因为每个算法可能具有对前导零的自己的要求。例如，Etereum使用的Keccak算法要求哈希以至少6个零开始。<br>
因此，虽然大多数区块链确实需要哈希以一定数量的零点开始，但情况并非总是如此。这取决于散列算法和正在散列的数据。随着区块链技术的发展，我们可以期望看到有效哈希所需的零数量的变化。</p>
<h3 id="回答-6">回答 6</h3>
<p>它的东西往往会混淆程序员。<br>
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。<br>
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。<br>
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。<br>
这就是你如何判断有人试图何时何<br>
它的东西往往会混淆程序员。<br>
它不是一个像存储器地址中的指针，这是编码器的指针意味着什么。相反，它是数据结构的关键。<br>
更简单：哈希指针是链中每个块的一部分。它包含上一个块的哈希。您可以称之为数据字段，其有帮助。<br>
哈希指针确保不再更改来自上一个块的数据。更改上一个块中的数据将改变该块的哈希值，从而使当前块的散列指针无效。<br>
这就是你如何判断有人试图操纵数据（重写历史记录）。这种机制使块状不变。</p>
<h3 id="回答-7">回答 7</h3>
<p>限制参数：0 ^ 0的限制参数都不是valivarguments。在点PIS处采用函数F的限制的唯一时间是在P处连续时计算f（p）的有效方法。 functionf（x，y）= x ^ y在p点p =（0,0）中不连续.thus，限制参数没有0 ^ 0的轴承，这是来自这些论点的一个取消的唯一一个，就是作者忽略或不了解限制与连续性之间的关系。<br>
对于那些认为限制争论的人是建立牵引的唯一方法，请记住，在19世纪起源之前，在这些局限性起来之前已经是1的0 ^ 0。有许多有效的方法（无限制）以确定0 ^ 0的值。在最简单的形式写入时，该值直接从定义中。它可以通过坚持符合符合符合的一致性来导出，或者可以源自广泛接受的数学定理，例如二项式定理等。人们经历不必要的麻烦以避免定义0 ^ 0。例如，递归定义从x ^ 1 = x而不是从x ^ 0开始的唯一原因= 1是毫无根据的恐惧。同样，唯一的原因给出递归定义（而不是更短的： x ^ n是x的n拷贝的乘积，再次努力避免0 ^ 0。最终，这些努力是徒劳的，因为仍然有许多定理通过裂缝，即，仍然意味着0 ^ 0 = 1。当然，这种感知的问题不是一个实际问题，因为数学是非常一致的，这意味着每个暗示0 ^ 0的值的每个定理和每个一致的参数将始终意味着相同的值。<br>
不确定形式：这是一些，但不是全部，不连续功能的列表。大多数教科书都没有定义除了简单的列表成员之外的此列表。成员资格是以历史原因决定的，原因不决定。例如，唯一的原因（0）不会出现在列表中是因为楼层当时不是一个众所周知的功能。事实上，在写这个列表时，Limits和连续性之间的关系尚不熟悉，而且因此，不连续功能并不是真正信任。当在该表中列出0 ^ 0时，Allthat意味着要说不同的路径（0,0）可以具有不同的限制（历史记录：它没有意味着0 ^ 0是未定义的，则在此时未出现该方法表是第一次出版）。然而，在这些概念没有被广泛理解的时候，它是震惊的，即这种众所周知的功能可能是不连续的，这基本上被认为是一个矛盾。 undefine 0 ^ 0（之前是1）的想法出现在这种混乱中。这一原因发生的原因之一是，在轮胎时，对连续性的理解是如此贫穷，人们甚至没有意识到拒绝0 ^ 0 Wontolve这个问题！ （即使在他们的思想中易于这样做，它不会让不连续性消失。不幸的是，今天仍然出现在许多微积分教科书中，这是对不连续性的不信任和对那时的不信任0（A.K.A.数学史上最伟大的发明）。</p>
<h3 id="回答-8">回答 8</h3>
<p>攻击者可以尝试用以前的哈希，不同的数据和不同的哈希插入一个块，但他仍然存在<br>
是的，攻击者可以插入具有相同先前散列的块，但与当前（合法）块相同的哈希值，因为散列随着数据的变化而变化，并且块的散列也随着先前的哈希变化而变化。因此，计算数十亿岁才能计算（称为哈希函数碰撞）。哈希非常容易计算，因此运行全节点的计算机将简单地拒绝具有错误散列的块。<br>
附加信息<br>
攻击者可以尝试使用以前的哈希，不同的数据和不同的哈希插入块，但是他需要显示他的工作证明，这是一些随机位被添加到块中的数据结束时，这样只需随机机会，哈希末端至少有17个（或SO）零。这很难计算，它确保许多人试图用那种数据计算那个块，并保证许多人对该数据同意，很多人都看到了这一数据。<br>
如果区块链切入2（例如：Hacker碰巧找到1个块的工作证明）和两个组（带有全节点的矿工）不同意块应包含的内容，然后是全节点保留链条的持续持续作为选项。两组矿工竞争直到一连串的街区比另一个块长，这意味着它有更多的工作证明（对应于更多人），直到最终丢弃较短的链条。<br>
这意味着工作证明是确保所有矿工看到当前国家并同意它的共识机制。这有点像民主。<br>
如果黑客控制全球采矿能力的51％，他可能会拨打51％的攻击，因为他可以加倍，因为他可以保证他的恶意链比合法区块长。<br>
51％的攻击可以阻止人们进行交易，（包括黑客交易），黑客可以使用它在商店花钱，然后取消自己的交易。<br>
阻止损坏不能用于从任何人的帐户中花费。那是因为为了通过全节点接受交易，所以每次交易都需要使用所有者的私钥和全节点检查一次！没有多少损坏的块可以窃取你的钱，但它可以取消自腐败开始以来发出的块（但是当攻击者疲惫时，理论上的所有情况都会被整理）。</p>
<h3 id="回答-9">回答 9</h3>
<p>如果您想赶上网络，您需要购买足够的计算能力和e<br>
我假设您指的是一个区块链接系统，可以实现工作验证的共识 - 就像比特币一样。<br>
嗯，这个想法是，如果你在块中改变一些东西，你需要找到一个新的哈希来为块找到一个新的哈希，并且在计算出来的时间（所以你可以将它放入下一个块），其余的网络将添加许多街区到原始区块链上。<br>
这意味着您的BlockChain版本现在短于无篡改权，网络将忽略您的版本并继续扩展原始版本。<br>
如果您想赶上网络，您需要比整个网络更快地购买足够的计算能力和电力，这比通过改变块更昂贵的东西更昂贵。<br>
事实上，如果您确实设法设置那种基础设施，那么您可能会更好地禁止诚实，只需累积块奖励（现在）。</p>
<h3 id="回答-10">回答 10</h3>
<p>另一个reaso.<br>
ID必须不同意S.K.苏曼在这里。<br>
0甚至确实。序列：序列：1,2,3,4,5,4,6即使是1,3,5是奇数。这里的图案在这里瞪大笑。每个奇数由偶数成功，而每一个偶数都是通过奇数再次成功，即奇数甚至数字在序列中播放，如上所述.Now按照顺序执行序列：-2，-1,0， 1，我们知道，即使-1和1是奇数的，我们也知道-2和2。在这里应用上面的逻辑，命令必须像偶数，奇数，偶数，奇数，&hellip;&hellip;.等所以我们可以看到0甚至是偶数。<br>
支持这一点的另一个原因是说，即使当数量除以2的剩余部分也是0.0，如2,4,6或-2，-4，-6。当除以2时，剩余部分是0，从而验证说明。当0除以2时，余数为0.因此如果上述逻辑是真的，那么我们可以断言0确实是偶数。</p>
<h3 id="回答-11">回答 11</h3>
<p>这不是难度如何工作，所以&hellip;&hellip;不可能回答这个问题。<br>
我的意思是，如果这真的是如何艰难的工作，那么找到一个街区所需的努力将能够通过两个因素来增长或缩小（因为只是领先的零只能编码这一数量的信息，因此没有更精细的空间 - 粒度调整）。<br>
如果要了解所有血腥细节，请选中此文章：</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
