<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>程序员真的必须知道如何为他们的程序计算大o吗？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="程序员真的必须知道如何为他们的程序计算大o吗？ 回答 1 Matt Laine的答案是完全正确的 - 软件工程师应该能够评估他们的计划的表现并相应行动，或者否则可能会发生坏事。
例如，我的一个同事曾一旦写过一种通过反复删除第一元素来处理C＃列表的算法。他没有意识到这是一个O（n）的操作，这使得总时间复杂度o（n ^ 2）。
不幸的是，它没有足够的效果来抓住测试，但它确实对生产中的一些重要客户产生了问题&hellip;&hellip;
回答 2 发生了什么是队列有点备份。这不是一个问题，除了检查队列中的成员资格是o（n）的问题，我们达到了队列足够长的地方，以便检查我们是否已经有SIMILA
您无需了解有关校样和类似的信息的详细信息。你只需要一个想法，事情将会失控。
这是一个例子：在生产系统中，等待处理的工作短队员。在向队列添加条目之前，完成了检查以确保该项目尚未在队列中。相当简单，对吧？
发生了什么是队列有点备份。除了检查队列中的成员资格是o（n），我们达到了一个问题，我们达到了足够长的时间，检查我们是否已经在队列中有类似的条目需要时间超过时间。系统也无法从队列中删除条目。换句话说，队列只能运行，只要它少于X条目即可，它在大部分时间和测试期间都会进行。
这是您必须了解的时间和空间复杂程度。我唯一一次听说实际上和正式使用Bigg o符号的时间是在20世纪80年代中期回到了大学时，​​他们试图将计算机科学成为实际科学。
回答 3 不，不准确地说。但暴露于概念是好的。
如果他们做任何最终有一些规模的事情，他们应该有一些相似的操作规模。如果描述这一点，符号是一种形式化的方式。如果它开始处理一些可敬的数据并学习如何避免问题，他们应该识别出荒谬的时间。例如：
回答 4 能够为整个节目产生准确的大o计算复杂性很少必要，但是在使用非琐碎的数据大小并且相当容易时，在算法中具有直觉既非常有价值。让我们来看看它。
假设我们在随机顺序中有5个随机数列表。
[23,14,76,12,99]
想象一下，我们编写一个软件功能来回答问题计算特定数量X中出现的次数，通过循环整个列表并将每个数字与x进行比较，递增计数器。该计划需要考虑的5个数字中有多少？答案是5，列表的长度。
现在，如果我们制作任意大小列表，请说n个数字，这些数字中有多少个数字需要查看？答案是n，列表的长度。这称为程序的计算复杂性。
我们将此写为O（n），每次执行函数时都意味着它会扫描n个数字，其中n是列表大小。这被称为Big-O表示法，因为我们在写它时使用一个大o。用英语，我们读到了这一点。
考虑计算复杂性有两种主要原因。
（1）在我们上面的简单示例中，如果我们的全部目标是回答关于一套数量的次数有多少次的问题，我们将要问这个问题真正大量的次数，我们可以做太多比O（n）好。
理想的哈希表是O（1），因为我们采取了一个关键，基本上直接查找值。因此，如果我们将数据存储更改为哈希表，其中每个键是数字，每个值都是它发生了多少时间，然后我们可以使用这种新的数据结构来回答我们在O（1）时间内的问题（说明作为1次）。 o（1）当n = 5时并不多得多，但是当n = 10亿时，这是速度的10亿倍。
（2）如果算法是O（n ^ 2）或更差，则在具有大n的数据集上运行它非常慢。可能无法在合理的时间内完成o（n ^ n）的算法。这个概念在很大程度上是加密学基于的。制作一个加密的Cypher，即使在最大的超级计算机上也需要100年的时间，并且可能足够安全，以保护数据长度比它更有用。 真的只有一个人需要了解一个，然后我们已经完成了。
BIG-O计算复杂性不是整个故事。故事的另一部分是每个工作单位所采取的时间。在上面的情况下，我们正在谈论使用平等运算符进行比较列表中的数量。计算机真的非常快，因此比较个别数字真的非常快，大约是微秒的顺序。
但是，如果我们的算法中的每个工作单元正在做一些更慢的东西（例如寻求旋转磁盘，写入闪存，或通过网络谈话），则每个工作单元都需要毫秒。同样，我们可以谈论某种硬件传感，相机或采集任务的算法可能需要几秒钟甚至几分钟。
这里的重要课程是，当您的工作单元更长（例如，秒）和您的n大，那么算法的大o复杂性就会变得更加重要。
就是这样。如果您了解所有这些，那么您知道计算复杂性的基础知识，您所缺少的所有内容都是常见算法计算复杂性的一系列经验和了解。
回答 5 是的，因为你必须要识别你是否曾经做过某种东西，因为几乎没有任何程序要求将容忍，除非不可能做得更好。有时甚至下限都太慢了。
这并不意味着你实际上必须在写它的规划意义上除了你的头脑中的任何地方。您有程序，您可以在代表性工作负载上运行它，您不需要计算限制时计算运行时间，当您可以在确切的情况下测量它们。在事实上，它几乎总是更好地测量运行时间而不是计算它，因为您的计算几乎与首先写入程序一样复杂。
当您拥有最严重的要求时，实时实时，您不会做任何计算。您必须以特定方式编写代码，具体的工具将确保您获得所需的性能。 （好的，你不必，但它真的非常好主意，如果你不这样做，那么它就会更加艰难）大多数东西是最糟糕的，但是，像服务器和操作系统和视频游戏一样软。只要你几乎一直生产出来的输出很快，那就好了，它足够好。很难实时是你有什么东西可以完全x毫秒来计算答案，做的事情或火车会崩溃，人们会死的，因为你可能猜到，确切的运行时间是重要的，而不是极限的近似值（AKA大o）
回答 6 因此，为什么在处理器/计算机上运行您的程序/应用程序是必要的
韩国表演初创公司，强调了对分析算法的需要。现场基本上是，打破了2个程序的领带，而它们基本上锁定在精度上的虚拟死热量。虽然该程序具有略高的精度，但在针对劣质计算机的同时略有较高的速度，但主角被声明了获胜者，以便能够提供一个系统，同时在Threadbare系统上运行时保持其一致性。
那么，为什么在几十年前在计算中有进步时，在处理器/计算机/手机上有必要在处理器/计算机/手机上运行？
CPU已经使电脑有高效。虽然单核处理器已经处于Moore Law的限制，但Muti核心和MUTI线程处理器已经更快地计算并使得可以在各种应用中无缝多任务。
GPU使得可以拥有图形和FPS（每秒帧）。 GPU已经让您在笔记本电脑上观看4K电影，并在众多游戏中找到人类反应的理论限制（抽搐射手，平台，打架游戏）。虽然GPU被销售为一个爱好者的努力，但他们通过高艺术，采矿和云计算为全世界的经济促销。
张量加工单位已彻底改变了人工智能实施的方式。 TPU使您可以在手机上具有自然语言处理的服务器缩放处理，并为每个用户提供了使用翻译功能和文本的能力，以便在您的声音方便的方便。 TPU使得可以运行计算机愿景来在您的特斯拉斯上运行，并使其可以检测其他汽车，具有无可挑剔的准确性
虽然计算的进步一直是必不可少的，并且影响了超级计算机的创建，量子计算机，虚拟和增强现实，但系统仍然设计与普通客户的普遍客户。像口袋妖怪的游戏，彻底改变了手持游戏，并带有数百万人进入一个经常被降级的生态系统（电话游戏），经常被降级到运行图形无能为力的生活SIM卡。虽然游戏仍然只有加强现实的初步实施，但它仍然努力处理全球所有客户。
抛出钱和资源问题从来都不是世界上最大的媒体特许经营的关注。虽然niantiac（由任天堂，口袋妖怪公司和谷歌支持）能够解决这个问题，但并非每个开发商都休闲在该规模上进行实验，而且大o表示法有助于开发设计的时间和空间所施加的理论限制要求解决问题。
回答 7 这是缺点，">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="程序员真的必须知道如何为他们的程序计算大o吗？" />
<meta property="og:description" content="程序员真的必须知道如何为他们的程序计算大o吗？ 回答 1 Matt Laine的答案是完全正确的 - 软件工程师应该能够评估他们的计划的表现并相应行动，或者否则可能会发生坏事。
例如，我的一个同事曾一旦写过一种通过反复删除第一元素来处理C＃列表的算法。他没有意识到这是一个O（n）的操作，这使得总时间复杂度o（n ^ 2）。
不幸的是，它没有足够的效果来抓住测试，但它确实对生产中的一些重要客户产生了问题&hellip;&hellip;
回答 2 发生了什么是队列有点备份。这不是一个问题，除了检查队列中的成员资格是o（n）的问题，我们达到了队列足够长的地方，以便检查我们是否已经有SIMILA
您无需了解有关校样和类似的信息的详细信息。你只需要一个想法，事情将会失控。
这是一个例子：在生产系统中，等待处理的工作短队员。在向队列添加条目之前，完成了检查以确保该项目尚未在队列中。相当简单，对吧？
发生了什么是队列有点备份。除了检查队列中的成员资格是o（n），我们达到了一个问题，我们达到了足够长的时间，检查我们是否已经在队列中有类似的条目需要时间超过时间。系统也无法从队列中删除条目。换句话说，队列只能运行，只要它少于X条目即可，它在大部分时间和测试期间都会进行。
这是您必须了解的时间和空间复杂程度。我唯一一次听说实际上和正式使用Bigg o符号的时间是在20世纪80年代中期回到了大学时，​​他们试图将计算机科学成为实际科学。
回答 3 不，不准确地说。但暴露于概念是好的。
如果他们做任何最终有一些规模的事情，他们应该有一些相似的操作规模。如果描述这一点，符号是一种形式化的方式。如果它开始处理一些可敬的数据并学习如何避免问题，他们应该识别出荒谬的时间。例如：
回答 4 能够为整个节目产生准确的大o计算复杂性很少必要，但是在使用非琐碎的数据大小并且相当容易时，在算法中具有直觉既非常有价值。让我们来看看它。
假设我们在随机顺序中有5个随机数列表。
[23,14,76,12,99]
想象一下，我们编写一个软件功能来回答问题计算特定数量X中出现的次数，通过循环整个列表并将每个数字与x进行比较，递增计数器。该计划需要考虑的5个数字中有多少？答案是5，列表的长度。
现在，如果我们制作任意大小列表，请说n个数字，这些数字中有多少个数字需要查看？答案是n，列表的长度。这称为程序的计算复杂性。
我们将此写为O（n），每次执行函数时都意味着它会扫描n个数字，其中n是列表大小。这被称为Big-O表示法，因为我们在写它时使用一个大o。用英语，我们读到了这一点。
考虑计算复杂性有两种主要原因。
（1）在我们上面的简单示例中，如果我们的全部目标是回答关于一套数量的次数有多少次的问题，我们将要问这个问题真正大量的次数，我们可以做太多比O（n）好。
理想的哈希表是O（1），因为我们采取了一个关键，基本上直接查找值。因此，如果我们将数据存储更改为哈希表，其中每个键是数字，每个值都是它发生了多少时间，然后我们可以使用这种新的数据结构来回答我们在O（1）时间内的问题（说明作为1次）。 o（1）当n = 5时并不多得多，但是当n = 10亿时，这是速度的10亿倍。
（2）如果算法是O（n ^ 2）或更差，则在具有大n的数据集上运行它非常慢。可能无法在合理的时间内完成o（n ^ n）的算法。这个概念在很大程度上是加密学基于的。制作一个加密的Cypher，即使在最大的超级计算机上也需要100年的时间，并且可能足够安全，以保护数据长度比它更有用。 真的只有一个人需要了解一个，然后我们已经完成了。
BIG-O计算复杂性不是整个故事。故事的另一部分是每个工作单位所采取的时间。在上面的情况下，我们正在谈论使用平等运算符进行比较列表中的数量。计算机真的非常快，因此比较个别数字真的非常快，大约是微秒的顺序。
但是，如果我们的算法中的每个工作单元正在做一些更慢的东西（例如寻求旋转磁盘，写入闪存，或通过网络谈话），则每个工作单元都需要毫秒。同样，我们可以谈论某种硬件传感，相机或采集任务的算法可能需要几秒钟甚至几分钟。
这里的重要课程是，当您的工作单元更长（例如，秒）和您的n大，那么算法的大o复杂性就会变得更加重要。
就是这样。如果您了解所有这些，那么您知道计算复杂性的基础知识，您所缺少的所有内容都是常见算法计算复杂性的一系列经验和了解。
回答 5 是的，因为你必须要识别你是否曾经做过某种东西，因为几乎没有任何程序要求将容忍，除非不可能做得更好。有时甚至下限都太慢了。
这并不意味着你实际上必须在写它的规划意义上除了你的头脑中的任何地方。您有程序，您可以在代表性工作负载上运行它，您不需要计算限制时计算运行时间，当您可以在确切的情况下测量它们。在事实上，它几乎总是更好地测量运行时间而不是计算它，因为您的计算几乎与首先写入程序一样复杂。
当您拥有最严重的要求时，实时实时，您不会做任何计算。您必须以特定方式编写代码，具体的工具将确保您获得所需的性能。 （好的，你不必，但它真的非常好主意，如果你不这样做，那么它就会更加艰难）大多数东西是最糟糕的，但是，像服务器和操作系统和视频游戏一样软。只要你几乎一直生产出来的输出很快，那就好了，它足够好。很难实时是你有什么东西可以完全x毫秒来计算答案，做的事情或火车会崩溃，人们会死的，因为你可能猜到，确切的运行时间是重要的，而不是极限的近似值（AKA大o）
回答 6 因此，为什么在处理器/计算机上运行您的程序/应用程序是必要的
韩国表演初创公司，强调了对分析算法的需要。现场基本上是，打破了2个程序的领带，而它们基本上锁定在精度上的虚拟死热量。虽然该程序具有略高的精度，但在针对劣质计算机的同时略有较高的速度，但主角被声明了获胜者，以便能够提供一个系统，同时在Threadbare系统上运行时保持其一致性。
那么，为什么在几十年前在计算中有进步时，在处理器/计算机/手机上有必要在处理器/计算机/手机上运行？
CPU已经使电脑有高效。虽然单核处理器已经处于Moore Law的限制，但Muti核心和MUTI线程处理器已经更快地计算并使得可以在各种应用中无缝多任务。
GPU使得可以拥有图形和FPS（每秒帧）。 GPU已经让您在笔记本电脑上观看4K电影，并在众多游戏中找到人类反应的理论限制（抽搐射手，平台，打架游戏）。虽然GPU被销售为一个爱好者的努力，但他们通过高艺术，采矿和云计算为全世界的经济促销。
张量加工单位已彻底改变了人工智能实施的方式。 TPU使您可以在手机上具有自然语言处理的服务器缩放处理，并为每个用户提供了使用翻译功能和文本的能力，以便在您的声音方便的方便。 TPU使得可以运行计算机愿景来在您的特斯拉斯上运行，并使其可以检测其他汽车，具有无可挑剔的准确性
虽然计算的进步一直是必不可少的，并且影响了超级计算机的创建，量子计算机，虚拟和增强现实，但系统仍然设计与普通客户的普遍客户。像口袋妖怪的游戏，彻底改变了手持游戏，并带有数百万人进入一个经常被降级的生态系统（电话游戏），经常被降级到运行图形无能为力的生活SIM卡。虽然游戏仍然只有加强现实的初步实施，但它仍然努力处理全球所有客户。
抛出钱和资源问题从来都不是世界上最大的媒体特许经营的关注。虽然niantiac（由任天堂，口袋妖怪公司和谷歌支持）能够解决这个问题，但并非每个开发商都休闲在该规模上进行实验，而且大o表示法有助于开发设计的时间和空间所施加的理论限制要求解决问题。
回答 7 这是缺点，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/do-programmers-really-have-to-know-how-to-calculate-the-big-o-for-their-programs/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:10+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:10+08:00" />

<meta itemprop="name" content="程序员真的必须知道如何为他们的程序计算大o吗？">
<meta itemprop="description" content="程序员真的必须知道如何为他们的程序计算大o吗？ 回答 1 Matt Laine的答案是完全正确的 - 软件工程师应该能够评估他们的计划的表现并相应行动，或者否则可能会发生坏事。
例如，我的一个同事曾一旦写过一种通过反复删除第一元素来处理C＃列表的算法。他没有意识到这是一个O（n）的操作，这使得总时间复杂度o（n ^ 2）。
不幸的是，它没有足够的效果来抓住测试，但它确实对生产中的一些重要客户产生了问题&hellip;&hellip;
回答 2 发生了什么是队列有点备份。这不是一个问题，除了检查队列中的成员资格是o（n）的问题，我们达到了队列足够长的地方，以便检查我们是否已经有SIMILA
您无需了解有关校样和类似的信息的详细信息。你只需要一个想法，事情将会失控。
这是一个例子：在生产系统中，等待处理的工作短队员。在向队列添加条目之前，完成了检查以确保该项目尚未在队列中。相当简单，对吧？
发生了什么是队列有点备份。除了检查队列中的成员资格是o（n），我们达到了一个问题，我们达到了足够长的时间，检查我们是否已经在队列中有类似的条目需要时间超过时间。系统也无法从队列中删除条目。换句话说，队列只能运行，只要它少于X条目即可，它在大部分时间和测试期间都会进行。
这是您必须了解的时间和空间复杂程度。我唯一一次听说实际上和正式使用Bigg o符号的时间是在20世纪80年代中期回到了大学时，​​他们试图将计算机科学成为实际科学。
回答 3 不，不准确地说。但暴露于概念是好的。
如果他们做任何最终有一些规模的事情，他们应该有一些相似的操作规模。如果描述这一点，符号是一种形式化的方式。如果它开始处理一些可敬的数据并学习如何避免问题，他们应该识别出荒谬的时间。例如：
回答 4 能够为整个节目产生准确的大o计算复杂性很少必要，但是在使用非琐碎的数据大小并且相当容易时，在算法中具有直觉既非常有价值。让我们来看看它。
假设我们在随机顺序中有5个随机数列表。
[23,14,76,12,99]
想象一下，我们编写一个软件功能来回答问题计算特定数量X中出现的次数，通过循环整个列表并将每个数字与x进行比较，递增计数器。该计划需要考虑的5个数字中有多少？答案是5，列表的长度。
现在，如果我们制作任意大小列表，请说n个数字，这些数字中有多少个数字需要查看？答案是n，列表的长度。这称为程序的计算复杂性。
我们将此写为O（n），每次执行函数时都意味着它会扫描n个数字，其中n是列表大小。这被称为Big-O表示法，因为我们在写它时使用一个大o。用英语，我们读到了这一点。
考虑计算复杂性有两种主要原因。
（1）在我们上面的简单示例中，如果我们的全部目标是回答关于一套数量的次数有多少次的问题，我们将要问这个问题真正大量的次数，我们可以做太多比O（n）好。
理想的哈希表是O（1），因为我们采取了一个关键，基本上直接查找值。因此，如果我们将数据存储更改为哈希表，其中每个键是数字，每个值都是它发生了多少时间，然后我们可以使用这种新的数据结构来回答我们在O（1）时间内的问题（说明作为1次）。 o（1）当n = 5时并不多得多，但是当n = 10亿时，这是速度的10亿倍。
（2）如果算法是O（n ^ 2）或更差，则在具有大n的数据集上运行它非常慢。可能无法在合理的时间内完成o（n ^ n）的算法。这个概念在很大程度上是加密学基于的。制作一个加密的Cypher，即使在最大的超级计算机上也需要100年的时间，并且可能足够安全，以保护数据长度比它更有用。 真的只有一个人需要了解一个，然后我们已经完成了。
BIG-O计算复杂性不是整个故事。故事的另一部分是每个工作单位所采取的时间。在上面的情况下，我们正在谈论使用平等运算符进行比较列表中的数量。计算机真的非常快，因此比较个别数字真的非常快，大约是微秒的顺序。
但是，如果我们的算法中的每个工作单元正在做一些更慢的东西（例如寻求旋转磁盘，写入闪存，或通过网络谈话），则每个工作单元都需要毫秒。同样，我们可以谈论某种硬件传感，相机或采集任务的算法可能需要几秒钟甚至几分钟。
这里的重要课程是，当您的工作单元更长（例如，秒）和您的n大，那么算法的大o复杂性就会变得更加重要。
就是这样。如果您了解所有这些，那么您知道计算复杂性的基础知识，您所缺少的所有内容都是常见算法计算复杂性的一系列经验和了解。
回答 5 是的，因为你必须要识别你是否曾经做过某种东西，因为几乎没有任何程序要求将容忍，除非不可能做得更好。有时甚至下限都太慢了。
这并不意味着你实际上必须在写它的规划意义上除了你的头脑中的任何地方。您有程序，您可以在代表性工作负载上运行它，您不需要计算限制时计算运行时间，当您可以在确切的情况下测量它们。在事实上，它几乎总是更好地测量运行时间而不是计算它，因为您的计算几乎与首先写入程序一样复杂。
当您拥有最严重的要求时，实时实时，您不会做任何计算。您必须以特定方式编写代码，具体的工具将确保您获得所需的性能。 （好的，你不必，但它真的非常好主意，如果你不这样做，那么它就会更加艰难）大多数东西是最糟糕的，但是，像服务器和操作系统和视频游戏一样软。只要你几乎一直生产出来的输出很快，那就好了，它足够好。很难实时是你有什么东西可以完全x毫秒来计算答案，做的事情或火车会崩溃，人们会死的，因为你可能猜到，确切的运行时间是重要的，而不是极限的近似值（AKA大o）
回答 6 因此，为什么在处理器/计算机上运行您的程序/应用程序是必要的
韩国表演初创公司，强调了对分析算法的需要。现场基本上是，打破了2个程序的领带，而它们基本上锁定在精度上的虚拟死热量。虽然该程序具有略高的精度，但在针对劣质计算机的同时略有较高的速度，但主角被声明了获胜者，以便能够提供一个系统，同时在Threadbare系统上运行时保持其一致性。
那么，为什么在几十年前在计算中有进步时，在处理器/计算机/手机上有必要在处理器/计算机/手机上运行？
CPU已经使电脑有高效。虽然单核处理器已经处于Moore Law的限制，但Muti核心和MUTI线程处理器已经更快地计算并使得可以在各种应用中无缝多任务。
GPU使得可以拥有图形和FPS（每秒帧）。 GPU已经让您在笔记本电脑上观看4K电影，并在众多游戏中找到人类反应的理论限制（抽搐射手，平台，打架游戏）。虽然GPU被销售为一个爱好者的努力，但他们通过高艺术，采矿和云计算为全世界的经济促销。
张量加工单位已彻底改变了人工智能实施的方式。 TPU使您可以在手机上具有自然语言处理的服务器缩放处理，并为每个用户提供了使用翻译功能和文本的能力，以便在您的声音方便的方便。 TPU使得可以运行计算机愿景来在您的特斯拉斯上运行，并使其可以检测其他汽车，具有无可挑剔的准确性
虽然计算的进步一直是必不可少的，并且影响了超级计算机的创建，量子计算机，虚拟和增强现实，但系统仍然设计与普通客户的普遍客户。像口袋妖怪的游戏，彻底改变了手持游戏，并带有数百万人进入一个经常被降级的生态系统（电话游戏），经常被降级到运行图形无能为力的生活SIM卡。虽然游戏仍然只有加强现实的初步实施，但它仍然努力处理全球所有客户。
抛出钱和资源问题从来都不是世界上最大的媒体特许经营的关注。虽然niantiac（由任天堂，口袋妖怪公司和谷歌支持）能够解决这个问题，但并非每个开发商都休闲在该规模上进行实验，而且大o表示法有助于开发设计的时间和空间所施加的理论限制要求解决问题。
回答 7 这是缺点，"><meta itemprop="datePublished" content="2022-01-23T22:08:10+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:10+08:00" />
<meta itemprop="wordCount" content="518">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="程序员真的必须知道如何为他们的程序计算大o吗？"/>
<meta name="twitter:description" content="程序员真的必须知道如何为他们的程序计算大o吗？ 回答 1 Matt Laine的答案是完全正确的 - 软件工程师应该能够评估他们的计划的表现并相应行动，或者否则可能会发生坏事。
例如，我的一个同事曾一旦写过一种通过反复删除第一元素来处理C＃列表的算法。他没有意识到这是一个O（n）的操作，这使得总时间复杂度o（n ^ 2）。
不幸的是，它没有足够的效果来抓住测试，但它确实对生产中的一些重要客户产生了问题&hellip;&hellip;
回答 2 发生了什么是队列有点备份。这不是一个问题，除了检查队列中的成员资格是o（n）的问题，我们达到了队列足够长的地方，以便检查我们是否已经有SIMILA
您无需了解有关校样和类似的信息的详细信息。你只需要一个想法，事情将会失控。
这是一个例子：在生产系统中，等待处理的工作短队员。在向队列添加条目之前，完成了检查以确保该项目尚未在队列中。相当简单，对吧？
发生了什么是队列有点备份。除了检查队列中的成员资格是o（n），我们达到了一个问题，我们达到了足够长的时间，检查我们是否已经在队列中有类似的条目需要时间超过时间。系统也无法从队列中删除条目。换句话说，队列只能运行，只要它少于X条目即可，它在大部分时间和测试期间都会进行。
这是您必须了解的时间和空间复杂程度。我唯一一次听说实际上和正式使用Bigg o符号的时间是在20世纪80年代中期回到了大学时，​​他们试图将计算机科学成为实际科学。
回答 3 不，不准确地说。但暴露于概念是好的。
如果他们做任何最终有一些规模的事情，他们应该有一些相似的操作规模。如果描述这一点，符号是一种形式化的方式。如果它开始处理一些可敬的数据并学习如何避免问题，他们应该识别出荒谬的时间。例如：
回答 4 能够为整个节目产生准确的大o计算复杂性很少必要，但是在使用非琐碎的数据大小并且相当容易时，在算法中具有直觉既非常有价值。让我们来看看它。
假设我们在随机顺序中有5个随机数列表。
[23,14,76,12,99]
想象一下，我们编写一个软件功能来回答问题计算特定数量X中出现的次数，通过循环整个列表并将每个数字与x进行比较，递增计数器。该计划需要考虑的5个数字中有多少？答案是5，列表的长度。
现在，如果我们制作任意大小列表，请说n个数字，这些数字中有多少个数字需要查看？答案是n，列表的长度。这称为程序的计算复杂性。
我们将此写为O（n），每次执行函数时都意味着它会扫描n个数字，其中n是列表大小。这被称为Big-O表示法，因为我们在写它时使用一个大o。用英语，我们读到了这一点。
考虑计算复杂性有两种主要原因。
（1）在我们上面的简单示例中，如果我们的全部目标是回答关于一套数量的次数有多少次的问题，我们将要问这个问题真正大量的次数，我们可以做太多比O（n）好。
理想的哈希表是O（1），因为我们采取了一个关键，基本上直接查找值。因此，如果我们将数据存储更改为哈希表，其中每个键是数字，每个值都是它发生了多少时间，然后我们可以使用这种新的数据结构来回答我们在O（1）时间内的问题（说明作为1次）。 o（1）当n = 5时并不多得多，但是当n = 10亿时，这是速度的10亿倍。
（2）如果算法是O（n ^ 2）或更差，则在具有大n的数据集上运行它非常慢。可能无法在合理的时间内完成o（n ^ n）的算法。这个概念在很大程度上是加密学基于的。制作一个加密的Cypher，即使在最大的超级计算机上也需要100年的时间，并且可能足够安全，以保护数据长度比它更有用。 真的只有一个人需要了解一个，然后我们已经完成了。
BIG-O计算复杂性不是整个故事。故事的另一部分是每个工作单位所采取的时间。在上面的情况下，我们正在谈论使用平等运算符进行比较列表中的数量。计算机真的非常快，因此比较个别数字真的非常快，大约是微秒的顺序。
但是，如果我们的算法中的每个工作单元正在做一些更慢的东西（例如寻求旋转磁盘，写入闪存，或通过网络谈话），则每个工作单元都需要毫秒。同样，我们可以谈论某种硬件传感，相机或采集任务的算法可能需要几秒钟甚至几分钟。
这里的重要课程是，当您的工作单元更长（例如，秒）和您的n大，那么算法的大o复杂性就会变得更加重要。
就是这样。如果您了解所有这些，那么您知道计算复杂性的基础知识，您所缺少的所有内容都是常见算法计算复杂性的一系列经验和了解。
回答 5 是的，因为你必须要识别你是否曾经做过某种东西，因为几乎没有任何程序要求将容忍，除非不可能做得更好。有时甚至下限都太慢了。
这并不意味着你实际上必须在写它的规划意义上除了你的头脑中的任何地方。您有程序，您可以在代表性工作负载上运行它，您不需要计算限制时计算运行时间，当您可以在确切的情况下测量它们。在事实上，它几乎总是更好地测量运行时间而不是计算它，因为您的计算几乎与首先写入程序一样复杂。
当您拥有最严重的要求时，实时实时，您不会做任何计算。您必须以特定方式编写代码，具体的工具将确保您获得所需的性能。 （好的，你不必，但它真的非常好主意，如果你不这样做，那么它就会更加艰难）大多数东西是最糟糕的，但是，像服务器和操作系统和视频游戏一样软。只要你几乎一直生产出来的输出很快，那就好了，它足够好。很难实时是你有什么东西可以完全x毫秒来计算答案，做的事情或火车会崩溃，人们会死的，因为你可能猜到，确切的运行时间是重要的，而不是极限的近似值（AKA大o）
回答 6 因此，为什么在处理器/计算机上运行您的程序/应用程序是必要的
韩国表演初创公司，强调了对分析算法的需要。现场基本上是，打破了2个程序的领带，而它们基本上锁定在精度上的虚拟死热量。虽然该程序具有略高的精度，但在针对劣质计算机的同时略有较高的速度，但主角被声明了获胜者，以便能够提供一个系统，同时在Threadbare系统上运行时保持其一致性。
那么，为什么在几十年前在计算中有进步时，在处理器/计算机/手机上有必要在处理器/计算机/手机上运行？
CPU已经使电脑有高效。虽然单核处理器已经处于Moore Law的限制，但Muti核心和MUTI线程处理器已经更快地计算并使得可以在各种应用中无缝多任务。
GPU使得可以拥有图形和FPS（每秒帧）。 GPU已经让您在笔记本电脑上观看4K电影，并在众多游戏中找到人类反应的理论限制（抽搐射手，平台，打架游戏）。虽然GPU被销售为一个爱好者的努力，但他们通过高艺术，采矿和云计算为全世界的经济促销。
张量加工单位已彻底改变了人工智能实施的方式。 TPU使您可以在手机上具有自然语言处理的服务器缩放处理，并为每个用户提供了使用翻译功能和文本的能力，以便在您的声音方便的方便。 TPU使得可以运行计算机愿景来在您的特斯拉斯上运行，并使其可以检测其他汽车，具有无可挑剔的准确性
虽然计算的进步一直是必不可少的，并且影响了超级计算机的创建，量子计算机，虚拟和增强现实，但系统仍然设计与普通客户的普遍客户。像口袋妖怪的游戏，彻底改变了手持游戏，并带有数百万人进入一个经常被降级的生态系统（电话游戏），经常被降级到运行图形无能为力的生活SIM卡。虽然游戏仍然只有加强现实的初步实施，但它仍然努力处理全球所有客户。
抛出钱和资源问题从来都不是世界上最大的媒体特许经营的关注。虽然niantiac（由任天堂，口袋妖怪公司和谷歌支持）能够解决这个问题，但并非每个开发商都休闲在该规模上进行实验，而且大o表示法有助于开发设计的时间和空间所施加的理论限制要求解决问题。
回答 7 这是缺点，"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">程序员真的必须知道如何为他们的程序计算大o吗？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:10+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="程序员真的必须知道如何为他们的程序计算大o吗">程序员真的必须知道如何为他们的程序计算大o吗？</h2>
<h3 id="回答-1">回答 1</h3>
<p>Matt Laine的答案是完全正确的 - 软件工程师应该能够评估他们的计划的表现并相应行动，或者否则可能会发生坏事。<br>
例如，我的一个同事曾一旦写过一种通过反复删除第一元素来处理C＃列表的算法。他没有意识到这是一个O（n）的操作，这使得总时间复杂度o（n ^ 2）。<br>
不幸的是，它没有足够的效果来抓住测试，但它确实对生产中的一些重要客户产生了问题&hellip;&hellip;</p>
<h3 id="回答-2">回答 2</h3>
<p>发生了什么是队列有点备份。这不是一个问题，除了检查队列中的成员资格是o（n）的问题，我们达到了队列足够长的地方，以便检查我们是否已经有SIMILA<br>
您无需了解有关校样和类似的信息的详细信息。你只需要一个想法，事情将会失控。<br>
这是一个例子：在生产系统中，等待处理的工作短队员。在向队列添加条目之前，完成了检查以确保该项目尚未在队列中。相当简单，对吧？<br>
发生了什么是队列有点备份。除了检查队列中的成员资格是o（n），我们达到了一个问题，我们达到了足够长的时间，检查我们是否已经在队列中有类似的条目需要时间超过时间。系统也无法从队列中删除条目。换句话说，队列只能运行，只要它少于X条目即可，它在大部分时间和测试期间都会进行。<br>
这是您必须了解的时间和空间复杂程度。我唯一一次听说实际上和正式使用Bigg o符号的时间是在20世纪80年代中期回到了大学时，​​他们试图将计算机科学成为实际科学。</p>
<h3 id="回答-3">回答 3</h3>
<p>不，不准确地说。但暴露于概念是好的。<br>
如果他们做任何最终有一些规模的事情，他们应该有一些相似的操作规模。如果描述这一点，符号是一种形式化的方式。如果它开始处理一些可敬的数据并学习如何避免问题，他们应该识别出荒谬的时间。例如：</p>
<h3 id="回答-4">回答 4</h3>
<h2 id="2如果算法是on--2或更差则在具有大n的数据集上运行它非常慢可能无法在合理的时间内完成on--n的算法这个概念在很大程度上是加密学基于的制作一个加密的cypher即使在最大的超级计算机上也需要100年的时间并且可能足够安全以保护数据长度比它更有用">能够为整个节目产生准确的大o计算复杂性很少必要，但是在使用非琐碎的数据大小并且相当容易时，在算法中具有直觉既非常有价值。让我们来看看它。<br>
假设我们在随机顺序中有5个随机数列表。<br>
[23,14,76,12,99]<br>
想象一下，我们编写一个软件功能来回答问题计算特定数量X中出现的次数，通过循环整个列表并将每个数字与x进行比较，递增计数器。该计划需要考虑的5个数字中有多少？答案是5，列表的长度。<br>
现在，如果我们制作任意大小列表，请说n个数字，这些数字中有多少个数字需要查看？答案是n，列表的长度。这称为程序的计算复杂性。<br>
我们将此写为O（n），每次执行函数时都意味着它会扫描n个数字，其中n是列表大小。这被称为Big-O表示法，因为我们在写它时使用一个大o。用英语，我们读到了这一点。<br>
考虑计算复杂性有两种主要原因。<br>
（1）在我们上面的简单示例中，如果我们的全部目标是回答关于一套数量的次数有多少次的问题，我们将要问这个问题真正大量的次数，我们可以做太多比O（n）好。<br>
理想的哈希表是O（1），因为我们采取了一个关键，基本上直接查找值。因此，如果我们将数据存储更改为哈希表，其中每个键是数字，每个值都是它发生了多少时间，然后我们可以使用这种新的数据结构来回答我们在O（1）时间内的问题（说明作为1次）。 o（1）当n = 5时并不多得多，但是当n = 10亿时，这是速度的10亿倍。<br>
（2）如果算法是O（n ^ 2）或更差，则在具有大n的数据集上运行它非常慢。可能无法在合理的时间内完成o（n ^ n）的算法。这个概念在很大程度上是加密学基于的。制作一个加密的Cypher，即使在最大的超级计算机上也需要100年的时间，并且可能足够安全，以保护数据长度比它更有用。</h2>
<p>真的只有一个人需要了解一个，然后我们已经完成了。<br>
BIG-O计算复杂性不是整个故事。故事的另一部分是每个工作单位所采取的时间。在上面的情况下，我们正在谈论使用平等运算符进行比较列表中的数量。计算机真的非常快，因此比较个别数字真的非常快，大约是微秒的顺序。<br>
但是，如果我们的算法中的每个工作单元正在做一些更慢的东西（例如寻求旋转磁盘，写入闪存，或通过网络谈话），则每个工作单元都需要毫秒。同样，我们可以谈论某种硬件传感，相机或采集任务的算法可能需要几秒钟甚至几分钟。<br>
这里的重要课程是，当您的工作单元更长（例如，秒）和您的n大，那么算法的大o复杂性就会变得更加重要。<br>
就是这样。如果您了解所有这些，那么您知道计算复杂性的基础知识，您所缺少的所有内容都是常见算法计算复杂性的一系列经验和了解。</p>
<h3 id="回答-5">回答 5</h3>
<p>是的，因为你必须要识别你是否曾经做过某种东西，因为几乎没有任何程序要求将容忍，除非不可能做得更好。有时甚至下限都太慢了。<br>
这并不意味着你实际上必须在写它的规划意义上除了你的头脑中的任何地方。您有程序，您可以在代表性工作负载上运行它，您不需要<em>计算限制时计算</em>运行时间，当您可以在确切的情况下测量它们。在事实上，它几乎总是更好地测量运行时间而不是计算它，因为您的计算几乎与首先写入程序一样复杂。<br>
当您拥有最严重的要求时，实时实时，您不会做任何计算。您必须以特定方式编写代码，具体的工具将确保您获得所需的性能。 （好的，你不必，但它真的非常好主意，如果你不这样做，那么它就会更加艰难）大多数东西是最糟糕的，但是，像服务器和操作系统和视频游戏一样软。只要你几乎一直生产出来的输出很快，那就好了，它足够好。很难实时是你有什么东西可以完全x毫秒来计算答案，做的事情或火车会崩溃，人们会死的，因为你可能猜到，确切的运行时间是重要的，而不是极限的近似值（AKA大o）</p>
<h3 id="回答-6">回答 6</h3>
<p>因此，为什么在处理器/计算机上运行您的程序/应用程序是必要的<br>
韩国表演初创公司，强调了对分析算法的需要。现场基本上是，打破了2个程序的领带，而它们基本上锁定在精度上的虚拟死热量。虽然该程序具有略高的精度，但在针对劣质计算机的同时略有较高的速度，但主角被声明了获胜者，以便能够提供一个系统，同时在Threadbare系统上运行时保持其一致性。<br>
那么，为什么在几十年前在计算中有进步时，在处理器/计算机/手机上有必要在处理器/计算机/手机上运行？<br>
CPU已经使电脑有高效。虽然单核处理器已经处于Moore Law的限制，但Muti核心和MUTI线程处理器已经更快地计算并使得可以在各种应用中无缝多任务。<br>
GPU使得可以拥有图形和FPS（每秒帧）。 GPU已经让您在笔记本电脑上观看4K电影，并在众多游戏中找到人类反应的理论限制（抽搐射手，平台，打架游戏）。虽然GPU被销售为一个爱好者的努力，但他们通过高艺术，采矿和云计算为全世界的经济促销。<br>
张量加工单位已彻底改变了人工智能实施的方式。 TPU使您可以在手机上具有自然语言处理的服务器缩放处理，并为每个用户提供了使用翻译功能和文本的能力，以便在您的声音方便的方便。 TPU使得可以运行计算机愿景来在您的特斯拉斯上运行，并使其可以检测其他汽车，具有无可挑剔的准确性<br>
虽然计算的进步一直是必不可少的，并且影响了超级计算机的创建，量子计算机，虚拟和增强现实，但系统仍然设计与普通客户的普遍客户。像口袋妖怪的游戏，彻底改变了手持游戏，并带有数百万人进入一个经常被降级的生态系统（电话游戏），经常被降级到运行图形无能为力的生活SIM卡。虽然游戏仍然只有加强现实的初步实施，但它仍然努力处理全球所有客户。<br>
抛出钱和资源问题从来都不是世界上最大的媒体特许经营的关注。虽然niantiac（由任天堂，口袋妖怪公司和谷歌支持）能够解决这个问题，但并非每个开发商都休闲在该规模上进行实验，而且大o表示法有助于开发设计的时间和空间所施加的理论限制要求解决问题。</p>
<h3 id="回答-7">回答 7</h3>
<p>这是缺点，<br>
虽然您可能不会积极地雇用它，但在您看到它们时，理解和识别问题是非常重要的。<br>
在我工作的另一个日子，我们正在设置一些代码来收集数据库查询性能的数据。基本上，我们制作了一个表，每次在DB中执行查询时，我们也将此表与查询的查询名称，开始时间和结束时间更新。这样做，我们已经能够收集有关我们最好的和最糟糕的表演查询的大量数据，并希望能够改善功能的加载时间。<br>
当然，这一切的缺点是我们现在每次与它做任何事情时都会击中数据库。就是这样，让我问你：<br>
一个人应该为此表添加索引吗？<br>
索引很棒，对吗？他们让您更快地访问数据。由于此原因，我遇到了默认索引所有列的开发人员。但是，就像软件工程中的一切一样，索引是一个权衡。插入DB时，还需要更新这些索引。<br>
没有索引，插入该表是O（1）。但是对于索引，每个插入都变为O（logn）乘以索引的数量。由于我们将以字面上的每个查询表现，那么对数复杂度可能会非常糟糕。<br>
如果我和其他开发人员对编程中的渐近复杂性没有了解渐近复杂性，我们可能已经实施了这一点，并观察了应用程序中的重大表现。然后我可以让我想象与产品团队的对话。跟踪性能太贵 - 它损害了用户体验。这不值得。我们提出了我们寻求解决更糟糕的问题，最终失去了我们试图找到改进我们的系统的数据，因为我们不明白索引如何影响我们的大O.<br>
这是一个罕见的事情，我需要弄清楚任何给定算法的渐近复杂性我写的 - 这种方式的性能问题只是我现在正常工作的规模只是罕见 - 但它是要注意的情况非常重要我刚刚描述的那样。此外，您将迟早在您需要开始思考性能的位置，并且当发生这种情况时，您需要能够在您看到它时识别坏大O。<br>
简而言之，你能否在不理解这个的情况下构建一个应用程序？绝对地。你能成为一个强大的软件工程师吗？不。<br>
希望能帮助。</p>
<h3 id="回答-8">回答 8</h3>
<p>大多数开发人员都不知道大o是什么，更不用说如何大约计算它。此外，最不知道哪种算法是对的。</p>
<h3 id="回答-9">回答 9</h3>
<p>他们至少需要了解它。<br>
有几年前，我正在使用分析DNA序列的程序组。一个程序必须以序列读取在多行上的ASCII文本。别人用外观写入输入例程，将缓冲区读入缓冲区，并将strcat（）读到先前读入的零件上。听起来很好且简单。<br>
它是o（n ** 2）。<br>
在某个时候，我们正在使用高达10MB的序列（即10兆塔，而且还存储在ASCII文本中，所以10兆字节。）输入例程是程序最慢的部分。<br>
希望所有人都理解为什么strcat（）循环是o（n ** 2）。<br>
如果没有，那<br>
他们至少需要了解它。<br>
有几年前，我正在使用分析DNA序列的程序组。一个程序必须以序列读取在多行上的ASCII文本。别人用外观写入输入例程，将缓冲区读入缓冲区，并将strcat（）读到先前读入的零件上。听起来很好且简单。<br>
它是o（n ** 2）。<br>
在某个时候，我们正在使用高达10MB的序列（即10兆塔，而且还存储在ASCII文本中，所以10兆字节。）输入例程是程序最慢的部分。<br>
希望所有人都理解为什么strcat（）循环是o（n ** 2）。<br>
如果没有，那就是你需要计算它的原因。</p>
<h3 id="回答-10">回答 10</h3>
<p>短暂的答案是肯定的。学习如何计算大O是了解算法性能可能取决于数据集大小的第一步。严格说话，您无需为您的算法计算大O来了解这一点。<br>
另一方面，大o是科学研究的基础。如果您想在科学期刊中发布一些巧妙的算法，则需要大O.如果您为拓扑建模或类似的任务编写矢量代码（即MATLAB），则需要大O.</p>
<h3 id="回答-11">回答 11</h3>
<p>而我从未计算过<br>
程序员真的必须知道如何为他们的程序计算大o吗？<br>
我从来没有计算过职业生活中的复杂性。但我很高兴我在大学学到了它，因为它给了我对一直出现的问题的基本理解。<br>
它归结为我概念化为程序控制流程的“形状”。即使你从未准确计算过东西，这通常是非常重要的。它有助于您了解您应该或不应该循环或重复的地方，并构建您对如何构建代码的思考。<br>
虽然我从未计算过复杂性，但我已经测量了它。与教科书的示例不同，其中原始操作为您为您定义，在现实世界中，它不一定是明显的，您需要小心。线性比二次级更好比指数更好，但是当您有交互系统时，可能使用本地指数算法更好地关闭，以避免涉及I / O和远程呼叫的某些操作的线性增长！但是，一次或两次IVE在合成数据集和经验测量的生长因子上设置基准，以帮助弄清楚问题的位置。一旦我最终将一个函数优化到如此难以理解的东西，即我在功能中使用的线条少于注释，解释为什么没有人应该将其重写为更明确和可维护的版本&hellip;&hellip;这是在一个系统ID中没有对数学建模的希望但是，我可以并确实在不同的输入大小和绘图n与运行时间上运行它，以及分析，看看代码的哪些部分与总时间成比例。在任何时候，我实际上使用数学超出了我需要在电子表格中制​​作图形的数学，但学习计算复发关系是建立了我原油方法工作的直觉的原因。</p>
<h3 id="回答-12">回答 12</h3>
<p>所以只是血腥学习它<br>
如果没有知道如何做到这一点，你可以成为一个程序员。<br>
然而，一个好程序员可以解释他们的程序的性能如何与输入的大小扩展，大问题是被发明的数学术语表达。在不了解它的语言的情况下，很难对算法的可扩展性特性进行任何准确的陈述！<br>
此外，人们假装这是这个噩梦的概念，这将杀死他们必须学习。实际上，它实际上并不复杂，至少基础是不是。<br>
所以只是血腥的学习！无论你是否真的都要少了痴迷时间就花了更少的时间。</p>
<h3 id="回答-13">回答 13</h3>
<p>我想这取决于你的意思。对我来说，通常足以知道算法小于指数。有时我需要知道n ^ 2和n ^ 3之间的区别。我不记得我最后一次需要知道它是否是log n或n log n或log（log n）。大多数时间都足以知道该算法并不令人震惊。</p>
<h3 id="回答-14">回答 14</h3>
<p>Ill Echo Alan Mellor和其他人说，对无症状复杂性（大O）更重要。<br>
知道哪种操作昂贵。如果n小，则磁盘读取可能比O（n ^ 3）循环更昂贵。<br>
表现的实际概念比严格的性能理论更重要。<br>
那说&hellip;&hellip;<br>
如果您申请了研究职位，最好是正式了解无症状复杂性。<br>
另外，如果你是一个新的毕业生。此时，您可能有更少的实践经验，面试官可能会检查您在学校注重关注。<br>
有<br>
Ill Echo Alan Mellor和其他人说，对无症状复杂性（大O）更重要。<br>
知道哪种操作昂贵。如果n小，则磁盘读取可能比O（n ^ 3）循环更昂贵。<br>
表现的实际概念比严格的性能理论更重要。<br>
那说&hellip;&hellip;<br>
如果您申请了研究职位，最好是正式了解无症状复杂性。<br>
另外，如果你是一个新的毕业生。此时，您可能有更少的实践经验，面试官可能会检查您在学校注重关注。<br>
还有一些大型技术公司会问这些问题。了解他们是否确实问了他们，​​然后准备面试。<br>
在其他情况下，人们不会如此严格。</p>
<h3 id="回答-15">回答 15</h3>
<p>一般来说，是的。<br>
我需要知道如何为我的程序估计大o。我不需要经常这样做。我不需要精确计算代码的O编号。我不需要为整个计划做到这一点。但我需要为它的关键部分做到这一点。<br>
我需要做什么：<br>
在20年作为软件工程师工作期间，由于算法的低效选择，我的代码有很少的时间。很少有，但他们是至关重要的。当我不得不为LZW或BZIP2算法实施解压缩器时，最令人难忘的是我的第一份工作。我决定削减角落，并使用常规泡沫而不是Quickssort。结果，我的代码几乎无法使用。<br>
随着时间的推移，我几乎本能地开始为我的代码估算大问题。</p>
<h3 id="回答-16">回答 16</h3>
<p>我们这样做，虽然现实上，说我们想要了解大欧米格或大职，但它真的很准确地说我们想知道我们的算法是否是或不是子地区。二次（即，大欧米茄或n个平方的大θ）或更糟糕的是坏事。子地区是可接受的。<br>
Knuth中的定义是（我希望）非常简单。如果您有兴趣，请参阅第1.2.11节。IIRC，您只需要了解限制理论，因为大o及其朋友只是运行时的渐近极限。</p>
<h3 id="回答-17">回答 17</h3>
<p>技术上不，但你*真的应该。<br>
非常同样，会计师并不需要知道如何添加和乘以数字以管理您的财务状况，因为它们可以使用计算器为它们执行此工作，即使他们真的不知道如何添加和乘以。<br>
但我不会雇用这样的会计师。</p>
<h3 id="回答-18">回答 18</h3>
<p>有一个很好的理解<br>
不是那么多，但是对常见数据结构和算法的时间复杂性和实现的理解很重要。例如，如果您正在编写某些阵列/向量/尺寸M的阵列/载体列表中的代码，并且在此阵列中执行线性搜索，那么知道这是O（m * n）并赢得了对于大的m和n刻度很好。并且，一些更好的选择可能是保持阵列排序和使用二进制搜索，或者使用不同的数据结构，如地图或哈希表，可以让您O（n log m）或更好，并且明显更快。<br>
对数据结构和算法具有良好的理解，以及它们对各种操作的一般属性和时间复杂性非常重要。一旦我分析了一些花费太长的代码，并且在其他事情中使用MFC CMAP类，其中内部使用哈希表。现在，设计良好的和正确使用的哈希表可以在最佳情况下获得O（1）查找。但是挖掘MFC源代码，我看到这个哈希表正在使用一个固定大小的数组，17我认为它是，而且永远不会越来越多的内部阵列，导致许多哈希冲突。我们正在将成千上万的元素放入其中。所以基本上在哈希找到正确的桶后，代码正在在该桶的链接列表中进行线性搜索，以查找所需的元素。因此，我无耻地复制了MFC代码并修改它以创建自己的版本，它将动态地增长哈希表大小，因为添加了元素。了解哈斯赫表的工作以及它们的属性是如何理解和解决问题的关键。</p>
<h3 id="回答-19">回答 19</h3>
<p>在我的经历中，这很少发生。通常有人在设计讨论中的优化讨论期间或更早地提出它。<br>
现实世界的程序员通常采取最实用的方法，即，我的计划是否在分配的时间和资源框架内做了什么？如果答案是肯定的，则没有更多的讨论。基本规则是机器时间总是比编程器时间便宜，除非在计算资源或时间内有巨大的节省，否则您只需将其留下即可。<br>
但是，如果您正在使用受限制的资源或时间，实用方法是配置代码。它的原因是，任何现代的非琐事程序都将使用一堆库，并且这些图书馆将使用其他库，并且绝对没有办法了解所有这些的复杂性，除非您阅读所有代码。但读取库代码击败了使用库的目的，因此除非读取库代码的具体原因，否则您不会这样做。但是，您所做的是您的代码的个人资料。您在探查器中运行代码，您可以在您的代码中学习最多的时间。<br>
代码分析经常返回惊喜，您的代码花了很多时间在您永远不会想象的地方。特别是，当您使用除其预期目的之外的其他内容的库时，会发生这种情况。然后您以适当的方式优化代码。您可以重写代码位，您可以更换您使用的库，可以优化您的数据，以便您需要更少使用昂贵的操作，您可以为您的数据介绍缓存，因此您不必经常获取它，解决方案是多样的，也是如此问题。<br>
一般来说，您很少需要计算您程序的复杂性，实用方法是更常见的。</p>
<h3 id="回答-20">回答 20</h3>
<p>你在这里得到了很多答案，这不是真的<br>
但这取决于&hellip;&hellip;这取决于<br>
对于你可能做的大部分工作，它并不重要。对于一些工作，它确实很重要。<br>
在典型的业务应用程序上工作，您可能会很少有此类讨论。<br>
我创建的一个产品是一个数据库<br>
我可以向你保证，当我们在建造东西时，有很多地方发生了大o讨论的地方，因为&hellip;&hellip;嗯，在建造这样的事情时你需要拥有它们。当我们在索引中有一个哈希碰撞时，实际发生了什么？我们最糟糕的情况是什么？<br>
你在这里得到了很多答案，这不是真的<br>
但这取决于&hellip;&hellip;这取决于<br>
对于你可能做的大部分工作，它并不重要。对于一些工作，它确实很重要。<br>
在典型的业务应用程序上工作，您可能会很少有此类讨论。<br>
我创建的一个产品是一个数据库<br>
我可以向你保证，当我们在建造东西时，有很多地方发生了大o讨论的地方，因为&hellip;&hellip;嗯，在建造这样的事情时你需要拥有它们。当我们在索引中有一个哈希碰撞时，实际发生了什么？我们可能看到的最坏情况是什么？这可能是病态的，需要在生产中发生之前被思考。</p>
<h3 id="回答-21">回答 21</h3>
<p>重要的是要记住那个符号背后的想法，因为是一个有效的团队沟通的被证明的工具。所以它不是严格必要的，但它是非常可取的。</p>
<h3 id="回答-22">回答 22</h3>
<p>我们遇到了许多例子，这就是Buil的本质<br>
不完全，但我想我可以在没有殴打死马的情况下添加一些东西，并重复其他人都在说什么。<br>
大O的基本思想与速度快速制作课程，因为它是关于了解计算资源的限制，以及您的代码可能会影响到这一点。<br>
例如，我们知道如何从点A到B获取，但计算机无法有效地执行此操作，因此我们必须使用不同的策略来解决这个问题。这是经典旅游推销员问题，一个难题的问题。<br>
我们遇到了许多例子，这就是建立超出基础知识超出任何规模的软件的本质。您可能不得不考虑记忆和速度。<br>
大学课程使用排序算法，因为它是概念最简单的插图，但是一个好的程序员可以将这些想法应用于更复杂的例子。至于各种类型，我们编程语言中的功能将比我们可以在99.9％的时间内写入的更好。</p>
<h3 id="回答-23">回答 23</h3>
<p>不，但他们应该能够感觉到它，至少大约。如果您处理大量数据，它通常变得重要，否则您可能会自由地忘记它。<br>
例如，如果在它们中的每一个中使用N个元素（或其他号码）的线性循环，则每个循环大致有助于新的O（n）产品项。在分割和征服算法的情况下，通常是O（n * log n），用于二进制搜索它是o（log n）等。<br>
顺便说一句，有时编译器可以优化某些类型的循环，因此它们变得更低的复杂性。有时候，很少在程序员的现实生活中。甚至那么，还有许多其他因素影响程序的性能，例如您的数据结构和算法是缓存/存储器/线程/资源/注册友好等。</p>
<h3 id="回答-24">回答 24</h3>
<p>你必须有一个感觉，你必须有一个意义对它的重要事件。<br>
如果您正在拍摄用户输入或给用户输出，请忘记它 - 没有人关心，计算机比人们快得多。<br>
如果您从股票代码中获取输入并将计算写入磁盘，那么您应该知道。<br>
如果您在喂养实时医疗设备，那么您该死的更好。</p>
<h3 id="回答-25">回答 25</h3>
<p>这是一个相当常见的技能，很少（虽然不是永远）所需的;没有那种能力是一个小小的缺点，而不是一个主要的缺点（如果需要，你可以问团队中的别人寻求帮助&hellip;&hellip;如果你自己编写了编码，那么就没有办法对这些问题有关的规模）。<br>
但是，当您需要能够计算该价值时不知道何时更严重。</p>
<h3 id="回答-26">回答 26</h3>
<p>另一方面，您可能想要驾驶赛车并推动违法行为<br>
是的！这就像询问司机是否真的需要知道如何改变他们的车辆的档位。<br>
当然，如果您在完全平坦的区域中驾驶自动传输，那么您不需要非常做。但是这一天你可能决定乘坐公路旅行到落基山脉去滑雪。您将不得不驾驶大量陡峭的倾斜和下降。如果您不知道如何换档，您将通过刹车片穿过刹车垫，并了解侧面的失控车道是为了艰难的方式：/。<br>
另一方面，您可能想要驾驶赛车并推动速度的边界。是的，你需要了解一些Snazzy双夹紧技术。<br>
更广泛地说，我发现很多这些Quora问题是相当于我真的需要流利的法国人成为一名法语时，我只想订购咖啡吗？不，你不需要流利地订购咖啡，但是你这样做是为了成为一个实际讲法语的人&hellip;&hellip;除非你很高兴成为这个陌生人坐在一个不明白任何人的角落里偶尔跳起来，每次跳起来喝咖啡&hellip;&hellip;</p>
<h3 id="回答-27">回答 27</h3>
<p>脚注<br>
我是我博士的一部分。复杂事件处理的论文工作（A.K.A.事件监测/事件组成）[1]。我会说程序员实际做到这一点罕见，它需要很多工作。我使用复发关系做了我的，当我解决了他们时，我必须考虑基于启发式的渐近方面，以简化复发关系。我还基于运行实验证实了时间复杂性。<br>
<!-- raw HTML omitted --> [1] <!-- raw HTML omitted --><br>
但是，正如许多人所提到的那样，专业程序员对此感受/直觉及其后果。如果您实施/设计算法，则必须遵循数据结构，并且数据结构必须设计为适合您的算法。该组合通常应求解一组相关问题，而不仅仅是一个相关问题。在设计算法和数据结构时，应解决关键问题，其中经常使用关键问题和/或（真的只或）对结果产生重大影响。它是一个批处理问题，在哪里可以进程处理数据？数据是不可变的吗？在您运行您的算法时可以发生变化，以及如何处理那个？<br>
无论如何，您通常可以查看数据结构，考虑您应该做些什么并弄清楚复杂性。但是，如果您应该比较两个相同复杂度（类）的算法，那么它变得更加困难。您可以通过推理来估计这一点，但有些情况令人棘手。通常，您比较不同复杂性的算法，然后唯一的问题是如果您处理大批数据（如果它很小，则其他因素可能比复杂性更重要）;例如，在Java中，您会注意到哈希映射和树映射之间的差异约为100.000秒的对象。<br>
就个人而言，我从数据结构开始（OOP的焦点），并在这样做时考虑功能。基本上，我尝试优化用于关键需求的数据结构，从而管理可扩展性和性能。例如，如果您可以遵循鸿沟并征服策略，则获得类似O（x log n），其中x基于您对数据的作用，并且日志n必须处理搜索/迭代的部分数据。在这种情况下，您可以通过对索引进行排序或通过维护索引来执行此操作。<br>
脚注</p>
<h3 id="回答-28">回答 28</h3>
<p>不，但他们必须知道计算复杂性作为概念。<br>
此外，只要您正在进行新任务，您需要确保您处于最低可能的Compslexity类中为您的问题。否则，您的Web服务器将需要90秒才能响应，并且您将能够在Web服务器上支持4个用户而不是10000。所有因为您没有将小丑从汽车中拿出来。<br>
此外，如果您不了解算法复杂性，您将被降级到The The Crud应用程序直到时间结束。</p>
<h3 id="回答-29">回答 29</h3>
<p>在一些数学应用程序中，我写的是我需要知道程序是否在某个时间范围内完成（例如我的生命周期），并且知道大O是有用的。</p>
<h3 id="回答-30">回答 30</h3>
<p>取决于程序员正在进行的工作，它有很大的变化，它有点取决于你的意思。很少有程序员做出如此严重的算法开发，以至于它们必须对异国情调算法进行复杂分析。但是，重要的是严重程序员对时间复杂性的一致了解，并且知道如何构建没有严重问题的算法。在实践中，这通常意味着选择从中构建更大算法的尝试和真正的算法，因此程序员很少实际上直接考虑时间复杂性。更重要的是他们对它有直观的理解，并知道如何避免陷阱。<br>
当然，要理解的另一件事是，在任何主要的软件中，通常只有一个微小的软件都包含任何有问题时间复杂度的算法。绝大多数软件是通常是线性时间复杂度的结构代码。换句话说，对于绝大多数编程工作，时间复杂性并不是一个问题。</p>
<h3 id="回答-31">回答 31</h3>
<p>不经常。您莫尔常常需要能够判断给定的算法是否比特定O刻度得多。如果您尝试竞争算法的影响，则可以在规划阶段中使用。虽然我的知识EOF算法复杂性绝对是指导我所做的决策，但我从未明确计算过，但了解如何和影响的知识可能是最重要的。</p>
<h3 id="回答-32">回答 32</h3>
<p>正如其他回复所指出的那样，程序员需要具有可扩展性的感觉。他们需要知道（以及其他事情）是什么指数增长，以及它如何影响他们的计划。<br>
我记得一个用户问我是否可以编写一个程序来打印出一堆字母，在某个代码中可以混合。<br>
我并不完全确定他们想要的东西。是的，我可以编程。如果您知道如何编程递归，它真的很简单。<br>
即使产生所有组合也会在这种情况下采取合理的时间，因为代码相对较短。<br>
问题正在打印它们。该计划将印刷数百万代码基本无用的信息。<br>
所以我所做的是，一开始就告诉用户请求这一点，关于国际象棋的起源的传说。然后我向他们估算了在这种情况下结果的大程度。</p>
<h3 id="回答-33">回答 33</h3>
<p>程序员真的必须知道如何为他们的程序计算大o吗？<br>
我从未听过大型讨论的程序。原因是大o描述了算法的渐近运行时间。除了用单一用途设计的程序外，仅执行单个算法，它不会延伸到程序。虽然它当然可以讨论一个完整程序的聚合，这涉及讨论渐近行为，而该程序实际上并不是在尺寸接近无穷大的输入上运行。<br>
此外，没有办法指定每个程序的大o行为。这个问题与停止问题有关。如果我们无法确定程序是否停止，我们当然无法说明它是否是有限的或无限的。</p>
<h3 id="回答-34">回答 34</h3>
<p>我不知道如何计算任务的复杂性。有两个关键的想法：了解大o，并了解它是如何谎言的。它确实如此。<br>
例如，假设我有一个问题以排序顺序存储10,000个32位整数。将有很多插入和删除。我应该将它们存储在列表中还是在数组中？<br>
BIG-O可能会建议插入和删除的列表更快。但它不考虑找到插入或删除该项目的地点的成本。此外，如果将其存储在列表中，每个列表单元将在开销的64个字节的顺序中添加，这涉及大量的存储空间。此外，根据插入和删除的数量，元素可以散射全部内存。这意味着页面错误。每个页面错误比缓存命令慢七个数量级。 Big-O表示法告诉您计算尺度增加的域大小，但它并没有告诉您O（f（n））真的意味着c * f（n），其中c是比例常数，a单一操作。除了它不是一个常数;多级缓存和页面故障意味着在每个计算上，您不知道它是否成本1或成本300,000,000，因此这种变化违反了大o符号的基本假设。三阶效果可以杀死你。拒绝数组表示最终更快。这是几十年前在Lisp机器的设计中被证明的。</p>
<h3 id="回答-35">回答 35</h3>
<p>知道怎么？是的，这不是那么困难，但乏味，需要一段时间。然而，您没有真正需要，因为您应该在经验中，能够觉得某些东西会以高速表现出来，EX。制作一个游戏并说它像100个敌人一样可以立刻在屏幕上，它不会滞后</p>
<h3 id="回答-36">回答 36</h3>
<p>大o指的是算法而不是程序。根据他们使用的排序，索引或搜索算法，他们将理解他们的程序所需的时间和空间。</p>
<h3 id="回答-37">回答 37</h3>
<p>对于现实世界的编程，它是一个经验的规则。<br>
看看你的循环，询问它最大可能的操作的大问题应该是什么。将循环的顺序乘以。因此，如果您有带有行和列的图片，并且您对每个单元格执行DB查找并编写。最慢的部分是写入。让我们说出它的成本= n x（log_128（n）-2）（因为你的记录可以适合每个磁盘页面和它的b树。预期50％的占用率，并且前两个级别几乎总是缓存）。注意其n，而不是n ^ 2，其中n是宽度倍。这是正方形和双回路的事实是一个诡计。上面的大o是n log n。但是您可以估计最慢的操作的实际数量：IOPS。<br>
现在，如果您想计算具有连接的DB查询的成本，则YOUD在表1中具有n个记录，以及表2中的M记录。您扫描表1，但在表2上执行日志M查询（记住该日志基座128和负2更逼真）。所以我们有n x log m，buut。当n接近无穷大时，m看起来更像是一个常数。我们的查询实际上是o（n）。然而，这是一个他妈的迟到的估计。我的拇指规则是将m作为n（这是谎言，而是更有用的估算者）<br>
现在想象一下，我们的存储过程，对于表1中的每个元素，基于一些非索引约束来计算表2中的过滤的计数成本。即我们漫步表1，查看属性和Requery表1（所有记录），然后加入对表2的每个元素（我们的日志M表）。现在我们有n x n x log m.如果我们眯起其很难是n ^ 2 log n.清楚地，谁写它并在共享生产硬件上运行应该被解雇。因为创建一个临时表可以摆脱连接，然后将n ^ 2缩小到n log n的地图减少算法，所以现在你在最坏的情况下有n log n + n log m。 。或者只是n log n的大o（用良好的地图减少，你的日志基础是100万，而不仅仅是128）<br>
最后部分是理解大O非常有用。为什么在AWS的Hadoop或EMR上花费很多钱，而刚刚在Postgres中运行了查询（并且必须解释为CTO的原因）是良好和坏产品/公司之间的区别。<br>
更常见的二进制树与哈希映射O（n log n）vs o（k）对话是bs，因为这假设您可以将随机存取存储器扩展到无穷大（如您可以使用基于网络磁盘的DBS）。哈希似乎甚至在小规模上几乎总是更快的哈希。</p>
<h3 id="回答-38">回答 38</h3>
<p>它不是计算。它关于大o（）代表的定义。<br>
举例：<br>
a = b * c<br>
是O（1）吗？<br>
好吧，我们假设是。但在这个例子中，缺少一个重要的事情，这是值的类型。因此，只有当这些数字被告知整数时，它将是O（1）。<br>
假设数字是大小的1000个二进制数字。<br>
即使您的语言像Mathematica，Matlab或C与支持数学的图书馆，表达式仍然是表单<br>
但后面的编译器将生成此类计算所需的两个嵌套环。外循环用于迭代B和内部的块<br>
它不是计算。它关于大o（）代表的定义。<br>
举例：<br>
a = b * c<br>
是O（1）吗？<br>
好吧，我们假设是。但在这个例子中，缺少一个重要的事情，这是值的类型。因此，只有当这些数字被告知整数时，它将是O（1）。<br>
假设数字是大小的1000个二进制数字。<br>
即使您的语言像Mathematica，Matlab或C与支持数学的图书馆，表达式仍然是表单<br>
a = b * c<br>
但后面的编译器将生成此类计算所需的两个嵌套环。外循环用于迭代B和内圈的块，用于迭代C组，转换它们并应用求和。<br>
所以它还是o（1）？<br>
这是Big-O（）表示法的问题。您必须知道某些特定的代码如何在某些特定硬件上执行。<br>
在具有并行硬件乘数的假设CPU上，让我们说1024位仍然是O（1），但在日常计算机上它不是。当您继续增加数字数量时，它变为O（n ^ 2），其中n表示由硬件乘数的块大小除以划分的数字数。</p>
<h3 id="回答-39">回答 39</h3>
<p>我在其他帖子中介绍了这一点，但我会在这里重复，因为它是一个重要的主题。首先，在大学中，您有三个基本课程（和数据结构。）基本课程，高级课程和数学分析课程。最后一门课程几乎总是毕业计算机科学课程，学生需要强烈了解基础知识，因为算法分析通常是毕业计划中最具挑战性的课程之一。<br>
但中产阶级也有一些数学分析。通常是学生学习大O的课程。你学会一般应该做的是什么以及你不应该做什么（总有例外！）。高级数据结构类开头的一点数学有助于学生了解他们为什么需要了解此东西。<br>
每天都是人们计算大O？不。不是大多数工作。除了求职面试外，人们还记得大o吗？不。再次，不是典型的工作。如实，我认识那些梦幻般的Web开发人员 - 比我更好 - 谁没有，因为现代框架隐藏了它们。只知道这些东西不会让你比那些没有的人更好。<br>
它有用吗？绝对地。一些工作确实要求人们了解算法。</p>
<h3 id="回答-40">回答 40</h3>
<p>这是我的秘诀。<br>
如果您想了解大O，只需运行不同数量的数据样本S这样的代码S 1,10,100,1000或更多，并且计算它运行的时间。<br>
大o用于告诉如果增加数据样本，则会判断一部分代码的一部分代码。你不需要准确，但你应该知道粗略估计。<br>
大o是上限。</p>
<h3 id="回答-41">回答 41</h3>
<p>我是一名程序员的懒惰恐龙，他们可以节省努力。<br>
我可以计算&rsquo;大o'？是的。<br>
我吗？如果我能帮助它。<br>
我的重点是问题。错误的答案快速比正确的速度更慢。<br>
那个泡沫排序我写道（最糟糕的是*），谁在乎？它是用于排序有计算机等待的100个记录，同时用户在用户键入中，然后再次等待它吹口哨Dixie暂停串行端口吐出。<br>
然后有多百万记录银行申请转换，在漫长的周末运行中需要72小时。这需要8个小时<br>
我是一名程序员的懒惰恐龙，他们可以节省努力。<br>
我可以计算&rsquo;大o'？是的。<br>
我吗？如果我能帮助它。<br>
我的重点是问题。错误的答案快速比正确的速度更慢。<br>
那个泡沫排序我写道（最糟糕的是*），谁在乎？它是用于排序有计算机等待的100个记录，同时用户在用户键入中，然后再次等待它吹口哨Dixie暂停串行端口吐出。<br>
然后有多百万记录银行申请转换，在漫长的周末运行中需要72小时。扫描文件需要8小时。我的客户匹配分部24小时分配（是Bryan White&rsquo;的同一个人&rsquo;B White吗？电话号码看起来类似但不同的前缀）。然后其他部分花了太久;我可以减少我的吗？<br>
经过一些研究，我说&rsquo;是的;给我2个小时，他们说是不可能的。<br>
不，如果我之前的一周匹配每个人，那么只需匹配这些少数，从那时起，漫长的周末就会有记录的更改。哦。这是一个好主意。<br>
&lsquo;大o&rsquo;甚至看起来都看起来。<br>
*好的，是的，你可以写得更糟糕，但我在这里是平淡的。</p>
<h3 id="回答-42">回答 42</h3>
<p>不是特别的，它真的可以是非常人为的，而它给出了对潜在问题的粗略期望，而不是确定代码的唯一方法是合理的。<br>
最准确的方式是体面的性能测试。您只需要勤奋，并确保您可以达到更糟糕的输入和用法的情况。其中在于优势，它通常是并发访问的动态，导致问题或像缓存和内存大小等阈值因素，或锁定和信令限制。您还需要大衡边缘收益是否值得额外的代码时间。一个月运行一次，几小时内运行的操作不需要优化（在原因内）。时间将更好地花费在其他地方优化或做更多的测试来检查代码的逻辑。在现实世界中，您必须准备延长时间贸易，我们并不真正有不断追逐完美的奢侈品。<br>
考虑到在现实世界的节目中常常有多少点，以确保质量，我永远无法设想时间将更好地花费计算复杂性过度测试的情况。它纯粹是一个学术工具，让新的程序员了解写作代码时要了解的内容。当您在商业上编写代码的时候进行编写到生产，人们希望您有足够的掌握，以便不需要正式做到。您应该能够查看您的代码并在其运行中的上下文中了解其影响。<br>
当然，这就是这些日子往往倾向于崩溃的地方。似乎新一代编码器并不真正了解其代码的影响。对他们来说，这是魔法，更像是吟唱一个咒语，然后一些仙女来了做这项工作。代码和实际操作之间的连接已丢失。人们维护您不需要在这一深度时知道的事情，但他们的系统否则证明。您可以抛出硬件一段时间，但最终的成本且往往是差的可扩展性意味着它达到了限制并停止工作。更多地编程比知道如何分配变量并写入循环。不幸的是，行业似乎忘了。</p>
<h3 id="回答-43">回答 43</h3>
<p>虽然当我们编程我们从未计算过&rsquo;正式&rsquo;算法的效率，但研究了如何做到这一点，以便意识到计算资源，主要是时间和内存非常有限。<br>
在我的经验中，您可以轻松地常常看到已经研究过“正式效率算法分析”和那些没有的程序员的差异。</p>
<h3 id="回答-44">回答 44</h3>
<p>在30多年的写作代码中，我从来不得不明确计算大O.我们基本上只是避免用已知的病理性能特征（泡沫分类，线性搜索等）写作任何东西。<br>
鉴于现代语言提供现在管理数据的各种漂亮的内置容器（词典，地图等）真的不需要。</p>
<h3 id="回答-45">回答 45</h3>
<p>这是一个非常可怕的视频。（对于记录，它在这里。我不会花太多时间撕裂它，但它很浅，误导，偶尔是平凡的。它甚至没有提供大O的定义！） 。你多么需要了解大量符号，我不能告诉 - 我的妈妈没有知道关于它的任何东西，也不知道一个合理的快乐和完成的人。但是，如果你想了解如何研究职能的增长，包括算法分析，然后你应该找到其他来源来学习这一点，而不是这个YouTube视频。知名的东西是绝不是能够背诵定义。我会在片刻里给你一个大o的定义，它相当短明确。在一个正式的意义上，这就是你需要知道的一切：只有其他一切都可以从它中衍生出来。然而，现实，学习使用，申请和玩大o表示练习，耐心和时间。永远，曾经期望知道你需要了解的一切主题从youtube上的5分钟视频。结构围绕着理解的学习，而不是可怜的快捷方式。你知道所有你需要了解大问题，当你能够有效和一致地解决与它相关的问题时，而不是你的问题在Quora.ok上看了视频或阅读答案。 Big O表示法意味着：我们有两个功能f（n）f（n）和g（n）g（n），以自然数nn为实数为输入和返回值（这可以进一步概括，但是现在没关系）。我们这么说<br>
f（n）= o（g（n））f（n）= o（g（n））<br>
如果满足以下条件：存在一些阈值N0N0，以及一些相称常数CC，以及<br>
| F（n）|≤c| F（n）|≤c| g（n）| g（n）|<br>
每当n≥n0n≥n0.in：f（n）f（n）是g（n）g（n）的大o，如果g（n）g（n），也许乘以某种东西，则最终大于f （n）f（n），如有必要地看绝对值。这一切都是寒冷的，形式的定义，就像我在某种意义上说这是你所需要的。但是你可能觉得定义是不透明和混乱的定义如果你以前从未见过这一点，这很好。努力工作是通过它的意义来源的，为什么它的建造以及如何使用它。大O表示法的使用延长以允许O（g （n））O（g（n））在表达式，方程和不平等中更灵活地显示出更灵活。例如，<br>
n2 + o（log（n））n2 + o（log⁡（n））<br>
表示具有n2 + f（n）n2 + f（n）的形式的函数，其中f（n）= o（log（n））f（n）= o（log⁡（n））。我们没有指定f（n）f（n），我们甚至没有打扰它一个名字：我们关心的是它是O（log（n））o（log⁡（n））。以这种方式您找到了例如，陈述<br>
log（n！）= nlog（n）-n + o（log（n））log⁡（n！）=nlog⁡（n）-n + o（log⁡（n））<br>
这表达了log（n！）log⁡（n！）的事实由nlog（n）nlog⁡（n）主导，并且下一个最有意义的贡献是-n-n术语，然后有一些剩菜这少于日志（n）log⁡（n）。这是一个理解斯特林的近似的一种很好的方式。您可能已经注意到，在定义中没有发现这个词算法.big o表示法在分析中非常有用算法，但它在一百个其他环境中也非常有用。在任何关于学习分析数字理论的人（Bachmann，Landau）的人的算法复杂性思考之前是很久的发明。我们在19世纪末谈论了这一点。现在，为什么这个定义？大o符号的目的是帮助我们研究职能的增长。当在组合者的表达式，数字理论，复杂性理论，复杂分析和其他地方分析表达时，了解最终会赢得胜利，以及最终赢得谁通过多少。例如，如果您比较函数10n10n和n！n！，您可能会发现，最初，10n10n是更大的。检查n = 1,2,3,4,5n = 1,2,3,4,5甚至n = n =的那些函数的值。 10n = 10;你怎么看？似乎10n10n赢得了一夜之间。<!-- raw HTML omitted --> n = 1：10与1 n = 2：100 vs 2 n = 3：1000与6 n = 4：10,000 Vs 24 n = 5：100,000 Vs 120 n = 10：10,000,000,000 vs 3,628,800 &lt;/ OL&gt;</p>
<!-- raw HTML omitted -->
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
