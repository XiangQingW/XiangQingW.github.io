<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？ | 知识的阶梯</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？ 回答 1 我不喜欢这个想法，除非物体中的一切都是公开的，或者仅受保护，而不是私人。
如果是的话，因此您可以使用扩展来修复错误。当然，这具有利用相同对象的人的副作用，必须继续与错误一起生活。
这意味着在实践中的原理意味着拧紧其他人，只要它适合我。
否则，如果有真正的私有部分，原则要求您与错误一起生活。这是无法接受的。
回答 2 这一原则是为了确保在其行为中可预测的共同特征，并且不会因个人要求而被操纵
是的，这是一个伎俩问题。面试官可能正在检查您在坚实的“开放式”原则上的理解程度。
“开放式”原则表示，实体应该开放到扩展，但关闭到修改。这意味着您可以使用代码中的功能/库方法，以扩展该功能已在做的内容。但您应该避免将/添加代码更改为共享库方法本身，以满足您的特定要求。
这一原则是确保在其行为中可预测的共同特征，并且不会因其消费者的个人要求而被操纵。它有助于减少添加到共享方法的错误变化的广泛副作用。
如果在常用函数中存在缺陷影响其消费者，则可以更改常见实体以解决问题。 “关闭”部分原则不是在行为不端时未修复功能本身。但是，在修改代码以解决问题之前，开发人员需要确保它实际上是常见功能的问题，而不仅仅是在特定扩展中使用它的错误使用。
回答 3 不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果接线出现问题，那就是错误的
不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果电机可以解决问题会出现问题，这将是错误的修复它？当然不是。这些是两个单独的问题 - 一个关于系统的适当设计理念，另一个关于有价值的特征的实际交付。
所以它与所有的固体原则有关。您通常应该避免用许多职责写作方法。给定类的目的应该是连贯的，具体的尽可能具体。您的所有子类通常都应该替代他们的父类。等等。
所以情况是开放式原理。如果我构建包含一堆计算器功能的库，我不应该假设使用我的图书馆的程序员将要挖掘我的代码并更改乘法函数的方式。它应该是一个黑匣子。他们可以有利于阅读我的源代码并知道它如何出于性能原因或某种东西的工作原理，但原则上，他们唯一需要知道的是他们可以呼叫繁殖（4,2），它将返回8。它们不应该或必要的是，他们改变这个功能。
但作为这个库的维护者，如果乘法不正常工作，或者我弄清楚更有效的方法来实现它，当然我可以做到这一点。修复代码中的错误是接口设计完全分开的问题。
我不知道面试官正在寻找什么，但这是我给予的答案。
更普遍
工程不是以下规则和检查清单的问题。这是关于批判性地思考你的设计决策。什么是权衡？有什么风险？坚实的原则，敏捷的做法，所有这些东西 - 他们是由资深工程师学到的准则，艰难的方式和与较大的社区共享，但这就是他们所在的 - 指导方针。它们并不总是适用于您的用例。如果在任何时候某些思想或标准练习似乎是愚蠢的工程，那么就不要在那种情况下使用它。只需确保您了解为什么您为规则发出异常。如果我在面试的人，那些证明他们都理解规则和何时制造一个例外，他们就会从我这里得到一个竖起大拇指。
谢谢你的A2A VSVH1NH83Z。
回答 4 不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我将会
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我还会注意到这一原则太自由地说，事情应该是开放的延期。不应遗传未明确设计的类别。
关闭部分的开放式原理意味着在大型软件系统中，您通常不会在每次要为特定用例添加新功能时修改现有类（其他代码可能依赖）。
所以，如果我们需要添加一个支持的函数，该函数只有我拥有的一些用例，我不应该将其添加到每个人的导入中的一般模块;相反，我应该将其写成我自己的模块，如果需要，将常规导入常规模块。同样对于一个类：我不应该混乱一类泛型类，每个人都使用了一些特定于我的用例的额外功能 - 在做出任何已经取决于类的所有代码都会进行风险。我应该创建一个用于我用例的新类，如果需要，在我的实现中利用现有类（通过构成或继承）。这样，没有人已经依赖改变，我的变化只会影响我。
如果您确定此类用户的所有用户（大概是，错误修复只需确保满足某些已经承诺的合同，则可以完全修复一个错误即使开放式原理技术上告诉你，你仍然可以随意为现有类添加方法（假设您能够这样做）如果它真的适用于所有类的用户，您可以保证您的所有现有用户都是正确的默认实现。
开放式原则是一个建议而不是一个艰难的规则。不要让它妨碍写好的代码。
回答 5 现在假设第4页，我们看到第十几次上市的租户，但这里是l
想到法律合同。
可以是什么，但让我们说租赁协议。这是应关闭的东西，以修改（除非各方当然同意）。假设合同有少数目标：
漂亮的标准东西。显然，5个子弹不是完整的合同，但与我忍受。
现在假设第4页，我们看到第十次上市的租户，但它将其列为Alice和Bbo。我们可以由于印刷错误而改变该合同吗？当然我们想这样做。我不是律师，所以这可能需要每个人或一个重新签名或其他什么，但我们确实想要修改问题。">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？" />
<meta property="og:description" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？ 回答 1 我不喜欢这个想法，除非物体中的一切都是公开的，或者仅受保护，而不是私人。
如果是的话，因此您可以使用扩展来修复错误。当然，这具有利用相同对象的人的副作用，必须继续与错误一起生活。
这意味着在实践中的原理意味着拧紧其他人，只要它适合我。
否则，如果有真正的私有部分，原则要求您与错误一起生活。这是无法接受的。
回答 2 这一原则是为了确保在其行为中可预测的共同特征，并且不会因个人要求而被操纵
是的，这是一个伎俩问题。面试官可能正在检查您在坚实的“开放式”原则上的理解程度。
“开放式”原则表示，实体应该开放到扩展，但关闭到修改。这意味着您可以使用代码中的功能/库方法，以扩展该功能已在做的内容。但您应该避免将/添加代码更改为共享库方法本身，以满足您的特定要求。
这一原则是确保在其行为中可预测的共同特征，并且不会因其消费者的个人要求而被操纵。它有助于减少添加到共享方法的错误变化的广泛副作用。
如果在常用函数中存在缺陷影响其消费者，则可以更改常见实体以解决问题。 “关闭”部分原则不是在行为不端时未修复功能本身。但是，在修改代码以解决问题之前，开发人员需要确保它实际上是常见功能的问题，而不仅仅是在特定扩展中使用它的错误使用。
回答 3 不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果接线出现问题，那就是错误的
不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果电机可以解决问题会出现问题，这将是错误的修复它？当然不是。这些是两个单独的问题 - 一个关于系统的适当设计理念，另一个关于有价值的特征的实际交付。
所以它与所有的固体原则有关。您通常应该避免用许多职责写作方法。给定类的目的应该是连贯的，具体的尽可能具体。您的所有子类通常都应该替代他们的父类。等等。
所以情况是开放式原理。如果我构建包含一堆计算器功能的库，我不应该假设使用我的图书馆的程序员将要挖掘我的代码并更改乘法函数的方式。它应该是一个黑匣子。他们可以有利于阅读我的源代码并知道它如何出于性能原因或某种东西的工作原理，但原则上，他们唯一需要知道的是他们可以呼叫繁殖（4,2），它将返回8。它们不应该或必要的是，他们改变这个功能。
但作为这个库的维护者，如果乘法不正常工作，或者我弄清楚更有效的方法来实现它，当然我可以做到这一点。修复代码中的错误是接口设计完全分开的问题。
我不知道面试官正在寻找什么，但这是我给予的答案。
更普遍
工程不是以下规则和检查清单的问题。这是关于批判性地思考你的设计决策。什么是权衡？有什么风险？坚实的原则，敏捷的做法，所有这些东西 - 他们是由资深工程师学到的准则，艰难的方式和与较大的社区共享，但这就是他们所在的 - 指导方针。它们并不总是适用于您的用例。如果在任何时候某些思想或标准练习似乎是愚蠢的工程，那么就不要在那种情况下使用它。只需确保您了解为什么您为规则发出异常。如果我在面试的人，那些证明他们都理解规则和何时制造一个例外，他们就会从我这里得到一个竖起大拇指。
谢谢你的A2A VSVH1NH83Z。
回答 4 不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我将会
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我还会注意到这一原则太自由地说，事情应该是开放的延期。不应遗传未明确设计的类别。
关闭部分的开放式原理意味着在大型软件系统中，您通常不会在每次要为特定用例添加新功能时修改现有类（其他代码可能依赖）。
所以，如果我们需要添加一个支持的函数，该函数只有我拥有的一些用例，我不应该将其添加到每个人的导入中的一般模块;相反，我应该将其写成我自己的模块，如果需要，将常规导入常规模块。同样对于一个类：我不应该混乱一类泛型类，每个人都使用了一些特定于我的用例的额外功能 - 在做出任何已经取决于类的所有代码都会进行风险。我应该创建一个用于我用例的新类，如果需要，在我的实现中利用现有类（通过构成或继承）。这样，没有人已经依赖改变，我的变化只会影响我。
如果您确定此类用户的所有用户（大概是，错误修复只需确保满足某些已经承诺的合同，则可以完全修复一个错误即使开放式原理技术上告诉你，你仍然可以随意为现有类添加方法（假设您能够这样做）如果它真的适用于所有类的用户，您可以保证您的所有现有用户都是正确的默认实现。
开放式原则是一个建议而不是一个艰难的规则。不要让它妨碍写好的代码。
回答 5 现在假设第4页，我们看到第十几次上市的租户，但这里是l
想到法律合同。
可以是什么，但让我们说租赁协议。这是应关闭的东西，以修改（除非各方当然同意）。假设合同有少数目标：
漂亮的标准东西。显然，5个子弹不是完整的合同，但与我忍受。
现在假设第4页，我们看到第十次上市的租户，但它将其列为Alice和Bbo。我们可以由于印刷错误而改变该合同吗？当然我们想这样做。我不是律师，所以这可能需要每个人或一个重新签名或其他什么，但我们确实想要修改问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiangqingw.github.io/posts/a-tech-interviewer-once-got-me-stuck-with-a-question-so-the-open-closed-principle-states-you-should-not-modify-existing-behavior-and-what-if-theres-a-bug-in-it-you-dont-fix-it-how-was-i-supposed-to-answer-this/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-23T22:08:11+08:00" />
<meta property="article:modified_time" content="2022-01-23T22:08:11+08:00" />

<meta itemprop="name" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？">
<meta itemprop="description" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？ 回答 1 我不喜欢这个想法，除非物体中的一切都是公开的，或者仅受保护，而不是私人。
如果是的话，因此您可以使用扩展来修复错误。当然，这具有利用相同对象的人的副作用，必须继续与错误一起生活。
这意味着在实践中的原理意味着拧紧其他人，只要它适合我。
否则，如果有真正的私有部分，原则要求您与错误一起生活。这是无法接受的。
回答 2 这一原则是为了确保在其行为中可预测的共同特征，并且不会因个人要求而被操纵
是的，这是一个伎俩问题。面试官可能正在检查您在坚实的“开放式”原则上的理解程度。
“开放式”原则表示，实体应该开放到扩展，但关闭到修改。这意味着您可以使用代码中的功能/库方法，以扩展该功能已在做的内容。但您应该避免将/添加代码更改为共享库方法本身，以满足您的特定要求。
这一原则是确保在其行为中可预测的共同特征，并且不会因其消费者的个人要求而被操纵。它有助于减少添加到共享方法的错误变化的广泛副作用。
如果在常用函数中存在缺陷影响其消费者，则可以更改常见实体以解决问题。 “关闭”部分原则不是在行为不端时未修复功能本身。但是，在修改代码以解决问题之前，开发人员需要确保它实际上是常见功能的问题，而不仅仅是在特定扩展中使用它的错误使用。
回答 3 不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果接线出现问题，那就是错误的
不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果电机可以解决问题会出现问题，这将是错误的修复它？当然不是。这些是两个单独的问题 - 一个关于系统的适当设计理念，另一个关于有价值的特征的实际交付。
所以它与所有的固体原则有关。您通常应该避免用许多职责写作方法。给定类的目的应该是连贯的，具体的尽可能具体。您的所有子类通常都应该替代他们的父类。等等。
所以情况是开放式原理。如果我构建包含一堆计算器功能的库，我不应该假设使用我的图书馆的程序员将要挖掘我的代码并更改乘法函数的方式。它应该是一个黑匣子。他们可以有利于阅读我的源代码并知道它如何出于性能原因或某种东西的工作原理，但原则上，他们唯一需要知道的是他们可以呼叫繁殖（4,2），它将返回8。它们不应该或必要的是，他们改变这个功能。
但作为这个库的维护者，如果乘法不正常工作，或者我弄清楚更有效的方法来实现它，当然我可以做到这一点。修复代码中的错误是接口设计完全分开的问题。
我不知道面试官正在寻找什么，但这是我给予的答案。
更普遍
工程不是以下规则和检查清单的问题。这是关于批判性地思考你的设计决策。什么是权衡？有什么风险？坚实的原则，敏捷的做法，所有这些东西 - 他们是由资深工程师学到的准则，艰难的方式和与较大的社区共享，但这就是他们所在的 - 指导方针。它们并不总是适用于您的用例。如果在任何时候某些思想或标准练习似乎是愚蠢的工程，那么就不要在那种情况下使用它。只需确保您了解为什么您为规则发出异常。如果我在面试的人，那些证明他们都理解规则和何时制造一个例外，他们就会从我这里得到一个竖起大拇指。
谢谢你的A2A VSVH1NH83Z。
回答 4 不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我将会
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我还会注意到这一原则太自由地说，事情应该是开放的延期。不应遗传未明确设计的类别。
关闭部分的开放式原理意味着在大型软件系统中，您通常不会在每次要为特定用例添加新功能时修改现有类（其他代码可能依赖）。
所以，如果我们需要添加一个支持的函数，该函数只有我拥有的一些用例，我不应该将其添加到每个人的导入中的一般模块;相反，我应该将其写成我自己的模块，如果需要，将常规导入常规模块。同样对于一个类：我不应该混乱一类泛型类，每个人都使用了一些特定于我的用例的额外功能 - 在做出任何已经取决于类的所有代码都会进行风险。我应该创建一个用于我用例的新类，如果需要，在我的实现中利用现有类（通过构成或继承）。这样，没有人已经依赖改变，我的变化只会影响我。
如果您确定此类用户的所有用户（大概是，错误修复只需确保满足某些已经承诺的合同，则可以完全修复一个错误即使开放式原理技术上告诉你，你仍然可以随意为现有类添加方法（假设您能够这样做）如果它真的适用于所有类的用户，您可以保证您的所有现有用户都是正确的默认实现。
开放式原则是一个建议而不是一个艰难的规则。不要让它妨碍写好的代码。
回答 5 现在假设第4页，我们看到第十几次上市的租户，但这里是l
想到法律合同。
可以是什么，但让我们说租赁协议。这是应关闭的东西，以修改（除非各方当然同意）。假设合同有少数目标：
漂亮的标准东西。显然，5个子弹不是完整的合同，但与我忍受。
现在假设第4页，我们看到第十次上市的租户，但它将其列为Alice和Bbo。我们可以由于印刷错误而改变该合同吗？当然我们想这样做。我不是律师，所以这可能需要每个人或一个重新签名或其他什么，但我们确实想要修改问题。"><meta itemprop="datePublished" content="2022-01-23T22:08:11+08:00" />
<meta itemprop="dateModified" content="2022-01-23T22:08:11+08:00" />
<meta itemprop="wordCount" content="212">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？"/>
<meta name="twitter:description" content="一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？ 回答 1 我不喜欢这个想法，除非物体中的一切都是公开的，或者仅受保护，而不是私人。
如果是的话，因此您可以使用扩展来修复错误。当然，这具有利用相同对象的人的副作用，必须继续与错误一起生活。
这意味着在实践中的原理意味着拧紧其他人，只要它适合我。
否则，如果有真正的私有部分，原则要求您与错误一起生活。这是无法接受的。
回答 2 这一原则是为了确保在其行为中可预测的共同特征，并且不会因个人要求而被操纵
是的，这是一个伎俩问题。面试官可能正在检查您在坚实的“开放式”原则上的理解程度。
“开放式”原则表示，实体应该开放到扩展，但关闭到修改。这意味着您可以使用代码中的功能/库方法，以扩展该功能已在做的内容。但您应该避免将/添加代码更改为共享库方法本身，以满足您的特定要求。
这一原则是确保在其行为中可预测的共同特征，并且不会因其消费者的个人要求而被操纵。它有助于减少添加到共享方法的错误变化的广泛副作用。
如果在常用函数中存在缺陷影响其消费者，则可以更改常见实体以解决问题。 “关闭”部分原则不是在行为不端时未修复功能本身。但是，在修改代码以解决问题之前，开发人员需要确保它实际上是常见功能的问题，而不仅仅是在特定扩展中使用它的错误使用。
回答 3 不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果接线出现问题，那就是错误的
不，这是荒谬的。
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。
这是否意味着，如果电机可以解决问题会出现问题，这将是错误的修复它？当然不是。这些是两个单独的问题 - 一个关于系统的适当设计理念，另一个关于有价值的特征的实际交付。
所以它与所有的固体原则有关。您通常应该避免用许多职责写作方法。给定类的目的应该是连贯的，具体的尽可能具体。您的所有子类通常都应该替代他们的父类。等等。
所以情况是开放式原理。如果我构建包含一堆计算器功能的库，我不应该假设使用我的图书馆的程序员将要挖掘我的代码并更改乘法函数的方式。它应该是一个黑匣子。他们可以有利于阅读我的源代码并知道它如何出于性能原因或某种东西的工作原理，但原则上，他们唯一需要知道的是他们可以呼叫繁殖（4,2），它将返回8。它们不应该或必要的是，他们改变这个功能。
但作为这个库的维护者，如果乘法不正常工作，或者我弄清楚更有效的方法来实现它，当然我可以做到这一点。修复代码中的错误是接口设计完全分开的问题。
我不知道面试官正在寻找什么，但这是我给予的答案。
更普遍
工程不是以下规则和检查清单的问题。这是关于批判性地思考你的设计决策。什么是权衡？有什么风险？坚实的原则，敏捷的做法，所有这些东西 - 他们是由资深工程师学到的准则，艰难的方式和与较大的社区共享，但这就是他们所在的 - 指导方针。它们并不总是适用于您的用例。如果在任何时候某些思想或标准练习似乎是愚蠢的工程，那么就不要在那种情况下使用它。只需确保您了解为什么您为规则发出异常。如果我在面试的人，那些证明他们都理解规则和何时制造一个例外，他们就会从我这里得到一个竖起大拇指。
谢谢你的A2A VSVH1NH83Z。
回答 4 不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我将会
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。
首先让我们看看开放式原则是什么：
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。
我还会注意到这一原则太自由地说，事情应该是开放的延期。不应遗传未明确设计的类别。
关闭部分的开放式原理意味着在大型软件系统中，您通常不会在每次要为特定用例添加新功能时修改现有类（其他代码可能依赖）。
所以，如果我们需要添加一个支持的函数，该函数只有我拥有的一些用例，我不应该将其添加到每个人的导入中的一般模块;相反，我应该将其写成我自己的模块，如果需要，将常规导入常规模块。同样对于一个类：我不应该混乱一类泛型类，每个人都使用了一些特定于我的用例的额外功能 - 在做出任何已经取决于类的所有代码都会进行风险。我应该创建一个用于我用例的新类，如果需要，在我的实现中利用现有类（通过构成或继承）。这样，没有人已经依赖改变，我的变化只会影响我。
如果您确定此类用户的所有用户（大概是，错误修复只需确保满足某些已经承诺的合同，则可以完全修复一个错误即使开放式原理技术上告诉你，你仍然可以随意为现有类添加方法（假设您能够这样做）如果它真的适用于所有类的用户，您可以保证您的所有现有用户都是正确的默认实现。
开放式原则是一个建议而不是一个艰难的规则。不要让它妨碍写好的代码。
回答 5 现在假设第4页，我们看到第十几次上市的租户，但这里是l
想到法律合同。
可以是什么，但让我们说租赁协议。这是应关闭的东西，以修改（除非各方当然同意）。假设合同有少数目标：
漂亮的标准东西。显然，5个子弹不是完整的合同，但与我忍受。
现在假设第4页，我们看到第十次上市的租户，但它将其列为Alice和Bbo。我们可以由于印刷错误而改变该合同吗？当然我们想这样做。我不是律师，所以这可能需要每个人或一个重新签名或其他什么，但我们确实想要修改问题。"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3W09QM57NF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3W09QM57NF', { 'anonymize_ip': false });
}
</script>



  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        知识的阶梯
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-23T22:08:11+08:00">January 23, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="一个技术面试官曾经让我陷入困境因此开放式原则状态您不应修改现有行为如果它有什么虫子怎么了你不修复它我该怎么回答这个">一个技术面试官曾经让我陷入困境：因此，开放式原则状态您不应修改现有行为。如果它有什么虫子，怎么了？你不修复它？我该怎么回答这个？</h2>
<h3 id="回答-1">回答 1</h3>
<p>我不喜欢这个想法，除非物体中的一切都是公开的，或者仅受保护，而不是私人。<br>
如果是的话，因此您可以使用扩展来修复错误。当然，这具有利用相同对象的人的副作用，必须继续与错误一起生活。<br>
这意味着在实践中的原理意味着拧紧其他人，只要它适合我。<br>
否则，如果有真正的私有部分，原则要求您与错误一起生活。这是无法接受的。</p>
<h3 id="回答-2">回答 2</h3>
<p>这一原则是为了确保在其行为中可预测的共同特征，并且不会因个人要求而被操纵<br>
是的，这是一个伎俩问题。面试官可能正在检查您在坚实的“开放式”原则上的理解程度。<br>
“开放式”原则表示，实体应该开放到扩展，但关闭到修改。这意味着您可以使用代码中的功能/库方法，以扩展该功能已在做的内容。但您应该避免将/添加代码更改为共享库方法本身，以满足您的特定要求。<br>
这一原则是确保在其行为中可预测的共同特征，并且不会因其消费者的个人要求而被操纵。它有助于减少添加到共享方法的错误变化的广泛副作用。<br>
如果在常用函数中存在缺陷影响其消费者，则可以更改常见实体以解决问题。 “关闭”部分原则不是在行为不端时未修复功能本身。但是，在修改代码以解决问题之前，开发人员需要确保它实际上是常见功能的问题，而不仅仅是在特定扩展中使用它的错误使用。</p>
<h3 id="回答-3">回答 3</h3>
<p>不，这是荒谬的。<br>
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。<br>
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。<br>
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。<br>
这是否意味着，如果接线出现问题，那就是错误的<br>
不，这是荒谬的。<br>
为了执行有效的面向对象的模块化设计，固体原则是您遵循的原则。<br>
当您设计要消耗的界面时，您正在尝试设计一些将简单且容易在其代码库中实现的东西。<br>
对于一个非常基本的例子，请考虑一下灯开关。光开关的用户不需要了解电气工程或物理以便操作它。他们应该能够在或关闭它，光应该工作。<br>
这是否意味着，如果电机可以解决问题会出现问题，这将是错误的修复它？当然不是。这些是两个单独的问题 - 一个关于系统的适当设计理念，另一个关于有价值的特征的实际交付。<br>
所以它与所有的固体原则有关。您通常应该避免用许多职责写作方法。给定类的目的应该是连贯的，具体的尽可能具体。您的所有子类通常都应该替代他们的父类。等等。<br>
所以情况是开放式原理。如果我构建包含一堆计算器功能的库，我不应该假设使用我的图书馆的程序员将要挖掘我的代码并更改乘法函数的方式。它应该是一个黑匣子。他们可以有利于阅读我的源代码并知道它如何出于性能原因或某种东西的工作原理，但原则上，他们唯一需要知道的是他们可以呼叫繁殖（4,2），它将返回8。它们不应该或必要的是，他们改变这个功能。<br>
但作为这个库的维护者，如果乘法不正常工作，或者我弄清楚更有效的方法来实现它，当然我可以做到这一点。修复代码中的错误是接口设计完全分开的问题。<br>
我不知道面试官正在寻找什么，但这是我给予的答案。<br>
更普遍<br>
工程不是以下规则和检查清单的问题。这是关于批判性地思考你的设计决策。什么是权衡？有什么风险？坚实的原则，敏捷的做法，所有这些东西 - 他们是由资深工程师学到的准则，艰难的方式和与较大的社区共享，但这就是他们所在的 - 指导方针。它们并不总是适用于您的用例。如果在任何时候某些思想或标准练习似乎是愚蠢的工程，那么就不要在那种情况下使用它。只需确保您了解为什么您为规则发出异常。如果我在面试的人，那些证明他们都理解规则和何时制造一个例外，他们就会从我这里得到一个竖起大拇指。<br>
谢谢你的A2A VSVH1NH83Z。</p>
<h3 id="回答-4">回答 4</h3>
<p>不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。<br>
首先让我们看看开放式原则是什么：<br>
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。<br>
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。<br>
我将会<br>
不，这完全不是开放式原则的意图 - 这是哲学的方式太远了。您应该显然修复代码中的错误。<br>
首先让我们看看开放式原则是什么：<br>
软件实体（类，模块，函数等）应打开扩展，但已关闭以进行修改。<br>
现在，这适用于较大的软件系统。我们希望关闭修改的事情的原因是我们不会修改许多其他组件可能取决于的东西。所以，当你只有几百条代码时，随意忽略这一原则。<br>
我还会注意到这一原则太自由地说，事情应该是开放的延期。不应遗传未明确设计的类别。<br>
关闭部分的开放式原理意味着在大型软件系统中，您通常不会在每次要为特定用例添加新功能时修改现有类（其他代码可能依赖）。<br>
所以，如果我们需要添加一个支持的函数，该函数只有我拥有的一些用例，我不应该将其添加到每个人的导入中的一般模块;相反，我应该将其写成我自己的模块，如果需要，将常规导入常规模块。同样对于一个类：我不应该混乱一类泛型类，每个人都使用了一些特定于我的用例的额外功能 - 在做出任何已经取决于类的所有代码都会进行风险。我应该创建一个用于我用例的新类，如果需要，在我的实现中利用现有类（通过构成或继承）。这样，没有人已经依赖改变，我的变化只会影响我。<br>
如果您确定此类用户的所有用户（大概是，错误修复只需确保满足某些已经承诺的合同，则可以完全修复一个错误即使开放式原理技术上告诉你，你仍然可以随意为现有类添加方法（假设您能够这样做）如果它真的适用于所有类的用户，您可以保证您的所有现有用户都是正确的默认实现。<br>
开放式原则是一个建议而不是一个艰难的规则。不要让它妨碍写好的代码。</p>
<h3 id="回答-5">回答 5</h3>
<p>现在假设第4页，我们看到第十几次上市的租户，但这里是l<br>
想到法律合同。<br>
可以是什么，但让我们说租赁协议。这是应关闭的东西，以修改（除非各方当然同意）。假设合同有少数目标：<br>
漂亮的标准东西。显然，5个子弹不是完整的合同，但与我忍受。<br>
现在假设第4页，我们看到第十次上市的租户，但它将其列为Alice和Bbo。我们可以由于印刷错误而改变该合同吗？当然我们想这样做。我不是律师，所以这可能需要每个人或一个重新签名或其他什么，但我们确实想要修改问题。<br>
修改不会影响合同或其消费者。<br>
这就是错误修复相似之处的地方。如果我们有一个课程关闭修改，其工作是提供一名员工，但我们有一个错误，即使是最近的公司假期的错误，那么雇员被雇用，这不是公司假期&hellip;&hellip;是的，解决这个问题。<br>
因为我们没有修改这一课程的合同，以便与消费者保持维持，我们确保合同遵循合同。<br>
就像爱丽丝和鲍勃一样，我们并没有表明一些神秘的第三方BBO是专门对没有宠物的责任，但是鲍勃正在休息的困境中，我们确保该单位的一切都与鲍勃有关。<br>
您可以争辩说代码甚至没有完成。<br>
考虑测试驱动的发展一会儿，如红绿或平躺式编码。<br>
我们有一个将向扩展开放的课程，但关闭修改。我们编写了一个故障测试，我们编写代码以使其通过。我们继续编写更广泛，更接近边缘案例测试，并继续以这样的方式实现代码来传递所有测试用例，因此所有使用情况。<br>
好吧，如果我们错过了测试/用例，我们是否真的正确地完成了代码？纪念的合同从未完全写过，所以从一定的角度来看，我们正在完成工作，而不是修改代码。<br>
很多方法来看这一点，但是当那样的问题弹出时，肯定会看看校长是什么 - 确保代码的消费者不会意外爆炸，在那里，在这种情况下。当我们想要一个int时，不要返回颜色字符串，因为任何人称该方法都会破坏，那就是一般目标。</p>
<h3 id="回答-6">回答 6</h3>
<p>开孔原理意味着打开扩展，关闭以改变。如果您愿意，您仍然可以子类（派生）来改变行为。这是多态性的整个点。<br>
如果您的派生对象堕落（表现差），您可能会归咎于LISKOV替换原则（LSP）<br>
如果是一个错误，你当然修复它。除非修复它会导致更多问题。<br>
我的答案是：理想情况下，我的对象将没有错误，因为有足够的测试覆盖率来确保正确的行为。但是如果发现错误，ID希望尽快修复它，根据需要更新单元测试，因此问题不会重新出现。离开这个错误会创造技术债务并将可以击倒其他开发商的路。唯一的id留下一个错误是如果修复它会破坏其他东西，或者科技领域认为它不值得的时间。</p>
<h3 id="回答-7">回答 7</h3>
<p>开放的封闭原则是废话作为原则，如：<br>
没有人应该撒谎。<br>
从这里阅读：</p>
<h3 id="回答-8">回答 8</h3>
<p>这真的取决于错误是什么。有几类不同的错误：<br>
尤其可以由客户使用＃3和＃4，如果改变行为，它们可能是不满意的。 ＃1几乎肯定应该是固定的。 ＃2可以辩论，有人用吗？如果是这样，后果是什么？ ＃5肯定可以更改，除非功能的时间确实指定为代码的功能描述的一部分<br>
开放式原则的一般原则是您不会更改现有行为，但您可以为接口添加其他功能。这并不意味着，如果代码在某人使用该软件的情况下，如果某人不打算使用的方式，则不应修复实际的真实错误 - 那么这绝对不是突破现有功能（它从未首先工作过）。同样，优化可以并且应该完成，其中内部行为可能会改变，但只有所花费的时间将从外部视图改变。<br>
人们做（MIS）有时使用功能。在Linux中，如果您有一个指向内存的指针，并且以字节为单位，并且要检查该指针是否确实有效并且内存是可读的，则可以调用Write（-1，指针，大小） - 因为操作系统将首先检查它可以进行指针+ +大小的有效副本，然后检查文件描述符（-1）并返回文件描述符无效的错误。 errno将在文件描述符与内存复制失败之间存在不同。这显然不会在它的意图中使用该功能，但预计将继续这样工作。</p>
<h3 id="回答-9">回答 9</h3>
<p>错误不是现有行为的特征;因此，如果修改它以修复不正确的行为，则不会修改现有行为</p>
<h3 id="回答-10">回答 10</h3>
<p>那是假设OOP  - 我没有。我必须先看到代码。（只要您展示您了解问题的参数，应该满足一个良好的面试官。[大多数猎头者不是非常科技的，所以他可能想要他在他的书中拥有的答案 - 谁知道这可能是什么？这是我认为我会把我的事业带给一个真正了解的人的问题。（我已经进行了技术面试 - 我永远不会问一个这样的问题。）]）</p>
<h3 id="回答-11">回答 11</h3>
<p>您肯定会在此时按照预期的方式记录行为 - 这很重要，尤其是*在这种情况下，它不是预期的。<br>
将更改此行为以更具逻辑/理智的方式，将计划为未成年人或重大释放，以至于消费者可以在预期行为中处理其变更以协商其变更。</p>
<h3 id="回答-12">回答 12</h3>
<p>招牌<br>
我认为有两种方法可以接近这个问题。<br>
问题可以简单地询问态度的冲突：该实体已关闭修改，但我们需要修改它以修复错误。如果是这样的话，那么我们当然会修复错误，如果实用。开放式原则是关于没有改变实体的行为在没有改变实体的意义上。通过修复一个实施错误，我们并没有违反开放式原则，因为错误的合同破坏或有害行为，从错误的代码结果不是模块所做的那样的一部分。<br>
除非是！这种问题可以接近的第二种方式是在将意外行为的演变中纳入对象的使用。如果客户端代码取决于窃听行为，那么在某种意义上，用户已重新定义模块的合同并修复错误将更改该模块所做的内容。因此，开放式原则与错误修复相关。</p>
<h3 id="回答-13">回答 13</h3>
<p>这是一个务实的软件设计和（更重要的）维护问题。<br>
即使有完整的测试，应用任何有意义的大小和复杂性的应用是非常罕见的。<br>
这是需要有机测试的位置：在实践中，使用足够复杂的应用程序，您无法编写测试并执行它们以验证并记录100％输入 - &gt;输出以定义正确的内容：测试套件设计需要优先考虑什么最重要的是知道有效和h &hellip;</p>
<h3 id="回答-14">回答 14</h3>
<p>来自#cleancode视图，错误意味着，行为不对，因此在正确的地方修复它。<br>
修复错误或回归不是关于更改或添加新行为，请确保使用正确的代码放置正确的行为。很值得这种原因，如果错误是依赖的开源组件，则始终建议向组件所有者报告（即包括OpenSource供应商）。<br>
更改行为意味着，假设方法是否正在执行乘法，现在您也希望允许它添加（编码练习不好），然后它为现有乘法添加新行为。当乘法中存在错误时，修复该乘法方法是强制性的，因为不适用开放式原理。<br>
在这种情况下，关闭的是，方法名称，应该不会改变，因为有些人可能正在使用它（如果乘法方法是非最终的公共或接口方法），如果有任何喜欢&rsquo;添加&rsquo;也，他可以继承这个父类，并做任何他想做的事情，以便多态可以开始工作。<br>
因此，出于这个原因，开放/关闭的主要少数作者称为多态性开放/关闭原则。</p>
<h3 id="回答-15">回答 15</h3>
<p>如果错误不支持新要求（您的Blackjack G<br>
开放式原理是指将功能添加到已完成的类。<br>
完成的类是一个类的类，其中创建了类时的所有行为是由测试涵盖的，并且所有这些测试都通过它。<br>
如果此bug是在类的预期行为中（例如，未正确处理空中传递到函数）而不是暗中隐藏新功能时，则表示课程未完成，您可以精细添加更多测试到现有类，并修复了错误。<br>
如果错误不支持新的要求（您的Blackjack游戏不处理Uno卡），那么您应该按照OCP遵循并将新功能作为现有类的扩展实现。<br>
请注意，即使在第二种情况下，也可能不会避免更改原始类至少一点点。<br>
因此，开放的原则通常不是一项规则，即您不允许更改现有行为，而是通过期望通过编写新代码添加功能的期望来设计您的课程，只有现有代码所需的最小更改，</p>
<h3 id="回答-16">回答 16</h3>
<p>你首先说这是一个设计原则，而不是自然的法则。与所有设计原则一样，其应用是设计权衡和判断呼叫的问题。<br>
然后我会讨论开放/关闭的原则实际上是什么，并与利斯沃替代原则进行比较和对比，人们经常与开放/关闭原则混淆。</p>
<h3 id="回答-17">回答 17</h3>
<p>我怀疑这是关于货物邪教编程危险的问题。非常重要的是要理解，应该理解开放的封闭原理等原则，并不盲目地遵循。</p>
<h3 id="回答-18">回答 18</h3>
<p>如果bug是'<br>
问题需要更多的错误定义。有人报告了代码的问题吗？你在做另一个修改时发现了吗？你在做另一个修改时创建它吗？开放式原则状态，您不会返回并无缘无故地更改界面。相反，您扩展了功能。如果您发现您认为的错误，那么您将与团队的其余部分讨论。如果它是一个报告的错误，那么你可以以不打破其他代码的方式修复它。如果有单元测试，则会查看为什么单位测试不涵盖此条件。<br>
如果错误不会导致问题，最好记录并单独留下它。有些用户可能会对该行为进行计数。它还取决于谁使用此代码。如果它只是内部使用，那么虽然原则适用于此可能不是那么相关。如果有成千上万的人使用它，那么避免打破界面很聪明。<br>
根据这些答案的一个选项是创建一个没有BUG的第二个API调用，以便使用两个路径。随着时间的推移，可以将人们迁移到新的API，并最终将其中退出其中的错误。</p>
<h3 id="回答-19">回答 19</h3>
<p>纠正<br>
所有设计原则都不重要而不是正确性。程序的第一个属性是做正确的事情。优雅地做得很好，但不太重要。<br>
如果错误需要修复（而不是推迟或被接受为限制），那么您可以在世界上所有权利打破现有的设计来解决它。不是你应该或大部分时间，但是它是允许的。<br>
更重要的是要确保飞机不会崩溃，而不是允许飞机崩溃，但在代码中具有更美丽的设计。<br>
无论如何，大多数错误都不是设计<br>
涉及<br>
纠正<br>
所有设计原则都不重要而不是正确性。程序的第一个属性是做正确的事情。优雅地做得很好，但不太重要。<br>
如果错误需要修复（而不是推迟或被接受为限制），那么您可以在世界上所有权利打破现有的设计来解决它。不是你应该或大部分时间，但是它是允许的。<br>
更重要的是要确保飞机不会崩溃，而不是允许飞机崩溃，但在代码中具有更美丽的设计。<br>
无论如何，大多数错误都不是设计<br>
与开放式/关闭原则有关。<br>
也许您可以看到您的错误修复，如扩展或不同的功能来开发和与现有代码相结合。并保持设计原则很好。所以要做。<br>
也许您可以将错误视为给定的代码无法实现其当前合同。然后，如果修改代码以使其遵守，您实际上没有执行任何修改或扩展。您更正了代码，以便实现实际上符合合同。太棒了。你没有违反任何原则。<br>
也许当前的设计不再适合，并且需要重构。然后你做这个重构（见下一个点）<br>
重构整个东西完全有效<br>
设计的伟大原则适用于给定的时间点。目标是确保代码易于理解，维护和发展。所以人们可以检查代码，阅读它，了解它。<br>
代码的版本1遵守原则：伟大。 v2坚持原则：伟大。设计变化了吗？没关系。<br>
我们不在乎代码更改时发生了什么。最有可能在某些计算机上崩溃的一点，没有编译。没人关心。只要您能够生成体面的v2，您就像开发人员一样。<br>
如果v2更改设计，这就是我们称之为重构的东西。<br>
案件是案件<br>
大多数错误将被拒绝，因为软件实际上已经表现得很好。有些人需要小变化，其他可能需要完整的重写（希望不经常）。你将在两者之间拥有一切。<br>
通常可以解决几种解决方案。即使有些人比其他人更加明显，它实际上存在无限数量。<br>
它是您工作的一部分，作为开发人员选择一个体面的人来修复错误并使其工作。</p>
<h3 id="回答-20">回答 20</h3>
<p>如果您了解原则或者只是记住定义，这是一个诀窍的问题。<br>
开放式原则并不意味着我们不会改变代码。<br>
它意味着对象之外的代码永远不会修改对象的内部行为，但可以扩展它。在JavaScript中，任何代码都可以更改对象属性，即使是原型。这不好。在运行时的任何点处，可以通过任何任意代码更改对象行为。因此，为什么创建符号类型，以隐藏对象属性。<br>
ID答案，这不是开放式原理的意思。你修复了错误。</p>
<h3 id="回答-21">回答 21</h3>
<p>好吧，我们的意思是什么？修复我们的意思是什么？一些错误可能需要修复，如安全漏洞。否则，假设现有功能正在运行，那么您可能会理想地想要提供某种扩展或备用功能来解决新功能。通过生成包装器来说，您可以通过几种方式执行此操作（即您可以在不同的类中添加新功能，然后通过组合创建一个结合旧的和新的Foreface。您可以简单地提供一个新的并行API，任何需要新功能使用而不是旧API，或者除此之外（仅适用于新的东西）等。<br>
如今，很多这类东西最终有关Web服务。在那里有更大的灵活性，因为新的和旧的东西可以在不同的端点中共存。所以，/v2.0/ url路径可以做任何它想要的，而旧的/v1.0 /仍然存在于需要它的人那里。也许你最终会弃用它，无论如何。</p>
<h3 id="回答-22">回答 22</h3>
<p>最常见的候选人问我是白板代码是否必须是错误的。这个问题往往是伴随着这个建议，这只是刚刚真实。inded，它往往没有。避免返回。重要的是错误的代码在现实世界中？你可能发现它有点难以回答这个问题.bugs永远不会好。所有其他都是平等的，你更喜欢错误的错误代码。但是一只错误一般都会让你解雇。如果它确实有一个错误，那么我们都没有乔布斯。在采访中，理想显然没有Bugs.bugs永远不可能;显然，你的面试官更喜欢看到更少的错误。这并不意味着你会因为有一个错误而被拒绝。你修复它。错误指示<br>
您的代码是您的代码示例，您的采访者从中推断有关您的编码技能的信息。正常性并不重要，它本身并不重要。如此：</p>
<!-- raw HTML omitted -->
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiangqingw.github.io/" >
    &copy;  知识的阶梯 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
